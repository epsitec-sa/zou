#!/bin/bash

[[ -z $ZOUL_GIT_VTABLE ]]         && . zoul-git-vtable
[[ -z $ZOUL_GIT_CONFIG_SKU ]]     && . zoul-git-config-sku
[[ -z $ZOUL_GIT_CONFIG_SELECT ]]  && . zoul-git-config-select
[[ -z $ZOUL_GIT_CONFIG_PUBLISH ]] && . zoul-git-config-publish
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_PUBLISH ]] && . zoul-git-branch-publish


moduleId=$(repo_module_id)
# io_message ">>>> git-publish $*" "[$moduleId]" Purple

cmdOpts=()

while [[ "$#" > 0 ]]; do case "$1" in
  -h|--help) zou-help $0; exit 0;;
  -0|--level0)        level0=true;;
  -q|--quiet)         cmdOpts+=($1); quiet=true;;
  -e|--stop-on-error) cmdOpts+=($1); stopOnError=true;;
  -r|--recursive)     cmdOpts+=($1); recursive=true;;
  -v|--vo)            cmdOpts+=($1); vo=true;; # original version (use nearest vtag)
  -u|--reuse)         cmdOpts+=($1); prerelPrefix='reuse';;
  --alpha)            cmdOpts+=($1); prerelPrefix='alpha';;
  --beta)             cmdOpts+=($1); prerelPrefix='beta';;
  --rc)               cmdOpts+=($1); prerelPrefix='rc';;
  --rtm)              cmdOpts+=($1); prerelPrefix='rtm';;
  --debug)            cmdOpts+=($1); debug=true;;
  --_stop-publish)    cmdOpts+=($1); stopPublish=true;;
  --_startup-root)    cmdOpts+=($1 $2); startupRoot=$(echo $2 | xargs echo); shift;;  # remove single quotes
  --_startup-dir)     cmdOpts+=($1 $2); startupDir=$(echo $2 | xargs echo); shift;;  # remove single quotes
  -*) echo "unknown option: $1" >&2; exit 1;;
esac; shift; done

process_error()
{
  [[ $1 -ne 0 && $stopOnError == true ]] && exit $1 || return 0
}
publish_update_vtable()
{
  [[ $recursive == true ]] || return 1
  # io_message "publish_update_vtable ${*@Q}" "[$moduleId]" Gray
  vtable_update "$startupRoot" "$moduleId"
}
publish_commit_vtable()
{
  [[ $recursive == true ]] || return 1
  # io_message "publish_commit_vtable ${*@Q}" "[$moduleId]" Gray
  local branch=$1 vtag=$2 vbranch=$3 ec=0
  vtable_update "$startupRoot" "$moduleId" || ec=$?

  # synchronize dev == prod
  [[ -n $vbranch ]] && branch_merge $branch $vbranch
  [[ -n $vtag ]] && {
    [ $ec -eq 0 ] && io_info "Created vtable for '$branch' at '$vtag'" "[$moduleId]"
    tag_move "$vtag" "$branch"
  }
}
publish_submodules()
{
  # io_warning ">>>> publish_submodules" "[$moduleId]"
  local branchOrTag=$1 opts=( ${!2} ) configFile include exclude path mroot=$PWD ec=0
  configFile=$(repo_zouflow_path "$mroot") || return $?
  include=( $(config_sku_list_included "$branchOrTag" "$configFile") )
  exclude=( $(config_select_list_excluded "$branchOrTag" "$configFile") )
  for path in $(string_sort $(array_remove_array 'include[@]' 'exclude[@]')); do
    cd "$mroot/$path"
    git publish ${opts[@]} || return $?
  done
  # io_warning "<<<< publish_submodules" "[$moduleId]"
}
publish_select_nearest_tag()
{
  local branch=$1 moduleId=$2 branchOrTag ec
  branchOrTag=$(branch_select_nearest_vtag "$branch"); ec=$?
  [ $ec -eq 0 ] && io_info "Already published at '$branchOrTag'" "[$moduleId]"
  [ $ec -eq 1 ] && io_error "Branch '$branchOrTag' was never published" "[$moduleId]"
  [ $ec -eq 2 ] && io_info "Published existing version '$branchOrTag'" "[$moduleId]"
  echo $branchOrTag
  return $ec
}
publish_prolog()
{
  local vo=$1 branch=$(branch_current)

  local label=()
  [[ $stopPublish == true ]] && label+=( 'STOPPED' )
  [[ $vo == true ]] && label+=( 'VO' )
  # io_warning ">>>> publish_prolog ($branch) ${label[*]}" "[$moduleId]"

  repo_require_clean_work_tree 'cannot publish' || return 1

  if [[ $stopPublish == true ]]; then
    # io_message "publish_prolog ($branch) STOPPED" "[$moduleId]" Gray
    echo $branch
    # io_warning "<<<< publish_prolog ($branch) STOPPED DISABLED" "[$moduleId]"
    return 2  # publish disabled
  else
    if [[ $vo == true ]]; then
      if repo_is_bundle_root "$PWD"; then
        # io_message "publish_prolog ($branch) VO+BUNDLE" "[$moduleId]" Gray
        echo $branch
        # io_warning "<<<< publish_prolog ($branch) VO+BUNDLE" "[$moduleId]"
      else
        # io_message "publish_prolog ($branch) VO" "[$moduleId]" Gray
        publish_select_nearest_tag "$branch" "$moduleId"
        # io_warning "<<<< publish_prolog ($branch) VO" "[$moduleId]"
      fi
    elif config_publish_is_enabled "$branch"; then
      # io_message "publish_prolog ($branch) ENABLED" "[$moduleId]" Gray
      branch=$(branch_ensure_current 2>/dev/null) || return 1
      echo $branch
      # io_warning "<<<< publish_prolog ($branch) ENABLED" "[$moduleId]"
    else
      # io_message "publish_prolog ($branch) DISABLED" "[$moduleId]" Gray
      publish_select_nearest_tag "$branch" "$moduleId"
      # io_warning "<<<< publish_prolog ($branch) DISABLED" "[$moduleId]"
      return 2  # publish disabled
    fi
  fi
}
publish_epilog()
{
  local branchOrTag=$1 vo=$2 publishDisabled=$3 info ec=0

  local label=()
  [[ $stopPublish == true ]] && label+=( 'STOPPED' )
  [[ $publishDisabled == true ]] && label+=( 'DISABLED' )
  [[ $vo == true ]] && label+=( 'VO' )
  # io_warning ">>>> publish_epilog ($branchOrTag) ${label[*]}" "[$moduleId]"
  
  if [[ $stopPublish == true || $publishDisabled == true ]]; then
    # io_message "publish_epilog ($branchOrTag) ${label[*]}" "[$moduleId]" Gray
    publish_update_vtable
  elif [[ "$PWD" == "$startupRoot" ]]; then
    if [[ $vo == true ]]; then
      if repo_is_bundle_root "$PWD"; then
        # io_message "publish_epilog ($branchOrTag) VO+BUNDLE" "[$moduleId]" Gray
        info=( $(branch_publish "$branch" "$prerelPrefix") ) || ec=$?
        publish_commit_vtable "$branchOrTag" "${info[@]}"
      # else
      #   io_message "publish_epilog ($branchOrTag) VO" "[$moduleId]" Gray
      fi
    else
      # io_message "publish_epilog ($branchOrTag) ENABLED" "[$moduleId]" Gray
      info=( $(branch_publish "$branch" "$prerelPrefix") ) || ec=$?
      publish_commit_vtable "$branchOrTag" "${info[@]}"
    fi
  else
    if [[ $vo == true ]]; then
      # io_message "publish_epilog ($branchOrTag) VO" "[$moduleId]" Gray
      publish_update_vtable
    else
      # io_message "publish_epilog ($branchOrTag) ENABLED" "[$moduleId]" Gray
      branch_publish "$branch" "$prerelPrefix" >/dev/null || ec=$?
      publish_update_vtable
    fi
  fi
  # io_warning "<<<< publish_epilog ($branchOrTag)" "[$moduleId]"
  return $ec
}
publish_tree()
{
  # io_warning ">>>> publish_tree ${*@Q}" "[$moduleId]"
  [[ $quiet == true ]] || echo Entering "'$(path_make_relative '.' "$startupDir")'"
  local vo=$1 publishDisabled branchOrTag ec=0
  branchOrTag=$(publish_prolog "$vo"); ec=$?
  [[ $ec == 1 ]] && return 1  # error
  [[ $ec == 2 ]] && publishDisabled=true

  if [[ $recursive == true ]]; then
  (
    local opts=( ${cmdOpts[@]} )
    [[ $publishDisabled == true ]] && opts+=( --_stop-publish )
    publish_submodules "$branchOrTag" 'opts[@]'
  ) || process_error $?
  fi
  
  publish_epilog "$branchOrTag" "$vo" "$publishDisabled"
  # io_warning "<<<< publish_tree ${*@Q}" "[$moduleId]"
}

if [[ -z $startupDir ]]; then
(
  startupDir=$PWD
  cmdOpts+=(--_startup-dir "'$startupDir'") # single quote startup dir option value to avoid shell path expansion on Windows
  startupRoot=$(repo_module_root)
  cmdOpts+=(--_startup-root "'$startupRoot'") # single quote startup dir option value to avoid shell path expansion on Windows
  [[ $recursive == true ]] && vtable_init "$startupRoot" "$moduleId"
  cd "$startupRoot"
  publish_tree "$vo" || process_error $?
)
else
  publish_tree "$vo" || process_error $?
fi
