#!/bin/bash

# Defaults:
# - always recursive
# - abstract - create vtable
# - always publish current module
# - do not propagate down prerelPrefix
# - foreach submodule
#     if --merge
#     then { merge and publish } 
#     else { publish last vtag }
#
# Bundle invocation
# - override - always create vtable
#
# Submodule invocation
# - override - create vtable if --vtable && submodule count > 0

# . test-git-repo-data
# cd "$sat1Dir"

[[ -z $ZOUL_LOCK ]]               && . zoul-lock
[[ -z $ZOUL_GIT_MODULE ]]         && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]]         && . zoul-git-config
[[ -z $ZOUL_GIT_COSM ]]           && . zoul-git-cosm
[[ -z $ZOUL_GIT_VTABLE ]]         && . zoul-git-vtable
[[ -z $ZOUL_GIT_BRANCH_CORE ]]    && . zoul-git-branch-core
[[ -z $ZOUL_GIT_CONFIG_SKU ]]     && . zoul-git-config-sku
[[ -z $ZOUL_GIT_CONFIG_SELECT ]]  && . zoul-git-config-select
[[ -z $ZOUL_GIT_CONFIG_PUBLISH ]] && . zoul-git-config-publish
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_PUBLISH ]] && . zoul-git-branch-publish

publish_parse()
{
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -q|--quiet)           quiet=true;;
    -e|--stop-on-error)   stopOnError=true;;
    -j*)                  jobsCount=${1#-j};;
    .)                    unset recursive;;
    -t|--vtable)          vtable=true;;
    -u|--reuse)           prerelPrefix='reuse';;
    --alpha)              prerelPrefix='alpha';;
    --beta)               prerelPrefix='beta';;
    --rc)                 prerelPrefix='rc';;
    --rtm)                prerelPrefix='rtm';;
    --dev)                publishHint='dev';;
    -*) io_error "unknown option '$1'"; return 1;;
  esac; shift; done
}
publish_run()
{
  # parse command line
  local jobsCount quiet stopOnError vtable prerelPrefix publishHint recursive=true
  publish_parse "$@" || return $?

  local commitSubmodules=true \
        publishSelectExcludeIds=() \
        publishScopes=( config_scope cosm_scope )

  module_run "${publishScopes[@]}" publish_main
}
publish_main()
{
  local createVTable

  if [[ $vtable == true ]]; then
    createVTable=true
  elif repo_has_submodules "$startupRoot" && repo_is_bundle_root "$startupRoot"; then
    createVTable=true
  fi
  # trace_method publish_main createVTable

  local lockDir lookupPath
  [[ $createVTable == true ]] && {
    lockDir=$(mktemp -u)
    lookupPath="$(mktemp)"
    vtable_init "$startupRoot" "$lookupPath"
  }
  publish_tree
}
publish_tree()
{
  # feed exclude list with moduleIds (modulePaths by default)
  publishSelectExcludeIds+=( "${configSelectExcludeIds}" )
  # io_trace "publish_tree -- $(print_vars moduleId publishSelectExcludeIds[@])"

  if array_contains_element "$moduleId" "${publishSelectExcludeIds[@]}"; then
    publish_update_vtable
  else
    local ec=0 branchOrTag=$moduleBranch stopPublish neverPublished ffPublish
    publish_prolog || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && return $ec
    [[ $recursive == true ]] && {
      publish_submodules || ec=$?
      [[ $ec -ne 0 && $stopOnError == true ]] && return $ec
    }
    publish_epilog || ec=$?
    return $ec
  fi
}
publish_submodules()
{
  local publishSubmodules=( $(array_sort configSkuInclude[@]) )
  module_visit_submodules_async 'publishSubmodules[@]' "${publishScopes[@]}" 'publish_tree'
}
publish_prolog()
{
  repo_require_clean_work_tree 'Cannot publish' || return 1

  if [[ $stopPublish == true ]]; then
    publish_try_attach
  elif config_publish_is_enabled; then
    if [[ $publishHint == 'dev' || "$PWD" == "$startupRoot" ]]; then
      branchOrTag=$(branch_select_branch "$(branch_best_match_dev $bundleBranch)" 'false') || return 1
    else
      publish_select_vtag
    fi
  else
    publish_select_vtag
    stopPublish=true
  fi
}
publish_epilog()
{
  local info ec=0
  
  cosm_process_unstaged_submodules

  if [[ $stopPublish == true ]]; then
    publish_update_vtable
  elif [[ "$PWD" == "$startupRoot" ]]; then
    # in startup module
    info=( $(branch_publish "$branchOrTag" "$prerelPrefix") ) || ec=$?
    publish_try_attach
    publish_commit_vtable "$branchOrTag" "${info[@]}"
  else
    # in submodule
    if [[ $publishHint == 'dev' ]]; then
      branch_publish "$branchOrTag" "$prerelPrefix" >/dev/null || ec=$?
      publish_try_attach
      publish_update_vtable
    else
      if [[ $neverPublished == true ]]; then
        branch_publish >/dev/null || ec=$?
        publish_try_attach
      elif [[ $ffPublish == true ]]; then
        local branch=$moduleBranch vbranch=$(vtag_get_vbranch_name $branchOrTag)
        branch_merge $vbranch $branch
        publish_try_attach
        io_success "Published branch '$branch' on vbranch '$vbranch' at ${Brown}$branchOrTag${Green} (fast-forward)" "$moduleTracePrefix"
      fi
      publish_update_vtable
    fi
  fi
  # io_warning "<<<< publish_epilog ($branchOrTag)" "$moduleTracePrefix"
  return $ec
}
publish_select_vtag()
{
  local branch=$branchOrTag vtag
  branchOrTag=$(branch_select_vtag "$(branch_realize $branchOrTag)" false)

  case $? in
  0)
    io_success "Published existing version ${Brown}$branchOrTag" "$moduleTracePrefix";;
  1)
    io_message "Already published at ${Brown}$branchOrTag" "$moduleTracePrefix" LightBlue;;
  2)
    io_warning "Branch '$branch' was never published" "$moduleTracePrefix"
    neverPublished=true;;
  3)
    ffPublish=true;;
  esac
  return 0
}
publish_try_attach() { branch_try_attach 'HEAD' "$bundleBranch" false >/dev/null; }
publish_update_vtable()
{
  [[ $createVTable == true ]] || return 1
  # io_trace "publish_update_vtable ${*@Q}"
  lock "$lockDir" 0.1 vtable_update "$startupRoot" "$moduleId" "$lookupPath"
}
publish_commit_vtable()
{
  [[ $createVTable == true ]] || return 1
  # io_trace "publish_commit_vtable ${*@Q}"
  local ec=0 branch=$1 vtag=$2 vbranch=$3
  vtable_update "$startupRoot" "$moduleId" "$lookupPath" true || ec=$?

  # synchronize dev with prod
  if [[ -n $vbranch ]]; then
    branch_merge $branch $vbranch
    branch_merge $vbranch $branch
  fi
  if [[ -n $vtag ]]; then
    [ $ec -eq 0 ] && io_success "Created version table for '$branch' at ${Brown}$vtag" "$moduleTracePrefix"
    tag_move "$vtag" "$branch" &>/dev/null
  fi
}

publish_run "$@"
