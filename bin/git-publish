#!/bin/bash

[[ -z $ZOUL_LOCK ]]               && . zoul-lock
[[ -z $ZOUL_GIT_VTABLE ]]         && . zoul-git-vtable
[[ -z $ZOUL_GIT_CONFIG_SKU ]]     && . zoul-git-config-sku
[[ -z $ZOUL_GIT_CONFIG_SELECT ]]  && . zoul-git-config-select
[[ -z $ZOUL_GIT_CONFIG_PUBLISH ]] && . zoul-git-config-publish
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_PUBLISH ]] && . zoul-git-branch-publish

jobsCount=16
while [[ "$#" > 0 ]]; do case "$1" in
  -h|--help) zou-help $0; exit 0;;
  -0|--level0)        level0=true;;
  -q|--quiet)         quiet=true;;
  -e|--stop-on-error) stopOnError=true;;
  -r|--recursive)     recursive=true;;
  -v|--vo)            vo=true;; # original version (use nearest vtag)
  -u|--reuse)         prerelPrefix='reuse';;
  --alpha)            prerelPrefix='alpha';;
  --beta)             prerelPrefix='beta';;
  --rc)               prerelPrefix='rc';;
  --rtm)              prerelPrefix='rtm';;
  -j*)                jobsCount=${1#-j};;
  -*) echo "unknown option: $1" >&2; exit 1;;
esac; shift; done

# global_variable_names='level0 quiet stopOnError recursive vo prerelPrefix startupRoot startupDir moduleId'

process_error()
{
  [[ $1 -ne 0 && $stopOnError == true ]] && exit $1 || return 0
}
publish_update_vtable()
{
  [[ $recursive == true ]] || return 1
  # io_message "publish_update_vtable ${*@Q}" "[$moduleId]" Gray
  lock "$lockDir" 0.1 vtable_update "$startupRoot" "$moduleId" "$lookupPath"
}
publish_commit_vtable()
{
  [[ $recursive == true ]] || return 1
  # io_message "publish_commit_vtable ${*@Q}" "[$moduleId]" Gray
  local branch=$1 vtag=$2 vbranch=$3 ec=0
  vtable_update "$startupRoot" "$moduleId" "$lookupPath" || ec=$?

  # synchronize dev == prod
  [[ -n $vbranch ]] && branch_merge $branch $vbranch
  [[ -n $vtag ]] && {
    [ $ec -eq 0 ] && io_info "Created vtable for '$branch' at '$vtag'" "[$moduleId]"
    tag_move "$vtag" "$branch"
  }
}
publish_submodules()
{
  # io_warning ">>>> publish_submodules" "[$moduleId]"
  local branchOrTag=$1 configFile include exclude path mroot=$PWD
  configFile=$(repo_zouflow_path "$mroot") || return $?
  include=( $(config_sku_list_included "$branchOrTag" "$configFile") )
  exclude=( $(config_select_list_excluded "$branchOrTag" "$configFile") )
  include=$(array_remove_array 'include[@]' 'exclude[@]')
  [[ -z $include ]] && return 0
  for path in $(string_sort $include); do
    (
      cd "$mroot/$path" || {
        io_error "cd $mroot+$path" "[$moduleId]"
        return 1
      }
      publish_tree || return $?
    ) &
    if (( $(wc -w <<<$(jobs -p)) % $jobsCount == 0 )); then wait; fi
  done
  wait
  # io_warning "<<<< publish_submodules" "[$moduleId]"
}
publish_select_nearest_tag()
{
  local branch=$1 branchOrTag ec
  # trace_method publish_select_nearest_tag branch "$global_variable_names"
  branchOrTag=$(branch_select_nearest_vtag "$branch"); ec=$?
  [ $ec -eq 0 ] && io_info "Already published at '$branchOrTag'" "[$moduleId]"
  [ $ec -eq 1 ] && io_error "Branch '$branchOrTag' was never published" "[$moduleId]"
  [ $ec -eq 2 ] && io_info "Published existing version '$branchOrTag'" "[$moduleId]"
  echo $branchOrTag
  return $ec
}
publish_prolog()
{
  local branch=$(branch_current)
  # trace_method publish_prolog branch "$global_variable_names"
  repo_require_clean_work_tree 'cannot publish' || return 1

  if [[ $stopPublish == true ]]; then
    # io_message "publish_prolog ($branch) STOPPED" "[$moduleId]" Gray
    echo $branch
    publishDisabled=true
    # io_warning "<<<< publish_prolog ($branch) STOPPED DISABLED" "[$moduleId]"
    return 2  # publish disabled
  else
    unset publishDisabled

    if [[ $vo == true ]]; then
      if repo_is_bundle_root "$PWD"; then
        # io_message "publish_prolog ($branch) VO+BUNDLE" "[$moduleId]" Gray
        echo $branch
        # io_warning "<<<< publish_prolog ($branch) VO+BUNDLE" "[$moduleId]"
      else
        # io_message "publish_prolog ($branch) VO" "[$moduleId]" Gray
        publish_select_nearest_tag "$branch"
        # io_warning "<<<< publish_prolog ($branch) VO" "[$moduleId]"
      fi
    elif config_publish_is_enabled "$branch"; then
      # io_message "publish_prolog ($branch) ENABLED" "[$moduleId]" Gray
      branch=$(branch_ensure_current 2>/dev/null) || return 1
      echo $branch
      # io_warning "<<<< publish_prolog ($branch) ENABLED" "[$moduleId]"
    else
      # io_message "publish_prolog ($branch) DISABLED" "[$moduleId]" Gray
      publish_select_nearest_tag "$branch"
      publishDisabled=true
      stopPublish=true
      # io_warning "<<<< publish_prolog ($branch) DISABLED" "[$moduleId]"
      return 2  # publish disabled
    fi
  fi
}
publish_epilog()
{
  local branchOrTag=$1 info ec=0
  # trace_method publish_epilog branchOrTag "$global_variable_names"

  if [[ $stopPublish == true || $publishDisabled == true ]]; then
    # io_message "publish_epilog ($branchOrTag) ${label[*]}" "[$moduleId]" Gray
    publish_update_vtable
  elif [[ "$PWD" == "$startupRoot" ]]; then
    if [[ $vo == true ]]; then
      if repo_is_bundle_root "$PWD"; then
        # io_message "publish_epilog ($branchOrTag) VO+BUNDLE" "[$moduleId]" Gray
        info=( $(branch_publish "$branchOrTag" "$prerelPrefix") ) || ec=$?
        publish_commit_vtable "$branchOrTag" "${info[@]}"
      # else
      #   io_message "publish_epilog ($branchOrTag) VO" "[$moduleId]" Gray
      fi
    else
      # io_message "publish_epilog ($branchOrTag) ENABLED" "[$moduleId]" Gray
      info=( $(branch_publish "$branchOrTag" "$prerelPrefix") ) || ec=$?
      publish_commit_vtable "$branchOrTag" "${info[@]}"
    fi
  else
    if [[ $vo == true ]]; then
      # io_message "publish_epilog ($branchOrTag) VO" "[$moduleId]" Gray
      publish_update_vtable
    else
      # io_message "publish_epilog ($branchOrTag) ENABLED" "[$moduleId]" Gray
      branch_publish "$branchOrTag" "$prerelPrefix" >/dev/null || ec=$?
      publish_update_vtable
    fi
  fi
  # io_warning "<<<< publish_epilog ($branchOrTag)" "[$moduleId]"
  return $ec
}
publish_tree()
{
  # trace_method publish_tree "$global_variable_names"
  # io_warning ">>>> publish_tree ${*@Q}" "[$moduleId]"
  [[ $quiet == true ]] || echo Entering "'$(path_make_relative '.' "$startupDir")'"
  local branchOrTag stopPublish publishDisabled ec=0 moduleId=$(repo_module_id)

  branchOrTag=$(publish_prolog)
  [ $? -eq 1 ] && return 1

  if [[ $recursive == true ]]; then
    publish_submodules "$branchOrTag" || process_error $?
  fi
  
  publish_epilog "$branchOrTag"
  # io_warning "<<<< publish_tree ${*@Q}" "[$moduleId]"
}

startupDir=$PWD
startupRoot=$(repo_module_root)
cd "$startupRoot"
[[ $recursive == true ]] && {
  lockDir=$(mktemp -u)
  lookupPath="$(mktemp)"
  vtable_init "$startupRoot" "$lookupPath"
}
publish_tree || process_error $?
