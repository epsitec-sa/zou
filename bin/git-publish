#!/bin/bash

# Defaults:
# - always recursive
# - abstract - create vtable
# - always publish current module
# - do not propagate down prerelPrefix
# - foreach submodule
#     if --merge
#     then { merge and publish } 
#     else { publish last vtag }
#
# Bundle invocation
# - override - always create vtable
#
# Submodule invocation
# - override - create vtable if --vtable && submodule count > 0

[[ -z $ZOUL_LOCK ]]               && . zoul-lock
[[ -z $ZOUL_GIT_MODULE ]]         && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]]         && . zoul-git-config
[[ -z $ZOUL_GIT_COSM ]]           && . zoul-git-cosm
[[ -z $ZOUL_GIT_VTABLE ]]         && . zoul-git-vtable
[[ -z $ZOUL_GIT_BRANCH_CORE ]]    && . zoul-git-branch-core
[[ -z $ZOUL_GIT_CONFIG_SKU ]]     && . zoul-git-config-sku
[[ -z $ZOUL_GIT_CONFIG_SELECT ]]  && . zoul-git-config-select
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_PUBLISH ]] && . zoul-git-branch-publish

publish_parse()
{
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)                  jobsCount=${1#-j};;
    .)                    unset recursive;;
    --dev)                publishDev=true;;
    -t|--vtable)          vtable=true;;
    -n|--dry-run)         dryRun=true;;
    -u|--reuse)           prerelPrefix='reuse';;
    --alpha)              prerelPrefix='alpha';;
    --beta)               prerelPrefix='beta';;
    --rc)                 prerelPrefix='rc';;
    --rtm)                prerelPrefix='rtm';;
    -*) io_error "unknown option '$1'"; return 1;;
    *) sku=$1;;
  esac; shift; done
}
publish_run()
{
  # parse command line
  local jobsCount sku vtable prerelPrefix publishDev dryRun recursive=true
  publish_parse "$@" || return $?

  local commitSubmodules=true \
        publishSelectExcludeIds=() \
        publishScopes=( config_scope cosm_scope )

  startupMessage="Publishing, please wait..."

  module_run "${publishScopes[@]}" publish_main
}
publish_main()
{
  [[ -z $sku ]] && sku=$bundleBranch

  local vtableCreate vtableGate vtableLookupPath
  publish_set_vtable_info

  publish_tree
}
publish_tree()
{
  # feed exclude list with moduleIds (modulePaths by default)
  publishSelectExcludeIds+=( "${configSelectExcludeIds[@]}" )

  if array_contains_element "$moduleId" "${publishSelectExcludeIds[@]}"; then
    publish_update_vtable
    return 0
  fi

  local lbranch vbranch vtag htag delta alias status nextHead publishStatus

  publish_prolog || return $?
  [[ $recursive == true ]] && { publish_submodules || return $?; }
  publish_epilog
}
publish_prolog()
{
  local forceDev=false allowDuplicateTags=false
  [[ $publishDev == true || "$PWD" == "$startupRoot" ]] && forceDev=true
  [[ $moduleRoot == $bundleRoot ]] && allowDuplicateTags=true

  if [[ $dryRun == true ]]; then
    branch_set_sku_info "$sku" "$forceDev" false "$allowDuplicateTags"
  else
    branch_set_select_auto "$sku" "$forceDev" false false "$allowDuplicateTags" || return $?
  fi

  if [[ $publishStatus == 'unpublishable' ]]; then
    io_error "Branch '$lbranch' cannot be published (no vbranch associated)" "$moduleTracePrefix"
    return 1
  fi
  # io_trace "publish_prolog -- $(print_vars lbranch vbranch vtag htag publishStatus)"
}
publish_submodules()
{
  local publishSubmodules=( $(array_sort configSkuInclude[@]) )
  module_visit_submodules_async 'publishSubmodules[@]' "${publishScopes[@]}" 'publish_tree'
}
publish_epilog()
{
  if [[ $publishStatus == 'published' ]]; then
    if [[ $dryRun == true ]]; then
      (( smToPublishCount > 0 )) && publishStatus='notPublished'
    else
      cosm_has_unstaged_submodules && publishStatus='notPublished'
    fi
  fi
  
  publish_publish || return $?
  publish_update_vtable
}

publish_publish()
{
  # io_trace "publish_publish 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
  
  case $publishStatus in
    published)    publish_already_published;;
    ffPublish)    publish_ff_publish;;
    notPublished) publish_not_published;;
    *)            publish_not_implemented;;
  esac
  # io_trace "publish_publish 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
}
publish_already_published()
{
  io_message "Already published at ${Brown}$vtag" "$moduleTracePrefix" LightBlue
}
publish_ff_publish()
{
  if [[ $dryRun == true ]]; then
    branch_io_message "Branch '$lbranch' will be fast-forwarded at ${Brown}$vtag" "$alias" LightPurple
  else
    branch_merge "$vtag" "$moduleBranch" \
    && io_message "Already published at ${Brown}$vtag${LightBlue} (${Brown}fast-forward${LightBlue})" "$moduleTracePrefix" LightBlue \
    || { io_error "Fast-forward publish of branch '$lbranch' failed" "$moduleTracePrefix"; return 1; }
    publish_try_attach
  fi
}
publish_not_published()
{
  local vnext=$vtag noIncrement

  # get principal module version
  publish_set_bundle_version # update htag and noIncrement

  if [[ $dryRun == true ]]; then
    branch_set_vnext "$vtag" "$htag" "$noIncrement" # -> prerelPrefix vnext
    branch_io_message "Branch '$lbranch' will be published at ${Brown}$vnext" "$alias" Green
    # io_trace "$(print_vars lbranch vbranch vtag htag delta status nextHead publishStatus vnext prerelPrefix)"
  else
    branch_set_publish "$lbranch" "$vbranch" "$vtag" "$htag" "$prerelPrefix" "$noIncrement" \
    && io_success "Published branch '$lbranch' at ${Brown}$vnext" "$moduleTracePrefix" \
    || { io_error "Publish of branch '$lbranch' failed" "$moduleTracePrefix"; return 1; }
    publish_try_attach
  fi
}
publish_not_implemented()
{
  io_error "Fatal: publishStatus '$publishStatus' not implemented" "$moduleTracePrefix"
  exit 1
}
# Compute next bundle version
# in:
#  (module_scope)
# out:
#  htag         -- high
#  noIncrement
publish_set_bundle_version()
{
  if [[ $moduleRoot == $bundleRoot && -n $principalModuleId ]]; then
    local smtag=$(module_visit "$principalModuleId" publish_principal_version)
    if [ -n $smtag ]; then
      htag=$smtag
      noIncrement=true
    fi
    # io_trace "publish_set_bundle_version -- $(print_vars principalModuleId vtag smtag htag noIncrement)"
  fi
}
publish_principal_version()
{
  local lbranch vbranch vtag htag delta alias status nextHead publishStatus
  branch_set_sku_info "$bundleBranch" "$publishDev" false false
  # io_trace "publish_principal_version << $(print_vars lbranch vbranch vtag htag delta alias status nextHead publishStatus)"
  echo "$htag"
}
publish_try_attach()
{
  branch_try_attach 'HEAD' "$sku" false || true
}
publish_set_vtable_info()
{
  if [[ $dryRun != true ]]; then
    if [[ $vtable == true ]]; then
      vtableCreate=true
    elif [[ $startupRoot == $bundleRoot ]] && module_has_submodules; then
      vtableCreate=true
    fi
    [[ $vtableCreate == true ]] && {
      vtableGate=$(lock_init)
      vtableLookupPath="$(mktemp)"
      vtable_init "$startupRoot" "$vtableLookupPath"
    }
  fi
}
publish_update_vtable()
{
  [[ $vtableCreate == true ]] || return 0
  if [[ "$PWD" == "$startupRoot" ]]; then
    publish_commit_vtable
  else
    lock_enter "$vtableGate"
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath"
    lock_exit "$vtableGate"
  fi
}
publish_commit_vtable()
{
  # io_trace "publish_commit_vtable ${*@Q}"
  if vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" true; then
    branch_merge_sync $lbranch $vbranch
    tag_move "$vnext" "$lbranch" &>/dev/null
    io_success "Created version table for '$lbranch' at ${Brown}$vnext" "$moduleTracePrefix"
  else
    io_error "Failed to create version table for '$lbranch' at ${Brown}$vnext" "$moduleTracePrefix"
  fi
}

publish_run "$@"
