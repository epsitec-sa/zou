#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_CMD ]] && . zoul-git-cmd
ZOUL_GIT_CMD=true

[[ -z $ZOUL_GIT_MODULE ]] && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]] && . zoul-git-config

# usage:
#   cmd_register_module_paths true sm1 sm2
# in:
#   recursive=${1:-false}
#   paths=${@:2}

declare -A cmdRecursiveMap
cmdModulePaths=()

cmd_register_module_paths()
{
  # io_trace "cmd_register_module_paths -- ${*@Q}"
  local recursive=${1:-false} path rpath; shift
  [ $# -eq 0 ] && return 0

  for path; do
    path=$(realpath "$path")
    # io_trace "cmd_register_module_paths 1 -- $(print_vars path)"
    if [[ ${cmdRecursiveMap["$path"]:-false} == false ]]; then
      cmdRecursiveMap["$path"]=$recursive
    fi
    if ! array_contains_element "$path" "${cmdModulePaths[@]}"; then
      cmdModulePaths+=( "$path" )
    fi
  done

  # io_trace "cmd_register_module_paths 2 -- $(print_vars cmdModulePaths[@])"
  local rpaths=()
  for path in "${cmdModulePaths[@]}"; do
    if [[ ${cmdRecursiveMap["$path"]} == true ]]; then
      for rpath in "${cmdModulePaths[@]}"; do
        [[ $rpath == $path ]] && continue
        if [[ ${rpath#$path} != $rpath ]] ; then
          rpaths+=( "$rpath" )
        fi
      done
    fi
  done
  cmdModulePaths=( $(array_remove_array 'cmdModulePaths[@]' 'rpaths[@]') )
  # io_trace "cmd_register_module_paths 3 -- $(print_vars cmdModulePaths[@] rpaths[@])"

  for rpath in "${rpaths[@]}"; do
    unset cmdRecursiveMap["$rpath"]
  done
  # declare -p cmdRecursiveMap
}

# usage:
#   local recursive=true command=wip subcommand=enter \
#         cmdScopes=( prod_scope config_scope cosm_scope)
#
#   cmd_register_module_paths true sm1 sm2
#   cmd_visit_modules
cmd_visit_modules()
{
  if [[ $moduleRoot == $startupRoot ]]; then
    # io_trace "cmd_visit_modules 1 -- $(print_vars cmdModulePaths[@])"
    # startup module scopes are already initialized
    module_visit_submodules_async 'cmdModulePaths[@]' _cmd_tree
  else
    io_trace "cmd_visit_modules 2 -- $(print_vars cmdModulePaths[@])"
    module_visit_submodules_async 'cmdModulePaths[@]' "${cmdScopes[@]}" _cmd_tree
  fi
}
cmd_check_subcommand()
{
  [[ -n $subcommand ]] && array_contains_element "$subcommand" "$@" && return 0
  io_error "missing subcommand: use one of (${VC}$(string_join ', ' "$@")${Red})\n"
  io_help $0
  exit 1
}
cmd_check_args()
{
  [[ $# -eq 0 ]] && return 0
  io_error "invalid argument ${VC}$1${Red}, use ${VC}--${Red} to specify modules paths\n"
  io_help $0
  exit 1
}

_cmd_tree()
{
  if [[ $(type -t "${command}_${subcommand}_scope") == 'function' ]]; then
    ${command}_${subcommand}_scope _cmd_tree_core
  else
    _cmd_tree_core
  fi
}
_cmd_tree_core()
{
  _cmd_prolog || return $?
  _cmd_visit_tree || return $?
  _cmd_epilog
}
_cmd_prolog()
{
  # io_trace "_cmd_prolog -- $(print_vars subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_prolog") == 'function' ]]; then
    ${command}_${subcommand}_prolog
  fi
}
_cmd_epilog()
{
  # io_trace "_cmd_epilog -- $(print_vars subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_epilog") == 'function' ]]; then
    ${command}_${subcommand}_epilog
  fi
}
_cmd_visit_tree()
{
  _cmd_is_recursive || return 0
  module_visit_submodules_async 'configSelectInclude[@]' "${cmdScopes[@]}" _cmd_tree
  if [[ $(type -t cosm_reset_scope) == 'function' ]]; then
    cosm_reset_scope
  fi
}
_cmd_is_recursive()
{
  local path
  for path in "${!cmdRecursiveMap[@]}"; do
    [[ ${cmdRecursiveMap["$path"]} == true ]] || continue
    [[ ${moduleRoot#$path} == $moduleRoot ]] || return 0
  done
  return 1
}
