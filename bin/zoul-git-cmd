#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_CMD ]] && . zoul-git-cmd
ZOUL_GIT_CMD=true

[[ -z $ZOUL_GIT_MODULE ]] && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]] && . zoul-git-config

#####################
# MODULE REGISTRATION
#####################

declare -A cmdRecursiveMap
cmdModulePaths=()

# usage:
#   cmd_register_module_paths true sm1 sm2
# in:
#   recursive=${1:-false}
#   paths=${@:2}
cmd_register_module_paths()
{
  # io_trace "cmd_register_module_paths -- ${*@Q}"
  local recursive=${1:-false} path rpath; shift
  [ $# -eq 0 ] && return 0

  for path; do
    path=$(realpath "$path")
    # io_trace "cmd_register_module_paths 1 -- $(print_vars path)"
    if [[ ${cmdRecursiveMap["$path"]:-false} == false ]]; then
      cmdRecursiveMap["$path"]=$recursive
    fi
    if ! array_contains_element "$path" "${cmdModulePaths[@]}"; then
      cmdModulePaths+=( "$path" )
    fi
  done

  # io_trace "cmd_register_module_paths 2 -- $(print_vars cmdModulePaths[@])"
  local rpaths=()
  for path in "${cmdModulePaths[@]}"; do
    if [[ ${cmdRecursiveMap["$path"]} == true ]]; then
      for rpath in "${cmdModulePaths[@]}"; do
        [[ $rpath == $path ]] && continue
        if [[ ${rpath#$path} != $rpath ]] ; then
          rpaths+=( "$rpath" )
        fi
      done
    fi
  done
  cmdModulePaths=( $(array_remove_array 'cmdModulePaths[@]' 'rpaths[@]') )
  # io_trace "cmd_register_module_paths 3 -- $(print_vars cmdModulePaths[@] rpaths[@])"

  for rpath in "${rpaths[@]}"; do
    unset cmdRecursiveMap["$rpath"]
  done
  # declare -p cmdRecursiveMap
}
cmd_set_recursive_if_registered()
{
  local path=$1 recursive=${2:-true}
  if [[ -n ${cmdRecursiveMap[$path]} ]]; then
    cmdRecursiveMap[$path]=$recursive
  fi
}

############################
# REGISTERED MODULES VISITOR
############################

# usage:
#   local command=wip subcommand=enter \
#         cmdScopes=( prod_scope config_scope cosm_scope)
#
#   cmd_register_module_paths true sm1 sm2
#   cmd_visit_modules
cmd_visit_modules()
{
  if array_contains_element "$startupRoot" "${cmdModulePaths[@]}"; then
    # startup module scope is already initialized
    # io_trace "cmd_visit_modules 1 ${*@Q} -- $(print_vars cmdModulePaths[@])"
    module_visit_submodules_async 'cmdModulePaths[@]' _cmd_tree "$@"
  else
    # io_trace "cmd_visit_modules 2 ${*@Q} -- $(print_vars cmdScopes[@] cmdModulePaths[@])"
    module_visit_submodules_async 'cmdModulePaths[@]' "${cmdScopes[@]}" _cmd_tree "$@"
  fi
}

####################
# SUBMODULES VISITOR
####################

_cmd_visit_tree()
{
  _cmd_is_recursive || return 0

  local ec=0
  module_visit_submodules_async "configSelectInclude[@]" "${cmdScopes[@]}" _cmd_tree "$@" || io_trace_error "_cmd_visit_tree 1" || ec=$?
  # io_trace "_cmd_visit_tree 1 ${*@Q} -- $(print_vars configSelectInclude[@] cmdScopes[@] ec)"
  module_visit_submodules_async "configSelectExclude[@]" _cmd_xscope "${cmdScopes[@]}" _cmd_xtree "$@" || io_trace_error "_cmd_visit_tree 2" || ec=$?
  # io_trace "_cmd_visit_tree 2 ${*@Q} -- $(print_vars configSelectInclude[@] cmdScopes[@] ec)"
  [[ $(type -t cosm_reset_scope) == 'function' ]] && cosm_reset_scope
  return $ec
}
_cmd_is_recursive()
{
  local path
  for path in "${!cmdRecursiveMap[@]}"; do
    [[ ${cmdRecursiveMap["$path"]} == true ]] || continue
    [[ ${moduleRoot#$path} == $moduleRoot ]] || return 0
  done
  return 1
}
_cmd_xscope()
{
  # io_trace "_cmd_xscope ${*@Q}"
  local configSelectIsExcluded=true
  if [[ $(type -t "${command}_${subcommand}_xprolog") == 'function' || $(type -t "${command}_${subcommand}_xepilog") == 'function' ]]; then
    $1 "${@:2}"
  fi
}

############################
# INCLUDED SUBMODULE VISITOR
############################

_cmd_tree()
{
  # io_trace "_cmd_tree ${*@Q}"
  if [[ $(type -t "${command}_${subcommand}_scope") == 'function' ]]; then
    ${command}_${subcommand}_scope _cmd_tree_core "$@"
  else
    _cmd_tree_core "$@"
  fi
}
_cmd_tree_core()
{
  # io_trace "_cmd_tree_core ${*@Q}"
  _cmd_prolog "$@" || return $?
  _cmd_visit_tree "$@" || return $?
  _cmd_epilog "$@"
}
_cmd_prolog()
{
  # io_trace "_cmd_prolog -- $(print_vars command subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_prolog") == 'function' ]]; then
    ${command}_${subcommand}_prolog "$@" || io_trace_error "${command}_${subcommand}_prolog"
  fi
}
_cmd_epilog()
{
  # io_trace "_cmd_epilog -- $(print_vars command subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_epilog") == 'function' ]]; then
    ${command}_${subcommand}_epilog "$@" || io_trace_error "${command}_${subcommand}_epilog"
  fi
}

############################
# EXCLUDED SUBMODULE VISITOR
############################

_cmd_xtree()
{
  # io_trace "_cmd_xtree ${*@Q}"
  if [[ $(type -t "${command}_${subcommand}_xscope") == 'function' ]]; then
    ${command}_${subcommand}_xscope _cmd_xtree_core "$@" || io_trace_error "${command}_${subcommand}_xscope"
  else
    _cmd_xtree_core "$@"
  fi
}
_cmd_xtree_core()
{
  # io_trace "_cmd_xtree_core ${*@Q}"
  _cmd_xprolog "$@" || return $?
  _cmd_visit_tree "$@" || return $?
  _cmd_xepilog "$@"
}
_cmd_xprolog()
{
  # io_trace "_cmd_xprolog -- $(print_vars command subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_xprolog") == 'function' ]]; then
    ${command}_${subcommand}_xprolog "$@" || io_trace_error "${command}_${subcommand}_xprolog"
  fi
}
_cmd_xepilog()
{
  # io_trace "_cmd_xepilog -- $(print_vars command subcommand cmdModulePaths[@])"
  if [[ $(type -t "${command}_${subcommand}_xepilog") == 'function' ]]; then
    ${command}_${subcommand}_xepilog "$@" || io_trace_error "${command}_${subcommand}_xepilog"
  fi
}

#######################
# COMMAND CHECK HELPERS
#######################

cmd_check_subcommand()
{
  [[ -n $subcommand ]] && array_contains_element "$subcommand" "$@" && return 0
  io_error "missing subcommand: use one of (${VC}$(string_join ', ' "$@")${Red})\n"
  io_help $0
  exit 1
}
cmd_check_args()
{
  [[ $# -eq 0 ]] && return 0
  io_error "invalid argument ${VC}$1${Red}, use ${VC}--${Red} to specify modules paths\n"
  io_help $0
  exit 1
}
