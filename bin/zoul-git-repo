#!/usr/bin/env bash

# Repository helpers
# 
# bundle ID                    (zou-dev)
#   = bundle root path name
# bundle root path             (/c/devel/zou-dev)
#   
# module ID
#   = module relative path
# module relative path
#   the module root path relative to the bundle root path
# module root path
#  
# submodule ID
#   the name of the section in the .gitmodules file
# submodule relative path
#   the path value in the .gitmodules config file
#   = relative path to the parent module / bundle
#
# Exemples:
#  repo_bundle_id        # zou-dev
#  repo_bundle_root      # /c/devel/zou-dev
#  repo_module_id        # zou, Bcx
#  repo_module_root      # /c/devel/zou-dev/zou, /c/devel/zou-dev/Bcx, ...
#
# http://schacon.github.io/git/git.html
# https://stackoverflow.com/questions/2657935/checking-for-a-dirty-index-or-untracked-files-with-git/2658301


# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo
ZOUL_GIT_REPO=true

[[ -z $ZOUL_CORE ]]     && . zoul-core
[[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core

internalIgnoreList=( 'versions.md' )

submoduleChangedEvent=()
repo_raise_submodule_changed_event() { raise_event 'submoduleChangedEvent[@]' "$@"; }

######################
# Bundle
repo_bundle_id()
{
  local dir
  dir=$(repo_bundle_root "$@")
  [ $? -ne 0 ] && return 1
  echo ${dir##*/}
}
repo_bundle_root()
{

  local dir
  dir=$(abspath "${1:-.}") || return $?
  while [[ -n "$dir" && ! -d "$dir/.git" ]]; do
    dir="${dir%/*}"
    [[ $dir =~ \:$ ]] && return 1
  done
  [[ -z $dir ]] && return 1
  echo "$dir"
}
# usage:
#  local bundleUrl bundleUrlName
#  repo_set_bundle_url_info "$broot"
# in:
#  $1:broot=bundleRoot
# out:
#  bundleUrl
#  bundleUrlName
# ex:
#  repo_set_bundle_url_info '/c/devel/zou-dev'
#  -> bundleUrl     = https://git.epsitec.ch/Build/zou-dev.git
#  -> bundleUrlName = zou-dev
repo_set_bundle_url_info()
{
  local broot=${1:-$bundleRoot}
  [[ -z $broot ]] && broot=$(repo_bundle_root)
  cd "$broot"
  bundleUrl=$(gitx config remote.origin.url 2>>"$stderrRedir")
  cd - &>>"$stdallRedir"
  bundleUrlName=${bundleUrl##*/}
  bundleUrlName=${bundleUrlName%.git}
}
# return the path relative to the bundle root of any bundle folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference bundle
repo_path_relative_to_bundle_root()
{
  local path bdir
  path=$(abspath "${1:-.}") || return $?
  bdir=$(repo_bundle_root "${2:-.}") || return $?
  abspath --relative-to="$bdir" "$path"
}

######################
# Module
repo_module_id()
{
  local dirs
  dirs=( $(repo_module_and_bundle_roots "$@") )
  [ $? -ne 0 ] && return 1
  local mdir=${dirs[0]} bdir=${dirs[1]}
  if [[ $mdir == $bdir ]]; then
    echo ${bdir##*/}
  else
    echo ${mdir#$bdir/}
  fi
}
repo_module_root()
{
  local dir
  dir=$(abspath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" || -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="${dir%/*}"
  done
  return 1
}
repo_module_parent()
{
  local mroot
  mroot="${1:-$(repo_module_root)}" || return $?
  if ! repo_is_bundle_root "$mroot"; then
    repo_module_root "$mroot/.."
    return 0
  fi
  return 1
}
repo_module_level()
{
  local dir level=0
  dir=$(abspath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      level=$(( $level + 1 ))
    elif [[ -d "$dir/.git" ]]; then
      echo $level
      return 0
    fi
    dir="${dir%/*}"
  done
  echo -1
  return 1
}

# return the path relative to the module root of any module folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference module
repo_module_root_relative_to_path()
{
  local dir=$(abspath "${1:-.}") mdir
  mdir=$(repo_module_root "${2:-.}") || return $?
  abspath --relative-to="$dir" "$mdir"
}
# return the path relative to the module root of any module folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference module
repo_path_relative_to_module_root()
{
  local dir=$(abspath "${1:-.}") mdir
  mdir=$(repo_module_root "${2:-.}") || return $?
  abspath --relative-to="$mdir" "$dir"
}
repo_module_and_bundle_roots()
{
  local dir=$(abspath ${1:-.}) mdir bdir
  while [[ -n "$dir" ]]; do
    if [[ -z "$mdir" && -f "$dir/.git" ]]; then
      mdir=$dir
      echo "$mdir"
    fi
    if [[ -d "$dir/.git" ]]; then
      if [[ -z "$mdir" ]]; then
        mdir=$dir
        echo "$mdir"
      fi
      bdir=$dir
      echo "$bdir"
      return 0
    fi
    dir=${dir%/*}
  done
  return 1
}
# <bundle>/SM1/foo/SM2/SM3
#   -> <bundle>/SM1/foo/SM2
#   -> <bundle>/SM1
#   -> <bundle>
repo_ancestor_roots()
{
  local mparent
  mparent=$(repo_module_parent "$1") || return $?
  repo_module_and_ancestor_roots "$mparent"
}
# <bundle>/SM1/foo/SM2/SM3
#   -> <bundle>/SM1/foo/SM2/SM3
#   -> <bundle>/SM1/foo/SM2
#   -> <bundle>/SM1
#   -> <bundle>
repo_module_and_ancestor_roots()
{
  local mroot=${1:-$moduleRoot}
  [[ -z $mroot ]] && mroot="$(repo_module_root "$mroot")" || mroot="$(abspath "$mroot")"
  while [[ -n "$mroot" ]]; do
    if [[ -f "$mroot/.git" ]]; then
      echo "$mroot"
    elif [[ -d "$mroot/.git" ]]; then
      echo "$mroot"
      return 0
    fi
    mroot=${mroot%/*}
  done
  return 1
}
# SM1/foo/SM2/SM3
#   -> /SM3/
#   -> /foo/SM2/
#   -> /SM1/
repo_module_and_ancestor_parts()
{
  local mroot=${1:-$moduleRoot} prevPath part
  [[ -z $mroot ]] && mroot="$(repo_module_root "$mroot")" || mroot="$(abspath "$mroot")"
  for path in $(repo_module_and_ancestor_roots "$mroot"); do
    part="${prevPath#"$path"}"
    [[ -n $part ]] && echo "$part"
    # io_trace "_hooks_compute_parts -- $(print_vars mroot path prevPath part)"
    prevPath="$path"
  done
}

######################
# Submodule

repo_submodule_root()
{
  local dir
  dir=$(abspath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="${dir%/*}"
  done
  return 1
}
repo_submodule_path()
{
  local smId=$1 root=$2
  [[ -z $root ]] && { root=$(repo_module_root) || return 1; }
  gitx config --file "$root/.gitmodules" "submodule.$smId.path" 2>>"$stderrRedir"
}

######################

repo_url_from_path()
{
  local pwd=$PWD url
  cd "${1:-.}"
  url=$(gitx config remote.origin.url 2>>"$stderrRedir")
  cd $pwd
  echo $url
}

repo_gitmodules_path()
{
  local mroot=$1 smid smpath
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  echo "$mroot/.gitmodules"
}

repo_list_deleted()    { gitx ls-files --deleted; }
repo_list_uncommited() { gitx diff-index --cached --name-only -r --ignore-submodules HEAD -- 2>>"$stderrRedir"; }
repo_list_unmerged()   { gitx diff --name-only --diff-filter=U --ignore-submodules 2>>"$stderrRedir" | cut -f1; }
repo_is_merging()      { gitx merge HEAD &>>"$stdallRedir" && return 1 || return 0; }
repo_is_all_clean()    { test -z "$(gitx status -C "${1:-.}" -s --porcelain &>>"$stdallRedir")"; }  # neither unstaged nor untracked

repo_is_bundle_root()  { [[ -d "${1:-.}/.git" ]]; }
repo_is_module_root()  { [[ -f "${1:-.}/.git" ]]; }

repo_is_clean()        { gitx diff-index --ignore-submodules --quiet HEAD -- &>>"$stdallRedir"; }

repo_has_submodules()
{
  local mroot=$1
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  gitx config --file "$mroot/.gitmodules" --get-regexp '^submodule\..*\.path$' &>>"$stdallRedir"
}
repo_list_submodule_paths()
{
  local mroot=${1:-$moduleRoot}
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  gitx config --file "$mroot/.gitmodules" --get-regexp '^submodule\..*\.path$' 2>>"$stderrRedir" | cut -d' ' -f2
}
repo_list_unstaged_submodules()       { repo_visit_unstaged_submodules "$1" _repo_list_unstaged_submodules_visitor; }
repo_list_unstaged_clean_submodules() { repo_visit_unstaged_submodules "$1" _repo_list_unstaged_clean_submodules_visitor; }
# usage:
#   local unstagedCleanSubmodules=() unstagedDirtySubmodules=()
#   repo_split_unstaged_submodules "$moduleRoot"
repo_split_unstaged_submodules() { repo_visit_unstaged_submodules "$1" _repo_split_unstaged_submodules_visitor; }

_repo_list_unstaged_submodules_visitor() { echo "$1"; }
_repo_list_unstaged_clean_submodules_visitor() { repo_is_clean && branch_is_ancestor_of_local && echo "$1"; }
_repo_split_unstaged_submodules_visitor()
{
  if repo_is_clean && branch_is_ancestor_of_local; then
    unstagedCleanSubmodules+=( $1 )
  else
    unstagedDirtySubmodules+=( $1 )
  fi
}

repo_visit_unstaged_submodules()
{
  local mroot=${1:-$moduleRoot} smid smref smpath smroot opwd=$PWD; shift
  [[ -n $1 ]] || io_trace_error "repo_visit_unstaged_submodules: missing visitor" || return 1
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  for smid in $(gitx diff-files --name-only -r 2>>"$stderrRedir"); do
    smpath=$(repo_submodule_path "$smid" "$mroot")
    [[ -z $smpath ]] && continue
    smroot="$mroot/$smpath"
    if repo_is_module_root "$smroot"; then
      smref=$(ref_get_submodule_ref "$smpath")
      cd "$smroot"
      # io_trace "repo_visit_unstaged_submodules ${*@Q} -1- $(print_vars smid smref PWD)"
      # execute visitor in submodule directory
      $1 "${@:2}" "$smid" "$smref"
      cd "$opwd"
    fi
  done
}
repo_list_untracked()
{
  local path smpath
  for path in $(gitx ls-files --exclude-standard --others 2>>"$stderrRedir"); do
    if [[ -f $path ]]; then
      # skip internal ignore list
      array_contains_element "$path" "${internalIgnoreList[@]}" || echo $path
    else
      # skip dangling submodules
      repo_is_module_root "$path" || echo $path
    fi
  done
}
repo_list_unstaged()
{
  local path
  for path in $(gitx diff-files --name-only -r --ignore-submodules 2>>"$stderrRedir"); do
    if [[ -f $path ]]; then
      # skip internal ignore list
      array_contains_element "$path" "${internalIgnoreList[@]}" || echo $path
    fi
  done
}
repo_list_dangling_submodules()
{
  local path
  for path in $(gitx ls-files --exclude-standard --others 2>>"$stderrRedir"); do
    [[ -d $path ]] && repo_is_module_root "$path" && echo "$path"
  done
}
repo_commit_clean_submodules() { _repo_commit_submodule_enumerator 'repo_list_unstaged_clean_submodules' "$1"; }
repo_commit_all_submodules()   { _repo_commit_submodule_enumerator 'repo_list_unstaged_submodules' "$1"; }
_repo_commit_submodule_enumerator()
{
  local enumerator=$1 mroot=$2 submodules
  submodules=$($enumerator "$mroot") || return 1
  repo_commit_submodules "$mroot" $submodules
}
repo_commit_submodules()
{
  # io_trace "repo_commit_submodules -1- ${*@Q}"
  local mroot=${1:-$moduleRoot}; shift
  [ $# -eq 0 ] && return 0
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }

  local opwd=$PWD sm
  cd "$mroot" || io_trace_error "repo_commit_submodules: cd $mroot" || exit 1

  # do not commit on detached head
  [[ -z $moduleHeadType ]] && moduleHeadType=$(ref_type)
  [[ $moduleHeadType == 'branch' ]] || return 0

  local branch=${moduleHead:-$(branch_current)}
  # io_trace "repo_commit_submodules -2- $(print_vars branch)"
  if git_commit 'update submodules' "$@"; then
    for sm; do
      io_message "  Commited submodule ${VC}$sm${DarkGray} on branch ${VC}$branch${DarkGray}" "$moduleTracePrefix" ${DarkGray}
    done
  fi
  repo_raise_submodule_changed_event "$@"
  cd "$opwd" || io_trace_error "repo_commit_submodules: cd $opwd" || exit 1
  return 1
}

repo_sync_submodule()
{
  # io_trace "repo_sync_submodule ${*@Q}"
  io_buffered_eval "gitx submodule sync \"$1\" 2>&1" '_repo_submodule_line_selector' ${DarkGray} >/dev/null
}
repo_update_submodule()
{
  # io_trace "repo_update_submodule ${*@Q} -1- PWD=$PWD"
  local smPaths
  smPaths=( $(io_buffered_eval "git sm update -C "$moduleRoot" --init \"$1\" 2>&1" '_repo_submodule_line_selector' ${DarkGray}) )
  # io_trace "repo_update_submodule -2- $(print_vars smPaths[@] PWD)"
  [ ${#smPaths[@]} -ne 0 ] && repo_raise_submodule_changed_event "${smPaths[@]}" || return 0
}
repo_discard_submodule()
{
  # io_trace "repo_discard_submodule ${*@Q}"
  local smPaths
  smPaths=( $(io_eval "git sm update -C "$moduleRoot" --recursive \"$1\" 2>&1" '_repo_submodule_line_selector' ${DarkGray}) )
  # io_trace "repo_discard_submodule -- $(print_vars smPaths[@])"
  [ ${#smPaths[@]} -ne 0 ] && repo_raise_submodule_changed_event "${smPaths[@]}"
}
_repo_submodule_line_selector()
{
  skipCurrentLine=''
  if [[ $line =~ ^Submodule[[:blank:]]+path[[:blank:]]+\'([^\']+)\' ]]; then
    local smpath="${BASH_REMATCH[1]}"
    echo "$smpath"
    # io_trace_unsafe "_repo_submodule_line_selector -1- $(print_vars smpath)"
    skipCurrentLine=true
  elif [[ $line =~ ^((Cloning|Synchronizing)[^\']+)\'([^\']+)\'(.*) ]]; then
    line="${BASH_REMATCH[1]}${VC}${BASH_REMATCH[3]}${color}${BASH_REMATCH[4]}"
    # io_trace_unsafe "_repo_submodule_line_selector -2- $(print_vars line)"
  else
    # io_trace_unsafe "_repo_submodule_line_selector -3- $(print_vars line)"
    skipCurrentLine=true
  fi
}

repo_discard_internal_ignore_list()
{
  local discarded=0 path
  for path in $(gitx diff-files --name-only -r --ignore-submodules 2>>"$stderrRedir"); do
    if [[ -f $path ]] && array_contains_element "$path" "${internalIgnoreList[@]}"; then
      gitx checkout -- "$path" &>>"$stdallRedir"
      (( discarded += 1 ))
    fi
  done
  return $discarded
}
repo_remove_dangling_submodule()
{
  local smpath=$1 smid=${1%/}
  # io_trace "repo_remove_dangling_submodule ${*@Q} -1- $(print_vars smpath smid PWD)"
  gitx submodule deinit $smid 2>>"$stderrRedir" && gitx rm --cached $smid 2>>"$stderrRedir"
  rm -rf "$smpath"
  mio_warning "Removed dangling submodule '${smpath%/}'"
}
repo_remove_dangling_submodules()
{
  local dangling=($(repo_list_dangling_submodules))
  # io_trace "repo_remove_dangling_submodules ${*@Q} -1- $(print_vars dangling[@] PWD)"
  visit 'dangling[@]' repo_remove_dangling_submodule
}
repo_remove_dangling_submodules_async()
{
  local dangling=($(repo_list_dangling_submodules))
  # io_trace "repo_remove_dangling_submodules ${*@Q} -1- $(print_vars dangling[@] PWD)"
  visit_async 'dangling[@]' repo_remove_dangling_submodule
}
repo_prune_tags()
{
  local verbose=$1 showMessage=$2
  [[ $showMessage == true ]] && mio_warning "Pruning tags..."

  if [[ $verbose == true ]]; then
    gitx tag -l 2>>"$stderrRedir" | xargs --no-run-if-empty gitx tag -d &>>"$stdallRedir"
    io_buffered_eval 'gitx fetch --tags 2>&1' _repo_prune_tags_line_selector
  else
    gitx tag -l 2>>"$stderrRedir" | xargs --no-run-if-empty gitx tag -d &>>"$stdallRedir"
    gitx fetch --tags &>>"$stdallRedir"
  fi
}
_repo_prune_tags_line_selector()
{
  [[ $line =~ ^.*\[new\ tag\][[:blank:]]+(.*)$ ]] && line="${BASH_REMATCH[1]}"
}
repo_require_clean_work_tree()
{
    local prefix="$*"
    [[ -n $prefix ]] && prefix="$prefix - "
    local err=0 b

    # Update the index
    if ! gitx update-index -q --ignore-submodules --refresh &>>"$stdallRedir"; then
      io_lock_enter
      mio_error_unsafe "${prefix}You have unmerged paths."
      for b in $(repo_list_unmerged); do
        mio_error_unsafe "  $b"
      done
      mio_info_unsafe  "  Run 'git sync' again or resolve conflicts and run 'git commit'."
      io_lock_exit
      return 1
    fi

    # Disallow untracked changes in the working tree
    if ! test -z "$(repo_list_untracked)"; then
      io_lock_enter
      mio_error_unsafe "${prefix}Your work tree contains untracked changes."
      for b in $(repo_list_untracked); do
        mio_error_unsafe "  $b"
      done
      mio_info_unsafe  "  Run 'git add'"
      io_lock_exit
      err=1
    fi

    # Disallow unstaged changes in the working tree
    if ! test -z "$(repo_list_unstaged)"; then
      io_lock_enter
      mio_error_unsafe "${prefix}You have unstaged changes."
      for b in $(repo_list_unstaged); do
        mio_error_unsafe "  $b"
      done
      mio_info_unsafe  "  Run 'git stash' or 'git add' and 'git commit'."
      io_lock_exit
      err=1
    fi

    # Disallow uncommitted changes in the index
    if ! gitx diff-index --cached --quiet HEAD --ignore-submodules -- &>>"$stdallRedir"; then
      io_lock_enter
      mio_error_unsafe "${prefix}Your index contains uncommitted changes."
      for b in $(repo_list_uncommited); do
        mio_error_unsafe "  $b"
      done
      mio_info_unsafe  "  Run 'git commit'."
      io_lock_exit
      err=1
    fi

    return $err
}