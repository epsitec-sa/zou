#!/bin/bash
# http://schacon.github.io/git/git.html
# https://stackoverflow.com/questions/2657935/checking-for-a-dirty-index-or-untracked-files-with-git/2658301

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo
ZOUL_GIT_REPO=true

[[ -z $ZOUL_CORE ]] && . zoul-core

declare -A smPathLookup
export smPathLookup

repo_zouflow_path()    { echo "$(repo_module_dir)/$ZOU_FLOW_CONFIG"; }
repo_list_deleted()    { git ls-files --deleted; }
repo_list_unstaged()   { git diff-files --name-only -r --ignore-submodules --; }
repo_list_uncommited() { git diff-index --cached --name-only -r --ignore-submodules HEAD --; }
repo_list_unmerged()   { git diff --name-only --diff-filter=U --ignore-submodules | cut -f1; }
repo_is_merging()      { git merge HEAD &>/dev/null && return 1 || return 0; }

repo_is_root()             { [[ -d "${1:-.}/.git" ]]; }
repo_is_submodule()        { [[ -f "${1:-.}/.git" ]]; }
repo_is_submodule_level1() { repo_is_submodule "$1" && repo_is_root "${1:-.}/.." ]]; }

repo_list_submodules()
{
  local key value
  key=$(repo_module_dir) || return 1
  value=${smPathLookup[$key]}
  if [[ -z $value ]]; then
    value=$(git config --file "$key/.gitmodules" --get-regexp '^submodule\..*\.path$' | cut -d' ' -f2)
    smPathLookup[$key]=$value
  fi
  echo $value
}
repo_list_unstaged_submodules()
{
  local x
  for x in $(git diff-files --name-only -r); do
    repo_is_submodule "$x" && echo $x
  done
}
repo_commit_submodules()
{
  local unstaged=( $(repo_list_unstaged_submodules) )
  [ ${#unstaged[@]} -eq 0 ] && return 1
  local cslist=$(string_join ', ' "${unstaged[@]}")
  git commit -m "zou-flow: update submodules '$cslist'" -- "${unstaged[@]}" >/dev/null
  io_warning "Commited submodules '$cslist'" "[$(repo_module_id)]"
}
repo_commit_ancestor_submodules()
{
  local dir pwd=$PWD
  for dir in $(repo_module_and_ancestor_dirs "$@"); do
    cd $dir
    repo_commit_submodules
  done
  cd $pwd
}
repo_list_untracked()
{
  local x
  for x in $(git ls-files --exclude-standard --others); do
    repo_is_submodule "$x" || echo $x
  done
}
repo_list_dangling_submodules()
{
  local x
  for x in $(git ls-files --exclude-standard --others); do
    repo_is_submodule "$x" && echo $x
  done
}
repo_remove_dangling_submodule()
{
  local path=$1 sm=${1%/}
  git submodule deinit $sm 2>/dev/null && git rm --cached $sm 2>/dev/null
  rm -rf $path
}
repo_remove_dangling_submodules()
{
  local sm
  for sm in $(repo_list_dangling_submodules); do
    repo_remove_dangling_submodule $sm
  done
}
repo_bundle_dir()
{
  local dir
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" && ! -d "$dir/.git" ]]; do
    dir="${dir%/*}"
  done
  [[ -z $dir ]] && return 1
  echo "$dir"
}
repo_module_dir()
{
  local dir
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" || -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="${dir%/*}"
  done
  return 1
}
repo_parent_module_dir()
{
  local moduleDir
  moduleDir=$(repo_module_dir "$@") || return $?
  repo_module_dir "$moduleDir/.."
}

# return module path relative to parent module
repo_module_path()
{
  local mdir pdir
  mdir=$(repo_module_dir "${1:-.}") || return $?
  pdir=$(repo_module_dir "$mdir/..") || { realpath "${1:-.}"; return 0; }
  realpath --relative-to="$pdir" "$mdir"
}

repo_module_and_bundle_dirs()
{
  local dir=$(realpath ${1:-.}) mdir bdir
  while [[ -n "$dir" ]]; do
    if [[ -z "$mdir" && -f "$dir/.git" ]]; then
      mdir=$dir
      echo "$mdir"
    fi
    if [[ -d "$dir/.git" ]]; then
      if [[ -z "$mdir" ]]; then
        mdir=$dir
        echo "$mdir"
      fi
      bdir=$dir
      echo "$bdir"
      return 0
    fi
    dir=${dir%/*}
  done
  return 1
}
repo_module_and_ancestor_dirs()
{
  local dir=$(realpath ${1:-.})
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      echo "$dir"
    fi
    if [[ -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir=${dir%/*}
  done
  return 1
}
repo_module_relative_to_path()
{
  local path=$(realpath "${1:-.}") mdir
  mdir=$(repo_module_dir "${2:-.}") || return $?
  realpath --relative-to="$path" "$mdir"
}
# return the path relative to a bundle folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference bundle
repo_path_relative_to_bundle()
{
  local path bdir
  path=$(realpath "${1:-.}") || return $?
  bdir=$(repo_bundle_dir "${2:-.}") || return $?
  realpath --relative-to="$bdir" "$path"
}
# return the path relative to a module folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference module
repo_path_relative_to_module()
{
  local path=$(realpath "${1:-.}") mdir
  mdir=$(repo_module_dir "${2:-.}") || return $?
  realpath --relative-to="$mdir" "$path"
}
repo_url_from_dir()
{
  cd "${1:-.}"
  local url=$(git config remote.origin.url)
  cd - >/dev/null
  echo $url
}
repo_module_id()
{
  local dirs
  dirs=( $(repo_module_and_bundle_dirs "$@") )
  [ $? -ne 0 ] && return 1
  local mdir=${dirs[0]} bdir=${dirs[1]}
  if [[ $mdir == $bdir ]]; then
    echo ${bdir##*/}
  else
    echo ${mdir#$bdir/}
  fi
}
repo_bundle_id()
{
  local dir
  dir=$(repo_bundle_dir)
  [ $? -ne 0 ] && return 1
  echo ${dir##*/}
}

repo_update_submodules()
{
  local moduleId recursive
  while [[ "$#" > 0 ]]; do case "$1" in
    --recursive) recursive=$1;;
    *) moduleId=$1;;
  esac; shift; done
  local submodules=( $(repo_list_submodules) )
  if [ ${#submodules[@]} -ne 0 ]; then
    [[ -z $moduleId ]] && moduleId=$(repo_module_id)
    io_info 'Updating submodules...' "[$moduleId]"
    git submodule update --init $recursive
  fi
}
repo_update_submodule()
{
  local path=$1
  io_info 'Updating submodule '$path'...' "[$(repo_module_id)]"
  git submodule update --init --recursive "$path"
}
repo_require_clean_work_tree () {
    local prefix="$*"
    [[ $prefix =~ ^\[ ]] || prefix="[$(repo_module_id)] $prefix"
    local err=0

    # Update the index
    if ! git update-index -q --ignore-submodules --refresh &>/dev/null; then
        io_error 'You have unmerged paths.' "$prefix"
        io_error "$(repo_list_unmerged)" '%2s'
        io_info  "Resolve conflicts and run 'git commit'." '%2s'
        return 1
    fi

    # Disallow untracked changes in the working tree
    if ! test -z "$(repo_list_untracked)"; then
        io_error 'Your work tree contains untracked changes.' "$prefix"
        io_error "$(repo_list_untracked)" '%2s'
        io_info  "Run 'git add'" '%2s'
        err=1
    fi

    # Disallow unstaged changes in the working tree
    if ! git diff-files --quiet --ignore-submodules --; then
        io_error 'You have unstaged changes.' "$prefix"
        io_error "$(repo_list_unstaged)" '%2s'
        io_info  "Run 'git stash' or 'git add' and 'git commit'." '%2s'
        err=1
    fi

    # Disallow uncommitted changes in the index
    if ! git diff-index --cached --quiet HEAD --ignore-submodules --; then
        io_error 'Your index contains uncommitted changes.' "$prefix"
        io_error "$(repo_list_uncommited)" '%2s'
        io_info  "Run 'git commit'." '%2s'
        err=1
    fi

    return $err
}