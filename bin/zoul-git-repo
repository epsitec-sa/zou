#!/bin/bash
# http://schacon.github.io/git/git.html
# https://stackoverflow.com/questions/2657935/checking-for-a-dirty-index-or-untracked-files-with-git/2658301

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo
ZOUL_GIT_REPO=true

[[ -z $ZOUL_CORE ]] && . zoul-core

repo_ism_opt()         { [[ -z $KEEP_SUBMODULES ]] && echo '--ignore-submodules'; }
repo_list_submodules() { git config --file .gitmodules --get-regexp path | cut -d' ' -f2; }
repo_list_deleted()    { git ls-files --deleted; }
repo_list_unstaged()   { git diff-files --name-only -r $(repo_ism_opt) --; }
repo_list_uncommited() { git diff-index --cached --name-only -r $(repo_ism_opt) HEAD --; }
repo_list_unmerged()   { git diff --name-only --diff-filter=U $(repo_ism_opt) | cut -f1; }
repo_is_merging()      { git merge HEAD &>/dev/null && return 1 || return 0; }

repo_is_root()             { [[ -d "${1:-.}/.git" ]]; }
repo_is_submodule()        { [[ -f "${1:-.}/.git" ]]; }
repo_is_submodule_level1() { repo_is_submodule "$1" && repo_is_root "${1:-.}/.." ]]; }

repo_list_unstaged_submodules()
{
  local x
  OIFS=$IFS; IFS=$'\n'
  for x in $(git diff-files --name-only -r); do
    repo_is_submodule "$x" && echo $x
  done
  IFS=$OIFS
}
repo_commit_submodules()
{
  local unstaged=( $(repo_list_unstaged_submodules) )
  [ ${#unstaged[@]} -eq 0 ] && return 1
  local message="USMR: $(string_join ', ' "${unstaged[@]}")"
  git commit -m "$message" -- "${unstaged[@]}"
}
repo_list_untracked()
{
  local x
  OIFS=$IFS; IFS=$'\n'
  for x in $(git ls-files --exclude-standard --others); do
    repo_is_submodule "$x" || echo $x
  done
  IFS=$OIFS
}
repo_list_dangling_submodules()
{
  local x
  OIFS=$IFS; IFS=$'\n'
  for x in $(git ls-files --exclude-standard --others); do
    repo_is_submodule "$x" && echo $x
  done
  IFS=$OIFS
}
repo_remove_dangling_submodules() { repo_list_dangling_submodules | xargs -I{} rm -rf "{}"; }

repo_bundle_dir()
{
  local dir=$(realpath ${1:-.})
  while [[ -n "$dir" && ! -d "$dir/.git" ]]; do
    dir=${dir%/*}
  done
  echo $dir
}
repo_module_dir()
{
  local bdir=$(realpath ${1:-.})
  local mdir
  while [[ -n "$bdir" && ! -d "$bdir/.git" ]]; do
    [[ -z "$mdir" && -f "$bdir/.git" ]] && mdir=$bdir
    bdir=${bdir%/*}
  done
  [[ -n $mdir ]] && echo "$mdir" || echo "$bdir"
}
repo_module_name()
{
  local mdir=$(repo_module_dir "$@")
  echo ${mdir##*/}
}
repo_dir_url()
{
  cd "${1:-.}"
  local url=$(git config remote.origin.url)
  cd - >/dev/null
  echo $url
}
repo_module_id()
{
  local url=$(repo_dir_url "$@")
  local id=${url##*/} # get 'file name'
  echo ${id%.git}     # remove 'extension'
}
repo_bundle_id()
{
  repo_module_id $(repo_bundle_dir)
}

repo_update_submodules()
{
  local moduleName=$1
  [[ -z $moduleName ]] && moduleName=$(repo_module_name)
  local submodules=( $(repo_list_submodules) )
  if [ ${#submodules[@]} -ne 0 ]; then
    io_info 'updating submodules...' "[$moduleName]"
    git submodule update --recursive
  fi
}
repo_require_clean_work_tree () {
    # io_info >&2 "repo_require_clean_work_tree"
    local prefix="$*"
    [[ $prefix =~ ^\[ ]] || prefix="[$(repo_module_name)] $prefix"
    local err=0

    # Update the index
    if ! git update-index -q $(repo_ism_opt) --refresh &>/dev/null; then
        io_error 'your have unmerged paths.' "$prefix"
        io_message >&2 "$(repo_list_unmerged | sed 's/^/  /')" '' Red
        io_message >&2 "  resolve conflicts and run 'git commit'." '' LightCyan
        return 1
    fi

    # Disallow untracked changes in the working tree
    if ! test -z "$(repo_list_untracked)"; then
        io_error 'your work tree contains untracked changes.' "$prefix"
        io_message >&2 "$(repo_list_untracked | sed 's/^/  /')" '' Red
        io_message >&2 "  run 'git add'" '' LightCyan
        err=1
    fi

    # Disallow unstaged changes in the working tree
    if ! git diff-files --quiet $(repo_ism_opt) --; then
        io_error 'you have unstaged changes.' "$prefix"
        io_message >&2 "$(repo_list_unstaged | sed 's/^/  /')" '' Red
        io_message >&2 "  run 'git stash' or 'git add' and 'git commit'." '' LightCyan
        err=1
    fi

    # Disallow uncommitted changes in the index
    if ! git diff-index --cached --quiet HEAD $(repo_ism_opt) --; then
        io_error 'your index contains uncommitted changes.' "$prefix"
        io_message >&2 "$(repo_list_uncommited | sed 's/^/  /')" '' Red
        io_message >&2 "  run 'git commit'." '' LightCyan
        err=1
    fi

    return $err
}