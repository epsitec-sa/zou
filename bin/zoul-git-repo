#!/bin/bash

# Manage repository
# 
# bundle ID
# bundle root path
#   
# module ID
#   = module relative path
# module relative path
#   the module root path relative to the bundle root path
# module root path
#  
# submodule ID
#   the name of the section in the .gitmodules file
# submodule relative path
#   the path value in the .gitmodules config file
#   = relative path to the parent module / bundle
#
# Exemples:
# repo_bundle_id        # zou-dev
# repo_bundle_root      # /c/devel/zou-dev
# repo_module_id        # zou, Bcx
# repo_module_root      # /c/devel/zou-dev/zou, /c/devel/zou-dev/Bcx, ...



# http://schacon.github.io/git/git.html
# https://stackoverflow.com/questions/2657935/checking-for-a-dirty-index-or-untracked-files-with-git/2658301

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo
ZOUL_GIT_REPO=true

[[ -z $ZOUL_CORE ]] && . zoul-core


######################
# Bundle
repo_bundle_id()
{
  local dir
  dir=$(repo_bundle_root)
  [ $? -ne 0 ] && return 1
  echo ${dir##*/}
}
repo_bundle_root()
{
  local dir
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" && ! -d "$dir/.git" ]]; do
    dir="${dir%/*}"
  done
  [[ -z $dir ]] && return 1
  echo "$dir"
}
# return the path relative to the bundle root of any bundle folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference bundle
repo_path_relative_to_bundle_root()
{
  local path bdir
  path=$(realpath "${1:-.}") || return $?
  bdir=$(repo_bundle_root "${2:-.}") || return $?
  realpath --relative-to="$bdir" "$path"
}

######################
# Module
repo_module_id()
{
  local dirs
  dirs=( $(repo_module_and_bundle_roots "$@") )
  [ $? -ne 0 ] && return 1
  local mdir=${dirs[0]} bdir=${dirs[1]}
  if [[ $mdir == $bdir ]]; then
    echo ${bdir##*/}
  else
    echo ${mdir#$bdir/}
  fi
}
repo_module_root()
{
  local dir
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" || -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="${dir%/*}"
  done
  return 1
}
repo_module_parent()
{
  local mroot
  mroot=$(repo_module_root) || return $?
  if ! repo_is_bundle_root "$mroot"; then
    repo_module_root "$mroot/.."
    return 0
  fi
  return 1
}
repo_module_level()
{
  local dir level=0
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      level=$(( $level + 1 ))
    elif [[ -d "$dir/.git" ]]; then
      echo $level
      return 0
    fi
    dir="${dir%/*}"
  done
  echo -1
  return 1
}

# return the path relative to the module root of any module folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference module
repo_module_root_relative_to_path()
{
  local dir=$(realpath "${1:-.}") mdir
  mdir=$(repo_module_root "${2:-.}") || return $?
  realpath --relative-to="$dir" "$mdir"
}
# return the path relative to the module root of any module folder
# input:
#  $1 : the path to compute the relative path
#  $2 : any folder path inside the reference module
repo_path_relative_to_module_root()
{
  local dir=$(realpath "${1:-.}") mdir
  mdir=$(repo_module_root "${2:-.}") || return $?
  realpath --relative-to="$mdir" "$dir"
}
repo_module_and_bundle_roots()
{
  local dir=$(realpath ${1:-.}) mdir bdir
  while [[ -n "$dir" ]]; do
    if [[ -z "$mdir" && -f "$dir/.git" ]]; then
      mdir=$dir
      echo "$mdir"
    fi
    if [[ -d "$dir/.git" ]]; then
      if [[ -z "$mdir" ]]; then
        mdir=$dir
        echo "$mdir"
      fi
      bdir=$dir
      echo "$bdir"
      return 0
    fi
    dir=${dir%/*}
  done
  return 1
}
repo_ancestor_roots()
{
  local mparent
  mparent=$(repo_module_parent "$1") || return $?
  repo_module_and_ancestor_roots "$mparent"
}
repo_module_and_ancestor_roots()
{
  local dir=$(realpath ${1:-.})
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      echo "$dir"
    elif [[ -d "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir=${dir%/*}
  done
  return 1
}

######################
# Submodule

repo_submodule_root()
{
  local dir
  dir=$(realpath "${1:-.}") || return $?
  while [[ -n "$dir" ]]; do
    if [[ -f "$dir/.git" ]]; then
      echo "$dir"
      return 0
    fi
    dir="${dir%/*}"
  done
  return 1
}
repo_submodule_path()
{
  local smId=$1 root=$2
  [[ -z $root ]] && { root=$(repo_module_root) || return 1; }
  git config --file "$root/.gitmodules" "submodule.$smId.path"
}

######################

repo_url_from_path()
{
  local pwd=$PWD; cd "${1:-.}"
  local url=$(git config remote.origin.url)
  cd $pwd
  echo $url
}

repo_gitmodules_path()
{
  local mroot=$1 smid smpath
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  echo "$mroot/.gitmodules"
}

repo_list_deleted()    { git ls-files --deleted; }
repo_list_unstaged()   { git diff-files --name-only -r --ignore-submodules --; }
repo_list_uncommited() { git diff-index --cached --name-only -r --ignore-submodules HEAD --; }
repo_list_unmerged()   { git diff --name-only --diff-filter=U --ignore-submodules | cut -f1; }
repo_is_merging()      { git merge HEAD &>/dev/null && return 1 || return 0; }
repo_is_clean()        { git diff-index --ignore-submodules --quiet HEAD --; }

repo_is_bundle_root()  { [[ -d "${1:-.}/.git" ]]; }
repo_is_module_root()  { [[ -f "${1:-.}/.git" ]]; }

repo_has_submodules()
{
  local mroot=$1
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  git config --file "$mroot/.gitmodules" --get-regexp '^submodule\..*\.path$' &>/dev/null
}
repo_list_submodule_paths()
{
  local mroot=$1
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  git config --file "$mroot/.gitmodules" --get-regexp '^submodule\..*\.path$' | cut -d' ' -f2
}
repo_list_unstaged_submodules()
{
  local mroot=$1 smid smpath
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  for smid in $(git diff-files --name-only -r); do
    smpath=$(repo_submodule_path "$smid" "$mroot")
    [[ -z $smpath ]] && continue
    if repo_is_module_root "$mroot/$smpath"; then
      echo $smid
    fi
  done
}
repo_list_unstaged_clean_submodules()
{
  local mroot=$1 smid smpath smroot opwd=$PWD
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  for smid in $(git diff-files --name-only -r); do
    smpath=$(repo_submodule_path "$smid" "$mroot")
    [[ -z $smpath ]] && continue
    smroot="$mroot/$smpath"
    if repo_is_module_root "$smroot"; then
      cd "$smroot"
      repo_is_clean && echo $smid
      cd "$opwd"
    fi
  done
}
repo_list_untracked()
{
  local mroot=$1 path smpath opwd=$PWD
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }
  cd "$mroot"
  for path in $(git ls-files --exclude-standard --others); do
    if [[ -f $path ]]; then
      echo $path
    else
      # skip dangling submodules
      repo_is_module_root "$path" || echo $path
    fi
  done
  cd "$opwd"
}
repo_list_dangling_submodules()
{
  local path
  for path in $(git ls-files --exclude-standard --others); do
    [[ -d $path ]] && repo_is_module_root "$path" && echo "$path"
  done
}
repo_commit_clean_submodules() { repo_commit_submodule_enumerator 'repo_list_unstaged_clean_submodules' "$1"; }
repo_commit_all_submodules()   { repo_commit_submodule_enumerator 'repo_list_unstaged_submodules' "$1"; }
repo_commit_submodule_enumerator()
{
  local enumerator=$1 mroot=$2 submodules
  submodules=$($enumerator "$mroot") || return 1
  repo_commit_submodules "$mroot" $submodules
}
repo_commit_submodules()
{
  # echo repo_commit_submodules "${*@Q}" >&2
  local mroot=$1; shift
  [ $# -eq 0 ] && return 1
  [[ -z $mroot ]] && { mroot=$(repo_module_root) || return 1; }

  local opwd=$PWD cslist=$(string_join ', ' "$@")
  cd "$mroot"
  local branch=$(branch_current)
  git commit -m "zou-flow: update submodules '$cslist' on branch '$branch'" -- "$@" >/dev/null
  io_warning "Commited submodules '$cslist' on branch '$branch'" "$moduleTracePrefix"
  cd "$opwd"
}
repo_remove_dangling_submodule()
{
  local smpath=$1 smid=${1%/}
  # echo "git submodule deinit $smid + git rm --cached $smid"
  git submodule deinit $smid 2>/dev/null && git rm --cached $smid 2>/dev/null
  rm -rf "$smpath"
  io_warning "Removed dangling submodule '${smpath%/}'" "$moduleTracePrefix"
}
repo_discard_submodule()
{
  local smpath=$1
  git submodule update --recursive "$smpath" &>/dev/null
  io_warning "Discarded submodule '$smpath' from branch '$moduleBranch'" "$moduleTracePrefix"
}
repo_remove_dangling_submodules_async()
{
  visit_async repo_list_dangling_submodules repo_remove_dangling_submodule
}
repo_discard_clean_submodules_async()
{
  visit_async repo_list_unstaged_clean_submodules repo_discard_submodule
}
repo_update_submodules()
{
  [ ${#moduleSubmodulePaths[@]} -eq 0 ] && return 0
  io_info 'Updating submodules...' "$moduleTracePrefix"
  (git submodule update --init --recursive 2>&1) | \
  while read -r line; do
    [[ -n $line ]] && io_info "$line" "$moduleTracePrefix"
  done
}
repo_update_submodule()
{
  local path=$1 line
  (git submodule update --init --recursive "$path" 2>&1) | \
  while read -r line; do
    [[ -n $line ]] && io_info "$line" "$moduleTracePrefix"
  done
}
repo_check_submodule()
{
  [[ -f .git || -d .git ]] && return 0
  cd "$startupRoot"
  repo_update_submodule "$1"
  cd "$1"
  [[ -f .git || -d .git ]] && return 0
  io_error "Not a git submodule '$1'" "$moduleTracePrefix"
  return 1
}
repo_require_clean_work_tree()
{
    local prefix="$*"
    [[ -n $prefix ]] && prefix="$prefix - "
    local err=0 b

    # Update the index
    if ! git update-index -q --ignore-submodules --refresh &>/dev/null; then
        io_error "${prefix}You have unmerged paths." "$moduleTracePrefix"
        for b in $(repo_list_unmerged); do
          io_error "  $b" "$moduleTracePrefix"
        done
        io_info  "  Resolve conflicts and run 'git commit'." "$moduleTracePrefix"
        return 1
    fi

    # Disallow untracked changes in the working tree
    if ! test -z "$(repo_list_untracked)"; then
        io_error "${prefix}Your work tree contains untracked changes." "$moduleTracePrefix"
        for b in $(repo_list_untracked); do
          io_error "  $b" "$moduleTracePrefix"
        done
        io_info  "  Run 'git add'" "$moduleTracePrefix"
        err=1
    fi

    # Disallow unstaged changes in the working tree
    if ! git diff-files --quiet --ignore-submodules --; then
        io_error "${prefix}You have unstaged changes." "$moduleTracePrefix"
        for b in $(repo_list_unstaged); do
          io_error "  $b" "$moduleTracePrefix"
        done
        io_info  "  Run 'git stash' or 'git add' and 'git commit'." "$moduleTracePrefix"
        err=1
    fi

    # Disallow uncommitted changes in the index
    if ! git diff-index --cached --quiet HEAD --ignore-submodules --; then
        io_error "${prefix}Your index contains uncommitted changes." "$moduleTracePrefix"
        for b in $(repo_list_uncommited); do
          io_error "  $b" "$moduleTracePrefix"
        done
        io_info  "  Run 'git commit'." "$moduleTracePrefix"
        err=1
    fi

    return $err
}