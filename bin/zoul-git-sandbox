#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_SANDBOX ]] && . zoul-git-sandbox
ZOUL_GIT_SANDBOX=true

[[ -z $ZOUL_CORE ]]              && . zoul-core
[[ -z $ZOUL_GIT_SANDBOX_DATA ]]  && . zoul-git-sandbox-data
[[ -z $ZOUL_GIT_SANDBOX_UTILS ]] && . zoul-git-sandbox-utils

sandbox_create()
{
  local sandboxReset createSubmodules
  while [[ "$#" > 0 ]]; do case "$1" in
    --reset) sandboxReset=true;;
    --sm)    createSubmodules=true;;
  esac; shift; done

  [[ $sandboxReset == true ]] && sandbox_delete
  ( sandbox_create_bundle ) &
  [[ $createSubmodules == true ]] && sandbox_create_submodules
  wait

  sandbox_clone
  mio_warning "$(printf '%.s-' {1..42}) created repos at ${VC}$zouTestRoot"
}

sandbox_create_bundle()
{
  [ -d $satHubDir ] && return 0
  _sandbox_create_local_and_remote_repo "$sat1Dir" "$satHubDir"
}
sandbox_delete()
{
  [ -d $satHubDir ] || return 0
  for id in sm1 sm2 sm3 sat1 sat2 origin; do
  (
    dir=${id}Dir; dir=${!dir}
    _sandbox_delete_repo "$dir"
  ) &
  done
  wait
}
sandbox_clone()
{
  # SAT2 <- HUB
  mio_info "Cloning ${VC}sat2"
  cd "$zouTestRoot"
  git clone --recurse-submodules -j16 "$satHubDir" 'sat2' &>/dev/null
}
sandbox_create_submodules()
{
  [ -d "$sat1Dir/sm1" ] && return 0

  for id in sm1 sm2 sm3; do
    ( _sandbox_create_sm_repo "$id" ) &
  done
  wait

  # populate submodules

  # SM1.SM3
  cd "$sm1Dir"
  git submodule add "$sm3HubDir" 'sm3' &>/dev/null
  mio_info "Added submodule ${VC}sm3${Cyan} to ${VC}sm1"
  git commit -m'SM1: add submodule' &>/dev/null
  git submodule update --init --recursive &>/dev/null
  git push -u origin master &>/dev/null

  # SAT1.SM1, SAT1.SM2
  cd "$sat1Dir"
  git submodule add "$sm1HubDir" 'sm1' &>/dev/null
  mio_info "Added submodule ${VC}sm1${Cyan} to ${VC}sat1"
  git submodule add "$sm2HubDir" 'sm2' &>/dev/null
  mio_info "Added submodule ${VC}sm2${Cyan} to ${VC}sat1"
  git commit -m'SAT1: add submodules' &>/dev/null

  git submodule update --init --recursive &>/dev/null
}
sandbox_create_skus()
{
  cd "$sat1Dir/sm1"
  sandbox_create_sku_with_work sku/sm1/dev
  sandbox_commit_work
  cd "$sat1Dir/sm2"
  sandbox_create_sku_with_work sku/sm2/dev
  sandbox_create_sku_with_work sku/dev
  sandbox_commit_work
  cd "$sat1Dir"
  sandbox_create_sku_with_work sku/sm1/dev
  sandbox_create_sku_with_work sku/sm2/dev
  sandbox_commit_work
}
sandbox_create_vresources()
{
  if sandbox_visit "$sat1Dir/sm2" commit_vresources_compta \
  && sandbox_visit "$sat1Dir/sm1" commit_vresources_sal; then
    sandbox_visit "$sat1Dir" commit_version_props
  else
    sandbox_visit "$sat1Dir" commit_vresources_sal
  fi

  cd "$sat1Dir"
  git-config-version -r --reset --auto
}
sandbox_create_work()
{
  sandbox_visit_commit_work "$sat1Dir/sm1" "$sat1Dir/sm1/sm3" "$sat1Dir/sm2" "$sat1Dir"
}

sandbox_create_sku_with_work()
{
  local sku=$1 startPoint=${2:-master}
  git checkout -b "$sku" "$startPoint" &>/dev/null
  sandbox_commit_work
  git checkout - &>/dev/null
}
# example:
#   sandbox_visit_commit_work "$sat1Dir" "$sat1Dir/sm1" "$sat1Dir/sm2"
sandbox_commit_work()
{
  local file=${1:-$(file_create_name)}
  file_change_commit "$file" "some work @ $(date +%T) on $(git symbolic-ref --short HEAD 2>/dev/null)"
}
sandbox_visit_commit_work()
{
  local path
  for path; do
    sandbox_visit "$path" sandbox_commit_work
  done
}
sandbox_visit()
{
  local path=$(realpath ${1:-.})
  # io_trace "sandbox_visit ${*@Q}"
  if [[ $path == $PWD ]]; then
    $2 "${@:3}"
  elif [ -d "$path" ]; then
    local OPWD=$PWD ec=0
    cd "$path"
    $2 "${@:3}" || ec=$?
    cd $OPWD
    return $ec
  else
    return 128
  fi
}

_sandbox_create_local_and_remote_repo()
{
  local localDir=$1 remoteDir=$2

  _sandbox_create_empty_repo "$remoteDir" --bare
  _sandbox_create_empty_repo "$localDir"
  git remote add origin "$remoteDir"
  # - readme
  file_change_commit 'readme.md' 'initial version'
  git push -u origin master &>/dev/null
}
_sandbox_create_empty_repo()
{
  [[ -d "$1" ]] || mkdir -p "$1"
  cd "$1"
  git init "${@:2}" &>/dev/null
  mio_info "Created repo at ${VC}$1"
}
_sandbox_create_sm_repo()
{
  local id=$1 localDir remoteDir
  localDir=${id}Dir; localDir=${!localDir}
  remoteDir=${1}HubDir; remoteDir=${!remoteDir}
  _sandbox_create_local_and_remote_repo "$localDir" "$remoteDir"
}
_sandbox_delete_repo()
{
  [[ -d "$1" ]] || return 0
  rm -rf "$1"
  mio_warning "Deleted repo ${VC}$1"
}
