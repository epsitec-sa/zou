#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_PROD ]] && . zoul-git-prod
ZOUL_GIT_PROD=true

[[ -z $ZOUL_GIT_REF ]]            && . zoul-git-ref
[[ -z $ZOUL_GIT_VBRANCH ]]        && . zoul-git-vbranch
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]   && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_CONFIG_VERSION ]] && . zoul-git-config-version

# io_trace "headChangedEvent+=( prod_reset_scope )"
headChangedEvent+=( _prod_on_head_changed )
headNameChangedEvent+=( _prod_on_head_name_changed )
branchCreatedEvent+=( _prod_on_branch_created )
branchDeletedEvent+=( _prod_on_branch_deleted )

# usage:
#   module_run prod_scope $*
prod_scope()
{
  # setup prod context
  local prodScopeInitialized=true \
        prodBranch prodBranchPath \
        prodVTag prodHTag prodAlias devAlias moduleAlias \
        vtagStatus vtag2dev vtag2prod \
        releaseVTag releasePrerelPrefix releaseStatus
  
  prod_reset_scope

  # execute next russian doll
  # io_trace "prod_scope >> $*"
  $1 "${@:2}"
  # io_trace "prod_scope << $*"
}
prod_reset_scope()
{
  # avoid prematured event processing
  [[ $prodScopeInitialized == true ]] || return 0

  _prod_init_vars

  if [[ $configSelectIsExcluded == true ]]; then
    _prod_init_xscope
  else
    _prod_init_scope "$moduleHead"
  fi
}
_prod_reset_alias()
{
  module_in_prod_mode && moduleAlias=$prodAlias || moduleAlias=$devAlias
}
_prod_trace()
{
  return 0

  io_lock_enter
  io_trace_unsafe "$1 -- $(print_vars prodBranch prodBranchPath)"
  io_trace_unsafe "$1 -- $(print_vars vtagStatus prodVTag prodHTag)"
  io_trace_unsafe "$1 -- $(print_vars vtag2dev vtag2prod prodAlias devAlias moduleAlias)"
  io_trace_unsafe "$1 -- $(print_vars releaseStatus releaseVTag releasePrerelPrefix)"
  io_lock_exit
}

########################################################
# SCOPE INITIALIZATION

_prod_init_vars()
{
  prodBranch=''; prodBranchPath=''; prodVTag=''; prodHTag=''
  vtagStatus='vtagMissing'; vtag2dev=0; vtag2prod=0
  releaseVTag=''; releasePrerelPrefix=''; releaseStatus='error'
  local alias; vtag_format_alias
  prodAlias=$alias; devAlias=$alias; moduleAlias=$alias 
  # io_trace "_prod_init_vars -- $(print_vars prodAlias devAlias moduleAlias)"
}
_prod_init_scope()
{
  # io_trace "_prod_init_scope ${*@Q}"
  local devBranchPath=$1 devBranch=${2:-$1} \
        vbranch vtag htag delta=0 alias status strict

  # 1. Retrieve vtag and vbranch info starting from dev branch
  module_is_bundle && strict=true
  vtag_set_describe "$devBranchPath" "$devBranch" 'auto' "$strict" # -> vbranch vtag delta alias
  if [[ -n $vtag ]]; then
    _prod_init_dev true

    # 2. Retrieve vtag and vbranch info starting from prod branch
    if [[ -z $prodBranchPath ]]; then
      _prod_set_no_prod_info "$vtag"
    else
      _prod_set_prod_info
    fi
    _prod_init_prod
  else
    status='vtagMissing'
    vtag_format_alias "$vtag" "$delta"
    _prod_init_dev
  fi
  _prod_init_release_status "$delta" "$status"

  _prod_trace '_prod_init_scope'
}
_prod_init_xscope()
{
  local vbranch vtag htag delta=0 alias status strict

  # io_trace "_prod_init_xscope 1 -- $(print_vars moduleHead)"
  module_is_bundle && strict=true
  vtag_set_describe "$moduleHead" "$moduleHead" false # -> vbranch vtag delta alias
  if [[ -n $vtag ]]; then
    _prod_init_dev false

    # 2. Retrieve vtag and vbranch info starting from prod branch
    if [[ -z $prodBranchPath ]]; then
      _prod_set_no_prod_info "$vtag"
    else
      _prod_set_xprod_info
    fi
    _prod_init_prod
    releaseStatus='released'
  fi

  _prod_trace '_prod_init_xscope'
}
_prod_init_dev()
{
  local vbranchCreate=$1
  if [[ -n $vbranch ]]; then
    local branch lbranch bref
    branch_set_realize "$vbranch"
    if [[ -z $branch && $vbranchCreate == true ]]; then
      branch_create "$vbranch" "$vtag"
      branch_set_realize "$vbranch"
    fi
    prodBranchPath=$branch
    prodBranch=$lbranch
    # io_trace "_prod_init_dev -- $(print_vars prodBranch prodBranchPath vbranch)"
  fi
  prodVTag=$vtag
  vtag2dev=$delta
  devAlias=$alias
  moduleAlias=$alias
}
_prod_init_prod()
{
  prodVTag=$vtag
  prodHTag=$htag
  prodAlias=$alias
  vtag2prod=$delta
  vtagStatus=$status
  releaseVTag=$vtag
  vtag_is_semver "$vtag" && releasePrerelPrefix=${BASH_REMATCH[7]#-}

  _prod_reset_alias
}
# usage:
#   local vbranch vtag htag delta alias status
#   _prod_set_prod_info
# scope:
#   devBranch devBranchPath prodBranch prodBranchPath strict
# out:
#   vbranch   -- associated version branch
#   vtag      -- nearest vtag (depends on skipVNodes value)
#   htag      -- highest vtag on vbranch (depends on allowDuplicateTags value)
#   delta     -- number of commits between branch and vtag (can be negative if branch is behind vtag)
#   alias     -- condensed vtag info - (> v1.0.0 (8)) means branch is ahead of v1.0.0 by 8 commits
#   status    -- vnode       -- nearest vtag is a vnode (branch was never released on this vbranch)
#                vtag        -- nearest vtag is a vtag
#                vtagMissing -- no vtag found (branch was never released)
_prod_set_prod_info()
{
  vtag_set_describe "$prodBranchPath" "$prodBranch" 'auto' "$strict" # -> vbranch vtag delta alias
  if [[ $vbranch != $prodBranch ]]; then
    mio_error "Branches ${VC}$prodBranch${LightPurple} and ${VC}$vbranch${LightPurple} are both descendants of (${VC}$vtag)" ${LightPurple}
    return 1
  fi
  # get highest tag in same folder
  htag=$(vtag_highest "$vbranch" true)   # in same folder
  # io_trace "_prod_set_prod_info 1 -- $(print_vars prodBranch prodBranchPath vbranch vtag htag delta alias)"
  if [[ $htag != $vtag ]]; then
    vtag=$htag
    delta=$(( $(git rev-list --count $vtag..$prodBranchPath) ))
    vtag_format_alias "$vtag" "$delta"
    # io_trace "_prod_set_prod_info 2 -- $(print_vars prodBranch vbranch vtag htag delta alias)"
  fi
  [[ -z $strict ]] && htag=$(vtag_highest "$vbranch" false) # in all folders
  # vnode or vtag
  vtag_is_vnode $vtag && status='vnode' || status='vtag'
  # io_trace "_prod_set_prod_info 3 -- $(print_vars prodBranch vbranch vtag htag status alias)"
}
_prod_set_xprod_info()
{
  vtag_set_describe "$prodBranchPath" "$prodBranch" 'auto' "$strict" # -> vbranch vtag delta alias
  # io_trace "_prod_set_xprod_info 1 -- $(print_vars prodBranch vbranch vtag htag delta alias)"
  if module_is_bundle; then
    htag=$(vtag_highest $vbranch true)
  else
    htag=$(vtag_highest $vbranch false)
  fi
  # vnode or vtag
  vtag_is_vnode $vtag && status='vnode' || status='vtag'
  # io_trace "_prod_set_xprod_info 2 -- $(print_vars prodBranch vbranch vtag htag status alias)"
}
# in:  vtag
# out: htag delta alias status
_prod_set_no_prod_info()
{
  local vtag=$1
  htag=$vtag
  delta=0
  if [[ -z $vtag ]]; then
    status='vtagMissing'
    alias='<>'
  else
    vtag_is_vnode $vtag && status='vnode' || status='vtag'
  fi
  vtag_format_alias "$vtag" "$delta"
  # io_trace "_prod_set_no_prod_info -- $(print_vars vtag htag delta status alias)"
}
# in:  delta status
# out: releaseStatus -- (error, unreleasable, released, unreleased, ffRelease)
_prod_init_release_status()
{
  local delta=$1 status=$2
  # io_trace "_prod_init_release_status -- $(print_vars delta status)"
  releaseStatus='error'
  if [[ $status == 'vtagMissing' ]]; then
    releaseStatus='unreleasable'
  elif [[ $status == 'vtag' ]]; then
    # released at least once on this vbranch
    if [ $delta -eq 0 ]; then
      # head has not been moved since last publish
      releaseStatus='released'
    elif [ $delta -gt 0 ]; then
      releaseStatus='unreleased'
    else
      # prod branch is behind vtag
      releaseStatus='ffRelease'
    fi
  elif [[ $status == 'vnode' ]]; then
    # never released on this vbranch
    releaseStatus='unreleased'
  else
    mio_error "_prod_init_release_status: status '$status' not implemented"
    return 1
  fi
  # io_trace "_prod_init_release_status -> $(print_vars releaseStatus)"
}

########################################################
# CHECKOUT

# in:
#   $1:sku
#   $2:checkoutType -- (vtag|vnext|dev) default to vtag
sku_checkout()
{
  # io_trace "sku_checkout ${*@Q}"
  local sku=$1 checkoutType=${2:-vtag} forceCheckout=$3 branch lbranch ec=0
  branch_set_best_match_dev "$sku"  # -> branch lbranch
  _prod_init_scope "$branch" "$lbranch"
  # io_trace "sku_checkout -- $(print_vars branch lbranch)"

  case $checkoutType in
    vtag)   prod_checkout false "$forceCheckout" "$lbranch" || ec=$?;;
    vnext)  prod_checkout true  "$forceCheckout" "$lbranch" || ec=$?;;
    dev)    dev_checkout        "$forceCheckout" "$lbranch" || ec=$?;;
  esac

  return $ec
}
prod_checkout()
{
  local vnext=$1 forceCheckout=$2 devBranch=$3
  # io_trace "prod_checkout -- $(print_vars vnext forceCheckout devBranch vtagStatus prodBranch prodVTag)"
  if [[ $vtagStatus == 'vtag' ]]; then
    if [[ $vnext == true ]]; then
      branch_checkout "$prodBranch" "$forceCheckout"
    elif [[ -n $prodVTag ]]; then
      branch_checkout "$prodVTag" "$forceCheckout"
    else
      dev_checkout "$forceCheckout" "$devBranch"
    fi
  else
    dev_checkout "$forceCheckout" "$devBranch"
  fi
}
dev_checkout()
{
  # io_trace "dev_checkout -- ${*@Q}"
  local forceCheckout=$1 devBranch=$2
  if [[ -z $devBranch ]]; then
    if module_is_bundle; then
      devBranch=$bundleDevBranch
    else
      local branch lbranch
      branch_set_best_match_dev "$bundleDevBranch" # -> branch lbranch
      devBranch=$lbranch
      # io_trace "dev_checkout 1 -- $(print_vars bundleDevBranch branch lbranch devBranch)"
    fi
  fi
  devBranch=$(wip_to_ref $devBranch)
  # io_trace "dev_checkout 2 -- $(print_vars bundleDevBranch branch lbranch devBranch)"
  branch_checkout "$devBranch" "$forceCheckout"
}

########################################################
# BRANCH CREATION

# in:
#   version=${1:-0.1}   -- default version if no vbranch exists
#   incrementKind=${2}  -- (minor|major)
#                       -- increment minor or major version if vbranch exists
# exemple:
#   prod_ensure_vbranch 0.1 'minor'
prod_ensure_vbranch()
{
  if [[ $prodBranch =~ ^(.*/)?([0-9]+)\.([0-9]+)(.*)$ ]]; then
    local vbranch prodFolder major=${BASH_REMATCH[2]} minor=${BASH_REMATCH[3]} suffix=${BASH_REMATCH[4]} \
    # prod folder should be equal to dev folder
    [[ $(wip_to_ref $moduleDevBranch) =~ ^(.*/)? ]] && prodFolder=${BASH_REMATCH[1]}
    # update major and/or minor versions
    case $incrementKind in
      minor) (( minor += 1 ));;
      major) (( major += 1 )); minor=0;;
    esac
    vbranch="${prodFolder}${major}.${minor}${suffix}"
    if [[ $vbranch != $prodBranch ]]; then
      vbranch_create "$vbranch" "$moduleDevBranchPath"
    fi
  else
    local version=$1 branch lbranch bref vbranch
    [[ $incrementKind == 'major' ]] && version=${version:-1.0} || version=${version:-0.1}
    branch_set_realize $(wip_to_ref $moduleDevBranch)
    # io_trace "prod_ensure_vbranch 2 -- $(print_vars version incrementKind prodBranch vtag2dev branch lbranch)"

    [[ $lbranch =~ ^(.*/)? ]] || return 1
    vbranch=${BASH_REMATCH[1]}$version
    # io_trace "prod_ensure_vbranch 3 -- $(print_vars vbranch)"
    vbranch_create "$vbranch" "$branch"
  fi
  _prod_ensure_bundle_vbranch
}
_prod_ensure_bundle_vbranch()
{
  module_is_principal || return 0
  # io_trace "_prod_ensure_bundle_vbranch -- $(print_vars moduleId principalModuleId prodBranch)"
  local bundleScopes=( prod_scope )
  module_visit "$bundleRoot" "${bundleScopes[@]}" _prod_ensure_bundle_vbranch_core "$prodBranch"
}
_prod_ensure_bundle_vbranch_core()
{
  [[ $prodBranch == $1 ]] && return 0
  
  local principalBranch=$1 principalVersion principalSuffix \
        devFolder devBranch vbranch

  [[ $principalBranch =~ ^(.*/)?([0-9]+\.[0-9]+)(.*)$ ]]
  principalVersion=${BASH_REMATCH[2]}
  principalSuffix=${BASH_REMATCH[3]}

  devBranch=$(wip_to_ref "$moduleDevBranch")
  [[ $devBranch =~ ^(.*/) ]] && devFolder=${BASH_REMATCH[1]}

  vbranch=${devFolder}${principalVersion}${principalSuffix}
  # io_trace "_prod_ensure_bundle_vbranch_core ${*@Q} -- $(print_vars principalBranch principalVersion principalSuffix devFolder vbranch)"

  vbranch_create "$vbranch" "$moduleDevBranchPath"
}

########################################################
# RELEASE

prod_fix_release_status()
{
  local prerelPrefix=$1 forceRelease=$2
  # io_trace "prod_fix_release_status 1 -- $(print_vars forceRelease prerelPrefix releasePrerelPrefix releaseStatus)"
  _prod_should_release "$@" && releaseStatus='unreleased'
  # io_trace "prod_fix_release_status 2 -- $(print_vars forceRelease prerelPrefix releasePrerelPrefix releaseStatus)"
}
_prod_should_release()
{
  local prerelPrefix=$1 forceRelease=$2
  [[ $forceRelease == true ]] && return 0
  [[ $releaseStatus != 'released' ]] && return 1
  # io_trace "_prod_should_release 1 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  cosm_has_unstaged_submodules && return 0
  # io_trace "_prod_should_release 2 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  [[ -z $prerelPrefix || $prerelPrefix == 'reuse' ]] && return 1
  # io_trace "_prod_should_release 3 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  [[ $prerelPrefix == 'rtm' && -z $releasePrerelPrefix ]] && return 1
  # io_trace "_prod_should_release 4 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  [[ $prerelPrefix == $releasePrerelPrefix ]] && return 1
  # io_trace "_prod_should_release 5 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  [[ $prerelPrefix > $releasePrerelPrefix ]] && return 0
  # io_trace "_prod_should_release 6 -- $(print_vars prerelPrefix releasePrerelPrefix releaseStatus)"
  return 1
}

prod_increment_release_version()
{
  local prerelPrefix=$1 noIncrement
  # get principal module version
  _prod_refresh_bundle_htag # update prodHTag and noIncrement
  _prod_increment_release_version "$prerelPrefix" "$noIncrement" # -> releaseVTag releasePrerelPrefix

  # io_lock_enter
  # io_trace_unsafe "prod_increment_release_version -- $(print_vars releaseStatus releasePrerelPrefix)"
  # io_trace_unsafe "prod_increment_release_version -- $(print_vars prodVTag prodHTag releaseVTag)"
  # io_lock_exit
}
prod_commit_release()
{
  if [[ $releasePrerelPrefix == 'reuse' ]]; then
    _prod_commit_release_core
    tag_move "$releaseVTag" "$prodBranch"
    # io_trace "prod_commit_release 1 -- $(print_vars releasePrerelPrefix releaseVTag prodBranch)"
  else
    # update technical version
    _prod_commit_release_core 'version_update'
    local comment="publish branch '$prodBranch' as '$releaseVTag'"
    git tag -a -m "zou-flow: $comment" "$releaseVTag" "$prodBranch"
    # io_trace "prod_commit_release 2 -- $(print_vars releasePrerelPrefix releaseVTag prodBranch)"
  fi
}
_prod_commit_release_core()
{
  # io_trace "_prod_commit_release_core ${*@Q}"
  local updater=$1 vresources=()
  # update technical version - modify resources files
  if [[ -n $updater ]]; then
    # IFS=$'\n' vresources=( $($updater $releaseVTag) ); IFS=$OIFS
    vresources=( $($updater $releaseVTag) )
  fi
  # io_trace "_prod_commit_release_core -- $(print_vars updater vresources[@])"
  # commit resources and clean submodules in dev branch
  version_commit_files "$releaseVTag" "${vresources[@]}" ${unstagedCleanSubmodules[@]}
  # branch_merge "$prodBranch" "$moduleDevBranchPath" &>/dev/null
}
_prod_refresh_bundle_htag()
{
  # io_trace "_prod_refresh_bundle_htag 1 -- $(print_vars principalModuleId prodHTag noIncrement)"
  [[ -n $principalModuleId ]] && module_is_bundle  || return 0

  local pinfo pstatus ptag pver hver \
        principalScopes=( prod_scope )

  pinfo=$(module_visit "$principalModuleId" "${principalScopes[@]}" _prod_get_principal_module_release_info)
  pstatus=${pinfo%;*}
  ptag=${pinfo#*;}
  [ -z $ptag ] && return 0

  pver=${ptag##*/}
  hver=${prodHTag##*/}
  # io_trace "_prod_refresh_bundle_htag 1 -- $(print_vars principalModuleId ptag pstatus prodHTag pinfo pstatus ptag hver pver)"
  if [[ $pstatus == 'released' && $hver == $pver ]]; then
    mio_message "Bundle ${VC}$bundleId${LightPurple} and module ${VC}$principalModuleId${LightPurple} have same version" ${LightPurple}
  else
    noIncrement=true
  fi
  hver=$(vtag_highest_of $pver $hver)
  # restore folder
  [[ $prodHTag =~ ^.*/ ]]
  prodHTag=${BASH_REMATCH[0]}$hver
  # io_trace "_prod_refresh_bundle_htag 2 -- $(print_vars principalModuleId ptag pstatus prodHTag noIncrement)"
}
# run in principal module context
_prod_get_principal_module_release_info()
{
  # io_trace "_prod_get_principal_module_release_info 1 -- $(print_vars releaseStatus prodVTag prodHTag releaseVTag)"
  # [[ $dryRun == true && -n $principalReleaseStatus ]] && releaseStatus=$principalReleaseStatus
  # io_trace "_prod_get_principal_module_release_info 2 -- $(print_vars lbranch vbranch vtag htag delta status nextHead releaseStatus)"
  local prerelPrefix noIncrement
  _prod_increment_release_version
  # io_trace "_prod_get_principal_module_release_info 2 -- $(print_vars releaseStatus prodVTag prodHTag releaseVTag)"
  echo "$releaseStatus;$releaseVTag"
}

# Compute next version
#
# usage:
#  local prerelPrefix='reuse' vnext
#  branch_set_vnext $noIncrement
# in:
#  prerelPrefix=$1  -- prerelease prefix (alpha, beta, rc, rtm, reuse)
#  $1:noIncrement   -- do not increment 
# out:
#  prerelPrefix=     -- prerelease prefix (alpha, beta, rc, rtm, reuse)
_prod_increment_release_version()
{
  if [[ $releaseStatus == 'released' ]]; then
    releaseVTag=$prodHTag
  else
    local prerelPrefix=$1 noIncrement=$2 vnext
    releasePrerelPrefix=$prerelPrefix
    if [[ $prerelPrefix == 'reuse' ]]; then
      # reuse previous vtag if it's not a vnode
      if vtag_is_vnode $prodVTag; then
        releasePrerelPrefix=''
        _prod_increment_release_version_core || return 1
      else
        releaseVTag=$prodVTag
      fi
    else
      _prod_increment_release_version_core || return 1
    fi
  fi
}
# out:
#  vnext
_prod_increment_release_version_core()
{
  local vnext
  if [[ $noIncrement == true ]]; then
    if vtag_is_vnode $prodHTag; then
      vtag_set_increment "$prodHTag" "$releasePrerelPrefix" || return 1
      releaseVTag=$vnext
    else
      releaseVTag=$prodHTag
    fi
  else
    vtag_set_increment "$prodHTag" "$releasePrerelPrefix" || return 1
    releaseVTag=$vnext
  fi
}

########################################################
# EVENTS

_prod_on_head_changed()
{
   prod_reset_scope "$@"
}
_prod_on_head_name_changed()
{
  prod_reset_scope "$@"
}
_prod_on_branch_created()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && prod_reset_scope "$@"
}
_prod_on_branch_deleted()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && prod_reset_scope "$@"
}
