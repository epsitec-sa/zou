#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_PROD ]] && . zoul-git-prod
ZOUL_GIT_PROD=true

[[ -z $ZOUL_GIT_REF ]]            && . zoul-git-ref
[[ -z $ZOUL_GIT_VBRANCH ]]        && . zoul-git-vbranch
[[ -z $ZOUL_GIT_BRANCH_SELECT ]]  && . zoul-git-branch-select
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]   && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_CONFIG_VERSION ]] && . zoul-git-config-version

# io_trace "headChangedEvent+=( prod_reset_scope )"
headChangedEvent+=( _prod_on_head_changed )
branchCreatedEvent+=( _prod_on_branch_created )
branchDeletedEvent+=( _prod_on_branch_deleted )

# usage:
#   module_run prod_scope $*
prod_scope()
{
  # setup prod context
  local prodScopeInitialized=true prodHeadChangedDisabled \
        prodBranch prodBranchPath \
        prodVTag prodHTag prodAlias devAlias moduleAlias \
        vtagStatus vtag2dev vtag2prod \
        publishVTag publishPrerelPrefix publishStatus \
  
  prod_reset_scope

  # execute next russian doll
  # io_trace "prod_scope >> $*"
  $1 "${@:2}"
  # io_trace "prod_scope << $*"
}
prod_reset_scope()
{
  _prod_init_scope "$moduleDevBranchPath" "$moduleDevBranch"
}


########################################################
# SCOPE INITIALIZATION

_prod_init_scope()
{
  # avoid prematured event processing
  [[ $prodScopeInitialized == true ]] || return 0
  
  local devBranchPath=$1 devBranch=$2 \
        vbranch vtag htag delta alias status \
        branch lbranch bref

  # 1. Retrieve vtag and vbranch info starting from dev branch
  vtag_set_describe "$devBranchPath" "$devBranch" 'auto' # -> vbranch vtag delta alias
  if [[ -z $vtag ]]; then
    # reset scope variables
    prodBranch=''; prodBranchPath=''; prodVTag=''; prodHTag=''
    prodAlias='<>'; devAlias='<>'; vtagStatus='vtagMissing'; vtag2dev=''; vtag2prod=''
    publishVTag=''; publishPrerelPrefix=''; publishStatus='unpublishable'
    return 0
  fi
  local branch lbranch bref
  branch_set_realize "$vbranch"
  prodBranchPath=$branch
  prodBranch=$lbranch
  prodVTag=$vtag
  devAlias=$alias
  vtag2dev=$delta
  vtagStatus=$status

  # 2. Retrieve vtag and vbranch info starting from prod branch
  _prod_set_vtag_info "$prodBranchPath" "$prodBranch"
  if [[ $vbranch != $prodBranch ]]; then
    mio_error "Branches ${VC}$prodBranch${LightPurple} and ${VC}$vbranch${LightPurple} are intermixed" ${LightPurple}
    return 1
  fi

  prodVTag=$vtag
  prodHTag=$htag
  prodAlias=$alias
  vtag2prod=$delta
  vtagStatus=$status

  module_in_dev_mode && moduleAlias=$devAlias || moduleAlias=$prodAlias

  _prod_init_publish_status "$delta" "$status"

  # io_lock_enter
  # io_trace_unsafe "_prod_init_scope -- $(print_vars prodBranch prodBranchPath)"
  # io_trace_unsafe "_prod_init_scope -- $(print_vars vtagStatus prodVTag prodHTag)"
  # io_trace_unsafe "_prod_init_scope -- $(print_vars vtag2dev vtag2prod prodAlias)"
  # io_trace_unsafe "_prod_init_scope -- $(print_vars publishStatus publishVTag publishPrerelPrefix)"
  # io_lock_exit
}
# usage:
#   local vbranch vtag htag delta alias status
#   _prod_set_vtag_info $branch $lbranch $skipVNodes $allowDuplicateTags
# in:
#   $1:branch             -- local or remote branch name
#   $2:lbranch            -- local branch name
# out:
#   vbranch   -- associated version branch
#   vtag      -- nearest vtag (depends on skipVNodes value)
#   htag      -- highest vtag on vbranch (depends on allowDuplicateTags value)
#   delta     -- number of commits between branch and vtag (can be negative if branch is behind vtag)
#   alias     -- condensed vtag info - (> v1.0.0 (8)) means branch is ahead of v1.0.0 by 8 commits
#   status    -- vnode       -- nearest vtag is a vnode (branch was never published on this vbranch)
#                vtag        -- nearest vtag is a vtag
#                vtagMissing -- no vtag found (branch was never published)
_prod_set_vtag_info()
{
  local branch=$1 lbranch=${2:-$1}
  vtag_set_describe "$branch" "$lbranch" 'auto' # -> vbranch vtag delta alias
  # allow duplicate tags in bundle
  htag=$(vtag_highest $vbranch true)
  # io_trace "_prod_set_vtag_info 1 -- $(print_vars branch vbranch vtag htag delta alias)"
  if [[ $htag != $vtag ]]; then
    vtag=$htag
    delta=$(( $(git rev-list --count $vtag..$vbranch) ))
    vtag_format_alias "$vtag" "$delta"
    # io_trace "_prod_set_vtag_info 2 -- $(print_vars branch vbranch vtag htag delta alias)"
  fi
  # [ $delta -ne 0 ] && alias="$lbranch $alias" # (master > v2.0.0 (8))
  # disallow duplicate tags in bundle
  if ! module_is_bundle; then
    htag=$(vtag_highest $vbranch false)
  fi
  # vnode or vtag
  vtag_is_vnode $vtag && status='vnode' || status='vtag'
  # io_trace "_prod_set_vtag_info 3 -- $(print_vars htag status alias)"
}
# in:
#   delta=$1
#   status=$2
# out:
#   publishStatus -- error
#                    unpublishable
#                    published
#                    notPublished
#                    ffPublish
_prod_init_publish_status()
{
  local delta=$1 status=$2
  # io_trace "_prod_init_publish_status -- $(print_vars delta status)"
  publishStatus='error'
  if [[ $status == 'vtagMissing' ]]; then
    publishStatus='unpublishable'
  elif [[ $status == 'vtag' ]]; then
    # published at least once on this vbranch
    if [ $delta -eq 0 ]; then
      # head has not been moved since last publish
      publishStatus='published'
    elif [ $delta -gt 0 ]; then
      publishStatus='notPublished'
    else
      # prod branch is behind vtag
      publishStatus='ffPublish'
    fi
  elif [[ $status == 'vnode' ]]; then
    # never published on this vbranch
    publishStatus='notPublished'
  else
    mio_error "_prod_init_publish_status: status '$status' not implemented"
    return 1
  fi
  # io_trace "_prod_init_publish_status -> $(print_vars publishStatus)"
}

########################################################
# CHECKOUT

sku_checkout()
{
  local sku=$1 vnext=$2 forceCheckout=$3 branch lbranch ec=0
  branch_set_best_match_dev "$sku"                 # -> branch lbranch
  _prod_init_scope $branch $lbranch

  local prodHeadChangedDisabled=true
  prod_checkout "$vnext" "$forceCheckout" "$lbranch" || ec=$?
  prodHeadChangedDisabled=''
  return $ec
}
prod_checkout()
{
  local vnext=$1 forceCheckout=$2 devBranch=$3
  # io_trace "prod_checkout -- $(print_vars vnext forceCheckout devBranch vtagStatus prodBranch prodVTag)"
  if [[ $vtagStatus == 'vtag' ]]; then
    if [[ $vnext == true ]]; then
      branch_checkout "$prodBranch" "$forceCheckout"
    else
      branch_checkout "$prodVTag" "$forceCheckout"
    fi
  else
    dev_checkout "$forceCheckout" "$devBranch"
  fi
}
dev_checkout()
{
  # io_trace "dev_checkout -- ${*@Q}"
  local forceCheckout=$1 devBranch=$2
  if [[ -z $devBranch ]]; then
    local branch lbranch
    branch_set_best_match_dev "$bundleDevBranch" # -> branch lbranch
    devBranch=$lbranch
    # io_trace "dev_checkout 1 -- $(print_vars bundleDevBranch branch lbranch devBranch)"
  fi
  devBranch=$(wip_to_ref $devBranch)
  # io_trace "dev_checkout 2 -- $(print_vars bundleDevBranch branch lbranch devBranch)"
  branch_checkout "$devBranch" "$forceCheckout"
}

########################################################
# BRANCH CREATION

prod_ensure_vbranch()
{
  [[ -n $prodBranch ]] && return 0
  local version=${1:-0.1} branch lbranch bref
  branch_set_realize $(wip_to_ref $moduleDevBranch)

  [[ $lbranch =~ (.*/)?(.+)$ ]] || return 1
  vbranch_create "${BASH_REMATCH[1]}$version" "$branch"
}

########################################################
# PUBLISH

publish_init_next_version()
{
  local prerelPrefix=$1 noIncrement
  # get principal module version
  _publish_refresh_bundle_htag # update prodHTag and noIncrement
  _publish_increment_version "$prerelPrefix" "$noIncrement" # -> publishVTag publishPrerelPrefix

  # io_lock_enter
  # io_trace_unsafe "publish_init_next_version -- $(print_vars publishStatus publishPrerelPrefix)"
  # io_trace_unsafe "publish_init_next_version -- $(print_vars prodVTag prodHTag publishVTag)"
  # io_lock_exit
}
publish_commit()
{
  if [[ $publishPrerelPrefix == 'reuse' ]]; then
    _publish_commit_core
    tag_move "$publishVTag" "$prodBranch"
    # io_trace "publish_commit 1 -- $(print_vars publishPrerelPrefix publishVTag prodBranch)"
  else
    # update technical version
    _publish_commit_core 'version_update'
    local comment="publish branch '$prodBranch' as '$publishVTag'"
    git tag -a -m "zou-flow: $comment" "$publishVTag" "$prodBranch"
    # io_trace "publish_commit 2 -- $(print_vars publishPrerelPrefix publishVTag prodBranch)"
  fi
}
_publish_commit_core()
{
  # io_trace "_publish_commit_core ${*@Q}"
  local updater=$1 vresources=()
  # update technical version - modify resources files
  if [[ -n $updater ]]; then
    # IFS=$'\n' vresources=( $($updater $publishVTag) ); IFS=$OIFS
    vresources=( $($updater $publishVTag) )
  fi
  # io_trace "_publish_commit_core -- $(print_vars updater vresources[@])"
  # commit resources and clean submodules in dev branch
  version_commit_files "$publishVTag" "${vresources[@]}" ${unstagedCleanSubmodules[@]}
  # branch_merge "$prodBranch" "$moduleDevBranchPath" &>/dev/null
}

_publish_refresh_bundle_htag()
{
  # io_trace "_publish_refresh_bundle_htag 1 -- $(print_vars principalModuleId prodHTag noIncrement)"
  [[ -n $principalModuleId ]] && module_is_bundle  || return 0

  local pinfo pstatus ptag pver hver \
        principalScopes=( prod_scope )

  pinfo=$(module_visit "$principalModuleId" "${principalScopes[@]}" _publish_principal_info)
  pstatus=${pinfo%;*}
  ptag=${pinfo#*;}
  [ -z $ptag ] && return 0

  pver=${ptag##*/}
  hver=${prodHTag##*/}
  # io_trace "_publish_refresh_bundle_htag 1 -- $(print_vars principalModuleId ptag pstatus prodHTag pinfo pstatus ptag hver pver)"
  if [[ $pstatus == 'published' && $hver == $pver ]]; then
    mio_message "Bundle ${VC}$bundleId${LightPurple} and module ${VC}$principalModuleId${LightPurple} have same version" ${LightPurple}
  else
    noIncrement=true
  fi
  hver=$(vtag_highest_of $pver $hver)
  # restore folder
  [[ $prodHTag =~ ^.*/ ]]
  prodHTag=${BASH_REMATCH[0]}$hver
  # io_trace "_publish_refresh_bundle_htag 2 -- $(print_vars principalModuleId ptag pstatus prodHTag noIncrement)"
}
# run in principal module context
_publish_principal_info()
{
  # io_trace "_publish_principal_info 1 -- $(print_vars publishStatus prodVTag prodHTag publishVTag)"
  # [[ $dryRun == true && -n $principalPublishStatus ]] && publishStatus=$principalPublishStatus
  # io_trace "_publish_principal_info 2 -- $(print_vars lbranch vbranch vtag htag delta status nextHead publishStatus)"
  local prerelPrefix noIncrement
  _publish_increment_version
  # io_trace "_publish_principal_info 2 -- $(print_vars publishStatus prodVTag prodHTag publishVTag)"
  echo "$publishStatus;$publishVTag"
}

# Compute next version
#
# usage:
#  local prerelPrefix='reuse' vnext
#  branch_set_vnext $noIncrement
# in:
#  prerelPrefix=$1  -- prerelease prefix (alpha, beta, rc, rtm, reuse)
#  $1:noIncrement   -- do not increment 
# out:
#  prerelPrefix=     -- prerelease prefix (alpha, beta, rc, rtm, reuse)
_publish_increment_version()
{
  if [[ $publishStatus == 'published' ]]; then
    publishVTag=$prodHTag
  else
    local prerelPrefix=$1 noIncrement=$2 vnext
    publishPrerelPrefix=$prerelPrefix
    if [[ $prerelPrefix == 'reuse' ]]; then
      # reuse previous vtag if it's not a vnode
      if vtag_is_vnode $prodVTag; then
        publishPrerelPrefix=''
        _publish_increment_version_core || return 1
      else
        publishVTag=$prodVTag
      fi
    else
      _publish_increment_version_core || return 1
    fi
  fi
}
# out:
#  vnext
_publish_increment_version_core()
{
  local vnext
  if [[ $noIncrement == true ]]; then
    if vtag_is_vnode $prodHTag; then
      vtag_set_increment "$prodHTag" "$publishPrerelPrefix" || return 1
      publishVTag=$vnext
    else
      publishVTag=$prodHTag
    fi
  else
    vtag_set_increment "$prodHTag" "$publishPrerelPrefix" || return 1
    publishVTag=$vnext
  fi
}

########################################################
# EVENTS

_prod_on_head_changed()
{
  [[ $prodHeadChangedDisabled == true ]] || prod_reset_scope
}
_prod_on_branch_created()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && prod_reset_scope
}
_prod_on_branch_deleted()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && prod_reset_scope
}
