#!/bin/bash

[[ -z $ZOUL_LOCK ]]              && . zoul-lock
[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_VTABLE ]]        && . zoul-git-vtable
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge

prod_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    -n|--dry-run)   dryRun=true;;
    --merge)        mergeIntoDev=true;;
    --vnext)        checkoutType='vnext';;
    --vlast)        checkoutType='vlast';;
    --vtable)       vtable=true;;
    --reuse)        prerelPrefix='reuse';;
    --alpha)        prerelPrefix='alpha';;
    --beta)         prerelPrefix='beta';;
    --rc)           prerelPrefix='rc';;
    --rtm)          prerelPrefix='rtm';;
    enter|release)  subcommand=$1;;
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'release'
  cmd_check_args "${args[@]}"
  
  prodModulePaths=( "$@" )
  # io_trace "prod_parse -- $(print_vars recursive checkoutType subcommand prodModulePaths[@])"
}
prod_run()
{
  # parse command line
  local jobsCount recursive command='prod' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        commitSubmodules=true mergeIntoDev \
        vtable prerelPrefix dryRun prodModulePaths=() \
        checkoutType='vnext'

  prod_parse "$@" || return $?
  prod_startup_message

  bundle_scope prod_command
}
prod_startup_message()
{
  case $subcommand in
    enter)
      startupMessage="Entering production, please wait...";;
    release)
      local what='next version' color=${White}
      [[ $dryRun == true ]] && color=${DarkGray}
      [[ $checkoutType == 'vlast' ]] && what='last version'
      startupMessage="${color}Releasing ${Brown}$what${color}, please wait...";;
  esac
}
prod_command()
{
  [ ${#prodModulePaths[@]} -eq 0 ] && prodModulePaths+=( './' )
  
  case $subcommand in
    release) recursive=true;;
  esac
  cmd_register_module_paths "$recursive" "${prodModulePaths[@]}"

  cmd_visit_modules
}

###############
# ENTER COMMAND
###############

prod_enter_prolog() { prod_checkout "$checkoutType" true || io_trace_error 'prod_enter_prolog'; }
prod_enter_epilog() { branch_show_status || io_trace_error 'prod_enter_epilog'; }

#################
# RELEASE COMMAND
#################

prod_release_root_scope()
{
  # avoid reentrency
  if [[ $prodReleaseRootScopeInitialized != true ]]; then

    # io_trace "prod_release_root_scope ${*@Q}"
    local prodReleaseRootScopeInitialized=true forcePrincipalRelease

    # version table scope
    local vtableCreate vtableGate vtableLookupPath vtableRoot
    _vtable_init || return $?

    # dry run scope
    local rstatusParentGate rstatusLookupPath rstatusParentLookupPath principalReleaseStatus

  fi

  # execute next russian doll
  $1 "${@:2}"
}

################
# Release prolog
################

prod_release_scope()
{
  # io_trace "prod_release_scope -- $(print_vars prodBranch)"
  local moduleMergeIntoDev=$mergeIntoDev modulePrerelPrefix=$prerelPrefix \
        hasBeenReleased moduleVLast

  # always merge into dev in bundle
  module_is_bundle && moduleMergeIntoDev=true

  if module_is_principal; then
    # vlast does not apply to principal module if force release is specified
    [[ $checkoutType == 'vlast' && $forcePrincipalRelease != true ]] && cmd_is_child && moduleVLast=true
    # prerelease always applies to principal module

    # io_trace "prod_release_scope PRINCIPAL -- $(print_vars forcePrincipalRelease moduleMergeIntoDev modulePrerelPrefix releasePrerelPrefix)"
  elif cmd_is_child; then
    # vlast applies to child modules
    [[ $checkoutType == 'vlast' ]] && moduleVLast=true
    # prerelease does not apply to child modules (excepting principal module)
    [[ $prerelPrefix != 'rtm' ]] && modulePrerelPrefix=''
    # io_trace "prod_release_scope CHILD -- $(print_vars forcePrincipalRelease moduleMergeIntoDev modulePrerelPrefix releasePrerelPrefix)"
  fi

  # execute next russian doll
  $1 "${@:2}"
}
prod_release_prolog()
{
  # io_trace "prod_release_prolog -- $(print_vars prodBranch)"
  case "$releaseStatus" in
    error|unreleasable)
      mio_error "Branch ${VC}$moduleDevBranch${Red} cannot be released."
      mio_info "  use ${VC}git dev release${Cyan} to release some development code."
      return 1;;
  esac
  if [[ $dryRun == true ]]; then
    _rstatus_init || io_trace_error 'prod_release_prolog 1'
  elif [[ $moduleVLast == true ]]; then
    prod_checkout 'vlast' true "$moduleDevBranch" true || io_trace_error 'prod_release_prolog 2'
  else
    prod_checkout 'vnext'  true "$moduleDevBranch" true || io_trace_error 'prod_release_prolog 3'
  fi
}

################
# Release epilog
################

prod_release_epilog()
{
  # io_trace "prod_release_epilog -- $(print_vars prodBranch)"
  _prod_fix_release_status
  _prod_release || io_trace_error 'prod_release_epilog 1' || return $?
  _vtable_update || io_trace_error 'prod_release_epilog 2'
}
prod_release_xepilog()
{
  _vtable_update
}

#################
# Release helpers
#################

_prod_fix_release_status()
{
  prod_fix_release_status "$modulePrerelPrefix" "$forcePrincipalRelease" "$moduleVLast"
  [[ $dryRun == true ]] && _rstatus_update
}
_prod_release()
{
  # io_trace "_prod_release 1 -- $(print_vars modulePrerelPrefix releaseStatus)"
  case $releaseStatus in
    unreleased) _prod_release_unreleased;;
    ffRelease)  _prod_release_ff;;
    released)   _prod_release_released;;
    *)          _prod_release_unimplemented;;
  esac
  # io_trace "_prod_release 2 -- $(print_vars modulePrerelPrefix releaseStatus hasBeenReleased)"
}
_prod_release_ff()
{
  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be forwarded to ${VC}$prodVTag${Green}"
  else
    branch_merge "$prodVTag" "$prodBranchPath" \
    && { branch_raise_head_changed_event "$prodBranch"; hasBeenReleased=true; } \
    || { mio_error "Merge of branch ${VC}$prodBranch${Red} failed"; return 1; }
  fi
}
_prod_release_unreleased()
{
  # head will change
  prod_increment_release_version "$modulePrerelPrefix"
  [ $? -eq 127 ] && _prod_force_release_of_principal_module 

  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be released at ${VC}$releaseVTag" "$alias"
  else
    prod_commit_release \
    && branch_raise_head_changed_event "$prodBranch" \
    && { mio_success "Released branch ${VC}$prodBranch${Green} at ${VC}$releaseVTag"; hasBeenReleased=true; } \
    || { mio_error "Release of branch '$prodBranch' failed"; return 1; }
  fi
}
_prod_release_released()
{
  if [[ $dryRun != true && $vtableCreate == true ]]; then
    [[ $moduleRoot == $vtableRoot ]] && vtableCreate=false
  fi
  mio_message "Already released" ${LightBlue}
}
_prod_release_unimplemented()
{
  mio_error "Fatal: releaseStatus '$releaseStatus' not implemented"
  exit 1
}
_prod_force_release_of_principal_module()
{
  [[ $releaseStatus == 'released' ]] && return 0 
  mio_message "Bundle ${VC}$bundleId${LightPurple} and module ${VC}$principalModuleId${LightPurple} have same version" ${LightPurple}
  local forcePrincipalRelease=true
  cmd_visit_module "$principalModuleId"
  cosm_reset_scope
}
_prod_merge_into_dev()
{
  local toMerge=$1 toMergeAlias=${2:-$1} devBranch=$(wip_to_ref "$moduleDevBranch")
  if [[ $devBranch == $moduleDevBranch ]]; then
    _prod_merge_into_dev_core "$toMerge" "$moduleDevBranchPath" "$toMergeAlias"
  else
    local branch lbranch bref
    branch_set_realize "$devBranch"
    _prod_merge_into_dev_core "$toMerge" "$branch" "$toMergeAlias"
  fi
}
_prod_merge_into_dev_core()
{
  # io_trace "_prod_merge_into_dev_core -- $(print_vars hasBeenReleased moduleVLast)"
  [[ $hasBeenReleased == true ]] || return 0

  local toMerge=$1 mergeInto=$2 toMergeAlias=${3:-$1}
  # io_trace "_prod_merge_into_dev_core -- $(print_vars toMerge mergeInto toMergeAlias moduleMergeIntoDev)"

  if _prod_can_merge_into_dev "$toMerge" "$mergeInto"; then
    branch_merge "$toMerge" "$mergeInto" "$toMergeAlias" '-Xtheirs'
  elif [[ $moduleMergeIntoDev == true ]]; then
    # if merge option is specified, we need to resolve conflicts manually
    branch_merge "$toMerge" "$mergeInto" "$toMergeAlias"
  else
    branch_merge_ff "$toMerge" "$mergeInto" "$toMergeAlias" || true
  fi
}
_prod_can_merge_into_dev()
{
  local toMerge=$1 mergeInto=$2 mergeBase comment IFS=$'\n'
  mergeBase=$(git merge-base "$toMerge" "$mergeInto")
  for comment in $(git log --format=%B "$mergeBase..$toMerge"); do
    # io_trace "_prod_can_merge_into_dev -- $(print_vars mergeBase comment)"
    [[ $comment =~ ^zou-flow: ]] || return 1
  done
}

###############
# Version table
###############

_vtable_init()
{
  # [[ $dryRun == true ]] && return 0
  if [[ $vtable == true ]]; then
    vtableCreate=true
  elif cmd_is_single_root "$bundleRoot"; then
    vtableCreate=true
  fi
  if [[ $vtableCreate == true ]]; then
    vtableRoot=$(cmd_single_root)
    if [ $? -ne 0 ]; then
      mio_error "Version table cannot be created when distinct modules are specified (${VC}$(cmd_registered_paths)${Red})"
      return 1
    fi

    vtableGate=$(lock_init)
    vtableLookupPath="$(mktemp)"
    vtable_init "$vtableRoot" "$vtableLookupPath"
  fi
}
_vtable_update()
{
  # io_trace "_vtable_update -- $(print_vars vtable vtableCreate configSelectIsExcluded vtableRoot PWD)"
  if [[ "$PWD" == "$vtableRoot" ]]; then
    _vtable_commit
  else
    _vtable_update_core
  fi
}
_vtable_update_core()
{
  [[ $vtableCreate == true ]] && vtable_update "$vtableRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
  [[ $configSelectIsExcluded == true || $dryRun == true ]] && return 0
  _prod_merge_into_dev_core "$prodBranch" "$moduleDevBranchPath" || io_trace_error "_vtable_update_core merge"
}
_vtable_commit()
{
  if [[ $dryRun == true ]]; then
    [[ $vtableCreate == true ]] || return 0
    vtable_update "$vtableRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
    mio_message "Created version table for ${VC}$prodBranch${DarkGray} at ${VC}$releaseVTag" ${DarkGray}
  elif [[ $vtableCreate == true ]]; then
    # io_trace "_vtable_commit -- $(print_vars releaseStatus prodBranch moduleDevBranch checkoutType)"
    local tmpBranch="_zou_$(date +%y%V)"
    git checkout -b "$tmpBranch" &>/dev/null
    vtable_update "$vtableRoot" "$moduleId" "$vtableLookupPath" "$vtableGate" true
    mio_message "Created version table for ${VC}$prodBranch${Green} at ${VC}$releaseVTag" ${Green}
    _prod_merge_into_dev "$tmpBranch" "$prodBranch"
    git checkout "$prodBranch" &>/dev/null
    git branch -D "$tmpBranch" &>/dev/null
  else
    _prod_merge_into_dev "$prodBranch"
  fi
}

################################
# Release status in dry run mode
################################

_rstatus_init()
{
  rstatusParentGate=$(lock_init)
  rstatusParentLookupPath=$rstatusLookupPath
  rstatusLookupPath=''
  # io_trace "_rstatus_init 1 -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  if config_has_submodules; then
    rstatusLookupPath="$(mktemp)"
    trap "rm \"$rstatusLookupPath\"" EXIT
    _rstatus_init_core "$rstatusLookupPath"
    # io_trace "_rstatus_init 2 -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  fi
}
_rstatus_update()
{
  # io_trace "_rstatus_update -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  if [[ -n $rstatusLookupPath ]]; then
    _rstatus_commit_core "$rstatusLookupPath"
  fi
  if [[ -n $rstatusParentLookupPath ]]; then
    _rstatus_update_core "$rstatusParentLookupPath" "$rstatusParentGate" "$moduleId" "$releaseStatus"
  fi
  # io_trace "_rstatus_update -- $(print_vars moduleId releaseStatus)"
}
_rstatus_init_core()
{
  local lookupPath=$1
  
  declare -A lookup                 # create lookup
  declare -p lookup >"$lookupPath"  # serialize lookup
  # io_trace "_rstatus_init_core -- $(print_vars lookupPath)"
}
_rstatus_update_core()
{
  local lookupPath=$1 gate=$2 moduleId=$3 releaseStatus=$4
  
  lock_enter "$gate"
  . "$lookupPath"                     # deserialize lookup
  lookup[$moduleId]="$releaseStatus"  # save publish status
  declare -p lookup >"$lookupPath"    # serialize lookup
  lock_exit "$gate"
  # io_trace "_rstatus_update_core -- $(print_vars lookupPath releaseStatus)"
}
# 
# out:
#   releaseStatus
#   principalReleaseStatus
_rstatus_commit_core()
{
  local lookupPath=$1 mid status
  . "$lookupPath"
  for mid in ${!lookup[@]}; do
    status=${lookup[$mid]}
    [[ $status == 'unreleased' ]] && releaseStatus=$status
    [[ $mid == $principalModuleId ]] && principalReleaseStatus=$status
  done
  return 0
}

prod_run  "$@"
