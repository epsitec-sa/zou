#!/bin/bash

[[ -z $ZOUL_LOCK ]]              && . zoul-lock
[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_VTABLE ]]        && . zoul-git-vtable
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

prod_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    --vnext)        vnext=true;;
    -t|--vtable)    vtable=true;;
    -n|--dry-run)   dryRun=true;;
    -u|--reuse)     prerelPrefix='reuse';;
    --alpha)        prerelPrefix='alpha';;
    --beta)         prerelPrefix='beta';;
    --rc)           prerelPrefix='rc';;
    --rtm)          prerelPrefix='rtm';;
    enter|release)  subcommand=$1;;
    publish)        subcommand='release';;  # alias
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'release'
  cmd_check_args "${args[@]}"
  
  prodModulePaths=( "$@" )
  # io_trace "prod_parse -- $(print_vars recursive vnext subcommand prodModulePaths[@])"
}
prod_run()
{
  # parse command line
  local jobsCount recursive command='prod' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        commitSubmodules=true \
        vnext vtable prerelPrefix dryRun prodModulePaths=()

  prod_parse "$@" || return $?
  
  case $subcommand in
    enter)
      startupMessage="Entering production mode, please wait...";;
    release)
      startupMessage="Releasing production branches, please wait..."
      [[ $dryRun == true ]] && startupMessage="${DarkGray}$startupMessage"
      recursive=true;;
  esac

  module_run "${cmdScopes[@]}" prod_command
}
prod_command()
{
  [ ${#prodModulePaths[@]} -eq 0 ] && prodModulePaths+=( './' )
  cmd_register_module_paths "$recursive" "${prodModulePaths[@]}"
  prod_${subcommand}_run
}

###############
# ENTER COMMAND
###############

prod_enter_run()    { cmd_visit_modules; }
prod_enter_epilog() { prod_checkout "$vnext" true; }

#################
# RELEASE COMMAND
#################

prod_release_run()
{
  # version table
  local vtableCreate vtableGate vtableLookupPath
  _vtable_init
  # dry run
  local rstatusParentGate rstatusLookupPath rstatusParentLookupPath principalPublishStatus

  cmd_visit_modules
}

################
# Release prolog
################

prod_release_prolog()
{
  # io_trace "prod_release_prolog -- $(print_vars prodBranch)"
  case "$publishStatus" in
    error|unpublishable)
      mio_error "Branch ${VC}$moduleDevBranch${Red} cannot be released."
      mio_info "  use ${VC}git dev finish${Cyan} to release some development code."
      return 1;;
  esac
  
  if [[ $dryRun == true ]]; then
    _rstatus_init
  else
    branch_checkout "$prodBranch"
  fi
}

################
# Release epilog
################

prod_release_epilog()
{
  _prod_fix_release_status
  _prod_release || return $?
  _vtable_update
}
prod_release_xepilog()
{
  _vtable_update
}

#################
# Release helpers
#################

_prod_fix_release_status()
{
  [[ $dryRun == true ]] && _rstatus_update
  prod_fix_release_status "$prerelPrefix"
}
_prod_release()
{
  # io_trace "_prod_release 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
  case $publishStatus in
    published)    _prod_release_already_released;;
    ffPublish)    _prod_release_ff;;
    notPublished) _prod_release_not_released;;
    *)            _prod_release_not_implemented;;
  esac
  # io_trace "_prod_release 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
}
_prod_release_already_released()
{
  # head will not change
  mio_message "Already published" ${LightBlue}
}
_prod_release_ff()
{
  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be forwarded to ${VC}$prodVTag${Green}"
  else
    branch_merge "$prodVTag" "$prodBranchPath" \
    && branch_raise_head_changed_event "$prodBranch" \
    || { mio_error "Merge of branch ${VC}$prodBranch${Red} failed"; return 1; }
  fi
}
_prod_release_not_released()
{
  # head will change
  publish_init_next_version "$prerelPrefix"

  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be released at ${VC}$publishVTag" "$alias"
  else
    publish_commit \
    && branch_raise_head_changed_event "$prodBranch" \
    && mio_success "Released branch ${VC}$prodBranch${Green} at ${VC}$publishVTag" \
    || { mio_error "Release of branch '$prodBranch' failed"; return 1; }
  fi
}
_prod_release_not_implemented()
{
  mio_error "Fatal: publishStatus '$publishStatus' not implemented"
  exit 1
}

###############
# Version table
###############

_vtable_init()
{
  # [[ $dryRun == true ]] && return 0
  if [[ $vtable == true ]]; then
    vtableCreate=true
  elif [[ $startupRoot == $bundleRoot ]] && module_has_submodules; then
    vtableCreate=true
  fi
  if [[ $vtableCreate == true ]]; then
    vtableGate=$(lock_init)
    vtableLookupPath="$(mktemp)"
    vtable_init "$startupRoot" "$vtableLookupPath"
  fi
}
_vtable_update()
{
  # io_trace "_vtable_update -- $(print_vars vtable vtableCreate configSelectIsExcluded)"
  if [[ "$PWD" == "$startupRoot" ]]; then
    _vtable_commit
  else
    _vtable_update_core
  fi
}
_vtable_update_core()
{
  [[ $vtableCreate == true ]] && vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
  [[ $configSelectIsExcluded == true || $dryRun == true ]] && return 0
  branch_merge "$prodBranch" "$moduleDevBranchPath" '-Xours' || io_trace_error "_vtable_update_core merge"
}
_vtable_commit()
{
  if [[ $dryRun == true ]]; then
    [[ $vtableCreate == true ]] || return 0
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
    mio_message "Created version table for ${VC}$prodBranch${DarkGray} at ${VC}$publishVTag" ${DarkGray}
  elif [[ $vtableCreate == true ]]; then
    # io_trace "_vtable_commit -- $(print_vars lbranch vbranch vnext)"
    branch_is_merged "$prodBranch" "$moduleDevBranch" && return 0
    local tmpBranch="_zou_$(date +%y%V)"
    git checkout -b "$tmpBranch" &>/dev/null
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate" true
    mio_message "Created version table for ${VC}$prodBranch${Green} at ${VC}$publishVTag" ${Green}
    branch_merge "$tmpBranch" "$moduleDevBranchPath" "$prodBranch" '-Xours'
    git checkout "$prodBranch" &>/dev/null
    git branch -D "$tmpBranch" &>/dev/null
  else
    branch_merge "$prodBranch" "$moduleDevBranchPath" '-Xours'
  fi
}

################################
# Release status in dry run mode
################################

_rstatus_init()
{
  rstatusParentGate=$(lock_init)
  rstatusParentLookupPath=$rstatusLookupPath
  rstatusLookupPath=''
  # io_trace "_rstatus_init 1 -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  if config_has_submodules; then
    rstatusLookupPath="$(mktemp)"
    _rstatus_init_core "$rstatusLookupPath"
    # io_trace "_rstatus_init 2 -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  fi
}
_rstatus_update()
{
  # io_trace "_rstatus_update -- $(print_vars moduleId rstatusParentLookupPath rstatusLookupPath)"
  if [[ -n $rstatusLookupPath ]]; then
    _rstatus_commit_core "$rstatusLookupPath"
    rm "$rstatusLookupPath"
  fi
  if [[ -n $rstatusParentLookupPath ]]; then
    _rstatus_update_core "$rstatusParentLookupPath" "$rstatusParentGate" "$moduleId" "$publishStatus"
  fi
  # io_trace "_rstatus_update -- $(print_vars moduleId publishStatus)"
}
_rstatus_init_core()
{
  local lookupPath=$1
  
  declare -A lookup                 # create lookup
  declare -p lookup >"$lookupPath"  # serialize lookup
  # io_trace "_rstatus_init_core -- $(print_vars lookupPath)"
}
_rstatus_update_core()
{
  local lookupPath=$1 gate=$2 moduleId=$3 publishStatus=$4
  
  lock_enter "$gate"
  . "$lookupPath"                     # deserialize lookup
  lookup[$moduleId]="$publishStatus"  # save publish status
  declare -p lookup >"$lookupPath"    # serialize lookup
  lock_exit "$gate"
  # io_trace "_rstatus_update_core -- $(print_vars lookupPath publishStatus)"
}
# 
# out:
#   publishStatus
#   principalPublishStatus
_rstatus_commit_core()
{
  local lookupPath=$1 mid status
  . "$lookupPath"
  for mid in ${!lookup[@]}; do
    status=${lookup[$mid]}
    [[ $status == 'notPublished' ]] && publishStatus=$status
    [[ $mid == $principalModuleId ]] && principalPublishStatus=$status
  done
  return 0
}

prod_run  "$@"
