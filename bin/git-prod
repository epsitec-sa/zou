#!/bin/bash

[[ -z $ZOUL_LOCK ]]              && . zoul-lock
[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_VTABLE ]]        && . zoul-git-vtable
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

prod_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    --vnext)        vnext=true;;
    -t|--vtable)    vtable=true;;
    -n|--dry-run)   dryRun=true;;
    -u|--reuse)     prerelPrefix='reuse';;
    --alpha)        prerelPrefix='alpha';;
    --beta)         prerelPrefix='beta';;
    --rc)           prerelPrefix='rc';;
    --rtm)          prerelPrefix='rtm';;
    enter|release)  subcommand=$1;;
    publish)        subcommand='release';;  # alias
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'release'
  cmd_check_args "${args[@]}"
  
  prodModulePaths=( "$@" )
  # io_trace "prod_parse -- $(print_vars recursive vnext subcommand prodModulePaths[@])"
}
prod_run()
{
  # parse command line
  local jobsCount recursive command='prod' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        commitSubmodules=true \
        vnext vtable prerelPrefix dryRun prodModulePaths=()

  prod_parse "$@" || return $?
  
  case $subcommand in
    enter)
      startupMessage="Entering production mode, please wait...";;
    release)
      startupMessage="Releasing production branches, please wait..."
      [[ $dryRun == true ]] && startupMessage="${DarkGray}$startupMessage"
      recursive=true;;
  esac

  module_run "${cmdScopes[@]}" prod_command
}
prod_command()
{
  [ ${#prodModulePaths[@]} -eq 0 ] && prodModulePaths+=( './' )
  cmd_register_module_paths "$recursive" "${prodModulePaths[@]}"
  prod_${subcommand}_run
}

###############
# ENTER COMMAND
###############

prod_enter_run()    { cmd_visit_modules; }
prod_enter_epilog() { prod_checkout "$vnext" true; }

#################
# RELEASE COMMAND
#################

prod_release_run()
{
  # version table
  local vtableCreate vtableGate vtableLookupPath
  prod_release_set_vtable_info
  # dry run
  local pstatusParentGate pstatusLookupPath pstatusParentLookupPath principalPublishStatus

  cmd_visit_modules
}

################
# Release prolog
################

prod_release_prolog()
{
  # io_trace "prod_release_prolog -- $(print_vars prodBranch)"
  if [[ $publishStatus == 'unpublishable' ]]; then
    mio_error "Branch ${VC}$moduleDevBranch${Red} cannot be released."
    mio_info "  use ${VC}git dev finish${Cyan} to validate development code for release."
    return 1
  fi
  if [[ $dryRun == true ]]; then
    prod_release_init_pstatus
  else
    branch_checkout "$prodBranch"
  fi
}

################
# Release epilog
################

prod_release_epilog()
{
  prod_release_fix_status
  prod_release_publish || return $?
  prod_release_update_vtable
}
prod_release_xepilog()
{
  prod_release_update_vtable
}
prod_release_fix_status()
{
  [[ $dryRun == true ]] && prod_release_update_pstatus
  [[ $publishStatus == 'published' ]] && cosm_has_unstaged_submodules && publishStatus='notPublished'
}

#################
# Publish helpers
#################

prod_release_publish()
{
  # io_trace "prod_release_publish 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
  
  case $publishStatus in
    published)    prod_release_already_published;;
    ffPublish)    prod_release_ff_publish;;
    notPublished) prod_release_not_published;;
    *)            prod_release_not_implemented;;
  esac
  # io_trace "prod_release_publish 1 -- $(print_vars lbranch vbranch vtag htag prerelPrefix publishStatus)"
}
prod_release_already_published()
{
  # head will not change
  mio_message "Already published" ${LightBlue}
}
prod_release_ff_publish()
{
  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be forwarded to ${VC}$prodVTag${Green}"
  else
    branch_merge "$prodVTag" "$prodBranchPath" \
    && branch_raise_head_changed_event "$prodBranch" \
    || { mio_error "Merge of branch ${VC}$prodBranch${Red} failed"; return 1; }
  fi
}
prod_release_not_published()
{
  # head will change
  publish_init_next_version "$prerelPrefix"

  if [[ $dryRun == true ]]; then
    mio_success "Branch ${VC}$prodBranch${Green} will be released at ${VC}$publishVTag" "$alias"
  else
    publish_commit \
    && branch_raise_head_changed_event "$prodBranch" \
    && mio_success "Released branch ${VC}$prodBranch${Green} at ${VC}$publishVTag" \
    || { mio_error "Release of branch '$prodBranch' failed"; return 1; }
  fi
}
prod_release_not_implemented()
{
  mio_error "Fatal: publishStatus '$publishStatus' not implemented"
  exit 1
}

###############
# Version table
###############

prod_release_set_vtable_info()
{
  # [[ $dryRun == true ]] && return 0
  if [[ $vtable == true ]]; then
    vtableCreate=true
  elif [[ $startupRoot == $bundleRoot ]] && module_has_submodules; then
    vtableCreate=true
  fi
  if [[ $vtableCreate == true ]]; then
    vtableGate=$(lock_init)
    vtableLookupPath="$(mktemp)"
    vtable_init "$startupRoot" "$vtableLookupPath"
  fi
}
prod_release_update_vtable()
{
  # io_trace "prod_release_update_vtable -- $(print_vars vtable vtableCreate configSelectIsExcluded)"
  [[ $vtableCreate == true ]] || return 0
  if [[ "$PWD" == "$startupRoot" ]]; then
    prod_release_commit_vtable
  else
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
    [[ $configSelectIsExcluded == true || $dryRun == true ]] && return 0
    branch_merge "$prodBranch" "$moduleDevBranchPath" '-Xours' &>/dev/null || io_trace_error "prod_release_update_vtable merge"
  fi
}
prod_release_commit_vtable()
{
  # io_trace "prod_release_commit_vtable -- $(print_vars lbranch vbranch vnext)"
  if [[ $dryRun == true ]]; then
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate"
    mio_message "Created version table for ${VC}$prodBranch${DarkGray} at ${VC}$publishVTag" ${DarkGray}
  else
    local tmpBranch="_zou_$(date +%y%V)"
    git checkout -b "$tmpBranch" &>/dev/null
    vtable_update "$startupRoot" "$moduleId" "$vtableLookupPath" "$vtableGate" true
    mio_message "Created version table for ${VC}$prodBranch${Green} at ${VC}$publishVTag" ${Green}
    branch_merge "$tmpBranch" "$moduleDevBranchPath" "$prodBranch" '-Xours' &>/dev/null
    git checkout "$prodBranch" &>/dev/null
    git branch -D "$tmpBranch" &>/dev/null
  fi
}

################################
# Publish status in dry run mode
################################

prod_release_init_pstatus()
{
  pstatusParentGate=$(lock_init)
  pstatusParentLookupPath=$pstatusLookupPath
  pstatusLookupPath=''
  # io_trace "prod_release_init_pstatus 1 -- $(print_vars moduleId pstatusParentLookupPath pstatusLookupPath)"
  if config_has_submodules; then
    pstatusLookupPath="$(mktemp)"
    pstatus_init "$pstatusLookupPath"
    # io_trace "prod_release_init_pstatus 2 -- $(print_vars moduleId pstatusParentLookupPath pstatusLookupPath)"
  fi
}
prod_release_update_pstatus()
{
  # io_trace "prod_release_update_pstatus -- $(print_vars moduleId pstatusParentLookupPath pstatusLookupPath)"
  if [[ -n $pstatusLookupPath ]]; then
    pstatus_commit "$pstatusLookupPath"
    rm "$pstatusLookupPath"
  fi
  if [[ -n $pstatusParentLookupPath ]]; then
    pstatus_update "$pstatusParentLookupPath" "$pstatusParentGate" "$moduleId" "$publishStatus"
  fi
  # io_trace "prod_release_update_pstatus -- $(print_vars moduleId publishStatus)"
}
pstatus_init()
{
  local lookupPath=$1
  
  declare -A lookup                 # create lookup
  declare -p lookup >"$lookupPath"  # serialize lookup
  # io_trace "pstatus_init -- $(print_vars lookupPath)"
}
pstatus_update()
{
  local lookupPath=$1 gate=$2 moduleId=$3 publishStatus=$4
  
  lock_enter "$gate"
  . "$lookupPath"                     # deserialize lookup
  lookup[$moduleId]="$publishStatus"  # save publish status
  declare -p lookup >"$lookupPath"    # serialize lookup
  lock_exit "$gate"
  # io_trace "pstatus_update -- $(print_vars lookupPath publishStatus)"
}
# 
# out:
#   publishStatus
#   principalPublishStatus
pstatus_commit()
{
  local lookupPath=$1 mid status
  . "$lookupPath"
  for mid in ${!lookup[@]}; do
    status=${lookup[$mid]}
    [[ $status == 'notPublished' ]] && publishStatus=$status
    [[ $mid == $principalModuleId ]] && principalPublishStatus=$status
  done
  return 0
}

prod_run  "$@"
