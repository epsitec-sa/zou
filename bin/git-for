#!/bin/bash

[[ -z $ZOUL_LOCK ]]               && . zoul-lock
[[ -z $ZOUL_PROCESS ]]            && . zoul-process
[[ -z $ZOUL_GIT_REPO ]]           && . zoul-git-repo
[[ -z $ZOUL_GIT_CONFIG_SKU ]]     && . zoul-git-config-sku
[[ -z $ZOUL_GIT_CONFIG_SELECT ]]  && . zoul-git-config-select
[[ -z $ZOUL_GIT_CONFIG_PUBLISH ]] && . zoul-git-config-publish

jobsCount=16
args=()
while [[ "$#" > 0 ]]; do case "$1" in
  --) shift; args+=("$@"); break;;
  -h|--help) zou-help $0; exit 0;;
  -q|--quiet)         quiet=true;;
  -e|--stop-on-error) stopOnError=true;;
  -s|--sm-only)       smOnly=true;;
  -a|--all)           noSkuFilter=true;;
  -p|--deep)          noSelectFilter=true;;
  -b|--bottom-up)     bottomUp=true;;
  -j*) jobsCount=${1#-j};;
  -*) echo "unknown option: $1" >&2; exit 1;;
  *) args+=("$1");;
esac; shift; done

# global_variable_names='quiet stopOnError smOnly noSkuFilter noSelectFilter bottomUp startupRoot startupDir moduleId'
process_error()
{
  [[ $stopOnError == true ]] && process_kill_group $$ || exit $1
}
for_submodules()
{
  # io_warning ">>>> for_submodules" "[$moduleId]"
  local branch=$1 configFile include exclude smpath mroot=$PWD ec=0
  configFile=$(repo_zouflow_path "$mroot") || return $?
  [[ $noSkuFilter    == true ]] && include=( $(repo_list_submodule_paths) ) || include=( $(config_sku_list_included "$branch" "$configFile") )
  [[ $noSelectFilter == true ]] && exclude=() || exclude=( $(config_select_list_excluded "$branch" "$configFile") )
  include=$(array_remove_array 'include[@]' 'exclude[@]')
  [[ -z $include ]] && return 0

  local pids=()
  for smpath in $(string_sort $include); do
    (
      cd "$mroot/$smpath" &>/dev/null || {
        io_error "cd $mroot+$smpath" "[$moduleId]"
        process_kill_group $$
      }
      for_tree "$(branch_current)" || process_error $?
    ) &
    if [[ $stopOnError == true ]]; then
      pids+=($!)
      if (( $(wc -w <<<$(jobs -p)) % $jobsCount == 0 )); then
        wait "${pids[@]}" &>/dev/null || ec=$?
        pids=()
        [[ $ec -ne 0 ]] && break
      fi
    else
      if (( $(wc -w <<<$(jobs -p)) % $jobsCount == 0 )); then wait &>/dev/null; fi
    fi
  done
  if [[ $stopOnError == true ]]; then
    wait "${pids[@]}" &>/dev/null || ec=$?
  fi
  wait
  return $ec
  # io_warning "<<<< for_submodules" "[$moduleId]"
}
for_tree()
{
  # trace_method for_tree "$global_variable_names"
  [[ $quiet == true ]] || echo Entering "'$(path_make_relative '.' "$startupDir")'"
  local branch=$1 moduleId=$(repo_module_id) path ec=0
  path=$moduleId

  if [[ $bottomUp != true ]]; then
    eval "$zou_command" || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && return $ec
  fi

  for_submodules "$branch" || ec=$?
  [[ $ec -ne 0 && $stopOnError == true ]] && return $ec

  if [[ $bottomUp == true ]]; then
    eval "$zou_command" || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && return $ec
  fi
  return $ec
  # io_warning "<<<< for_tree ${*@Q}" "[$moduleId]"
}

startupDir=$PWD
startupRoot=$(repo_module_root)
cd "$startupRoot"
zou_command="${args[@]}"
if [[ $smOnly == true ]]; then
  for_submodules $(branch_current)
else
  for_tree $(branch_current)
fi