#!/usr/bin/env bash

[[ -z $ZOUL_CORE ]]       && . zoul-core
[[ -z $ZOUL_GIT_REPO ]]   && . zoul-git-repo
[[ -z $ZOUL_GIT_BUNDLE ]] && . zoul-git-bundle
[[ -z $ZOUL_GIT_CMD ]]    && . zoul-git-cmd

bundler_parse()
{
  local paths=() path

  while [[ "$#" > 0 ]]; do case "$1" in
    --) shift; paths+=("$@"); break;;
    -h|--help) zou-help $0; exit 0;;
    -a|--all)        allBundles=true;;
    -q|--quiet)      export quiet=true;;
    -f|--force)      export forceConfig=true;;
    -t|--prune-tags) export pruneTags=true;;
    -u|--unregister) export unregister=true;;
    --reset)         resetRegisteredBundles=true;;
    -*) io_error "unknown option '$1'"; return 1;;
    *)  paths+=("$1")
  esac; shift; done

  _bundler_add_bundle_paths "${paths[@]}"
}

bundler_run()
{
  # avoid default registration
  doNotRegisterBundle=true

  local unregister allBundles forceConfig quiet \
        resetRegisteredBundles pruneTags \
        bundlePaths=() bundleRegisteredPaths=()

  bundler_parse "$@"
  
  [[ -z $allBundles ]] && ! repo_bundle_root && allBundles=true

  _bundler_process_registration
  if [ ${#bundleRegisteredPaths[@]} -eq 0 ]; then
    mio_warning "No bundle registered."
    return 1
  fi

  io_message "${Cyan}[zou]${White} : ${Brown}Configuring bundles, please wait..."
  if [[ $allBundles == true ]]; then
    # io_trace "bundler_run -3- $(print_vars bundleRegisteredPaths[@])"
    bundle_visit 'bundleRegisteredPaths[@]' _bundler_config
  else
    # io_trace "bundler_run -4- $(print_vars bundlePaths[@])"
    bundle_visit 'bundlePaths[@]' _bundler_config
  fi
}

# Filter and normalize bundle paths
#
# in:
#   $@:paths
# in-out:
#   bundlePaths
_bundler_add_bundle_paths()
{
  local path ec=0
  for path; do
    path="$(repo_bundle_root "$path")"; ec=$?
    if [ $ec -eq 0 ] && [ -d "$path/zou" ] && ! array_contains_element "$path" "${bundlePaths[@]}"; then
      bundlePaths+=( "$(abspath "$path")" )
    fi
  done
  return $ec
}

# in:
#   resetRegisteredBundles
#   allBundles
#   unregister
# in-out:
#   bundlePaths
#   bundleRegisteredPaths
_bundler_process_registration()
{
  local broot=$(repo_bundle_root) path

  # process registration
  [[ $resetRegisteredBundles == true ]] && bundle_unregister_all

  if [[ $allBundles == true ]]; then
    # get sibling bundles
    local root="$(abspath $broot/..)" path
    _bundler_add_bundle_paths $(ls -d $root/*) "$PWD"
  fi
  [ ${#bundlePaths[@]} -eq 0 ] && bundlePaths+=("$broot")
  # io_trace "_bundler_process_registration -1- $(print_vars bundlePaths[@])"

  for path in "${bundlePaths[@]}"; do
    _bundler_register "$path" "$unregister"
  done

  bundle_set_registered_paths # -> bundleRegisteredPaths
  # io_trace "_bundler_process_registration -2- $(print_vars bundleRegisteredPaths[@])"
}
_bundler_register()
{
  # io_trace "_bundler_register ${*@Q}"
  local bundlePath="$1" unregister=$2 url
  [[ -z $bundlePath ]] && return 0

  url=$(gitx -C "$bundlePath" config remote.origin.url)
  if [[ $unregister == true ]]; then
    # io_trace "_bundler_register -1- $(print_vars url bundlePath unregister)"
    bundle_unregister "$url" "$bundlePath"
  else
    # io_trace "_bundler_register -2- $(print_vars url bundlePath)"
    bundle_register "$url" "$bundlePath"
  fi
}

_bundler_config()
{
  local command='_bundler' subcommand='config' \
        noSkuFilter=true cmdScopes=( config_scope )

  local message="${LightBlue}$bundleUrl${White} -> ${VC}$bundleRoot${White}"

  # check if bundle is already configured (exit code 1)
  if module_configure; then
    # bundle was not configured (now it is) - configure submodules
    # io_trace "_bundler_config -1- $(print_vars bundleRoot)"
    io_message "${Brown}┅ $message" "$bundleTracePrefix" ${White}
    cmd_register_module_paths true "$bundleRoot"
    cmd_visit_modules
  else
    # bundle is already configured
    # io_trace "_bundler_config -1- $(print_vars bundleRoot)"
    io_message "${Green}√ $message" "$bundleTracePrefix" ${White}
  fi
}
_bundler_config_scope()
{
  local abort=0 stopConfig
  # execute next russian doll
  $1 "${@:2}"
}
_bundler_config_prolog()
{
  # bundle is already configured in _bundler_config
  module_is_bundle && return 0

  # TODO: check if it is still necessary with zou-flow notes operations
  gitx config push.followTags true

  # repair previous zou installation
  notes_repair &>>"$stdallRedir" || forceConfig=true
  hooks_repair &>>"$stdallRedir" || forceConfig=true

  # io_lock_enter
  if [[ -z $stopConfig ]] && module_configure "$forceConfig"; then
    # module was not configured or configuration is forced
    if [[ -z $quiet ]]; then
      local moduleType
      module_is_bundle && moduleType='bundle' || moduleType='submodule'
      mio_message_unsafe "Configuring $moduleType..."
    fi
  else
    # already configured : do not abort if prune tags is asked
    stopConfig=true
    [[ $pruneTags == true ]] || abort=1
  fi
  if [[ $pruneTags == true ]]; then
    [[ -z $quiet ]] && mio_warning_unsafe 'Pruning tags...'
    repo_prune_tags
  fi
  # io_lock_exit

  return $abort
}

bundler_run "$@"

