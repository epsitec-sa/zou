#!/usr/bin/env bash

[[ -z $ZOUL_CORE ]]       && . zoul-core
[[ -z $ZOUL_GIT_REPO ]]   && . zoul-git-repo
[[ -z $ZOUL_GIT_BUNDLE ]] && . zoul-git-bundle
[[ -z $ZOUL_GIT_CMD ]]    && . zoul-git-cmd
[[ -z $ZOUL_GIT_HOOKS ]]  && . zoul-git-hooks

bundler_parse()
{
  while [[ "$#" > 0 ]]; do case "$1" in
    --) shift; bundlePaths+=("$@"); break;;
    -h|--help) zou-help $0; exit 0;;
    -u|--unregister) unregister=true;;
    -s|--scan)       scanBundles=true;;
    -k|--hooks)      updateHooks=true;;
    -f|--force)      forceUpdate=true;;
    -x|--external)   export noSelectFilter=true;;
    -q|--quiet)      quiet=true;;
    +)               scanBundles=true; updateHooks=true; forceUpdate=true;;
    --reset)         resetRegisteredBundles=true;;
    -*) io_error "unknown option '$1'"; return 1;;
    *)  bundlePaths+=( "$(abspath $1)" )
  esac; shift; done
}
bundler_run()
{
  # avoid default registration
  doNotRegisterBundle=true

  local unregister scanBundles updateHooks forceUpdate quiet \
        resetRegisteredBundles bundlePaths=()

  bundler_parse "$@"
  
  [[ $resetRegisteredBundles == true && -f "$zouConfigFile" ]] && rm "$zouConfigFile"

  if [[ $scanBundles == true ]]; then
    _bundler_scan
  fi
  
  [ ${#bundlePaths[@]} -eq 0 ] && bundlePaths+=("$(repo_bundle_root)")
  # io_trace "bundler_run 1 -- $(print_vars bundlePaths[@])"

  if [[ $unregister == true ]]; then
    bundle_visit_async 'bundlePaths[@]' _bundler_unregister
  else
    bundle_visit_async 'bundlePaths[@]' _bundler_register
  fi

  local bundleRegisteredPaths
  bundle_set_registered_paths
  # io_trace "bundler_run 2 -- $(print_vars bundleRegisteredPaths[@])"

  if [ ${#bundleRegisteredPaths[@]} -eq 0 ]; then
    mio_warning "No bundle registered."
    return 1
  fi

  if [[ $updateHooks == true ]]; then
    if [[ $scanBundles == true ]]; then
      bundle_visit_async 'bundleRegisteredPaths[@]' _bundler_config
    else
      bundle_visit_async 'bundlePaths[@]' _bundler_config
    fi
  else
    bundle_visit_async 'bundleRegisteredPaths[@]' _bundler_status
  fi
}
_bundler_scan()
{
  io_message "Scanning bundles, please wait..."
  local root="$(abspath $(repo_bundle_root)/..)"
  for dir in $(ls -d $root/*); do
    [[ -d "$dir/.git" && -d "$dir/zou" ]] || continue
    bundlePaths+=( "$dir" )
  done
  # io_trace "_bundler_scan -- $(print_vars root bundlePaths[@])"
}
_bundler_register()
{
  local url=$(gitx config remote.origin.url)
  bundle_register "$url" "$bundleRoot" "$updateHooks"
}
_bundler_unregister()
{
  local url=$(gitx config remote.origin.url)
  bundle_unregister "$url" "$bundleRoot"
}

_bundler_config()
{
  local command='_bundler' subcommand='config' \
        noSkuFilter=true cmdScopes=( config_scope )

  bundle_scope _bundler_config_command
}
_bundler_config_command()
{

  cmd_register_module_paths true "$bundleRoot"
  cmd_visit_modules
}
_bundler_config_prolog()
{
  # io_trace '_bundler_config_prolog -- $(print_vars moduleRoot bundleRoot)'
  if hooks_update_module "$moduleRoot" "$forceUpdate"; then
    # already updated, abort
    _bundler_message 'Git hooks already up to date'
    return 1
  elif module_is_bundle; then
    _bundler_message 'Installing git hooks, please wait...'
  else
    _bundler_message 'Updated git hooks...'
  fi
  gitx config push.followTags true
  return 0
}

_bundler_status()
{
  io_message "${LightBlue}$bundleUrl${White} -> ${VC}$bundleRoot${White}" "$bundleTracePrefix" ${White}
}
_bundler_update_hooks()
{
  hooks_update_module "$moduleRoot" "$bundleRoot"
}
_bundler_message()
{
  if module_is_bundle; then
    io_message "$1" "$bundleTracePrefix" ${White}
  else
    [[ -z $quiet ]] && io_warning "$1" "$moduleTracePrefix"
  fi
}

bundler_run "$@"

