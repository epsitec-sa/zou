#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core
ZOUL_GIT_BRANCH_CORE=true

[[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core

branch_exists()         { git rev-parse --quiet --verify $1 >/dev/null; }
branch_upstream()       { git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null; }
branch_sync_info()      { git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" refs/heads "$@"; }
branch_list_local()     { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_local_at()  { git show-ref --heads | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,'; }
branch_list_remote()    { git for-each-ref --format='%(refname:short)' refs/remotes | grep -v '/HEAD$'; }
branch_list_remote_at() { git show-ref | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | grep 'refs/remotes' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_list_all()       { branch_list_local; branch_list_remote; }
branch_list_all_at()    { git show-ref | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_is_attached()    { git symbolic-ref --short -q HEAD &>/dev/null; }
branch_is_local()       { git show-ref -s --verify "refs/heads/$1" &>/dev/null; }
branch_is_remote()      { git show-ref -s --verify "refs/remotes/$1" &>/dev/null; }
branch_is_head()
{
  local hash1 hash2
  hash1=$(git rev-parse HEAD^{} 2>/dev/null)
  [ $? -ne 0 ] && return 1
  hash2=$(git rev-parse $1^{} 2>/dev/null)
  [ $? -ne 0 ] && return 1
  [ $hash1 = $hash2 ]
}
branch_current()
{
  local c=$(git rev-parse --abbrev-ref HEAD)
  [ $c == 'HEAD' ] && git rev-parse --short HEAD || echo $c
}
branch_current_root_branch()
{
  cd "$(repo_bundle_dir)"
  local branch=$(branch_current)
  cd - >/dev/null
  echo $branch
}
branch_list_local_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $l && -n $r ]] && echo $l
  done < <(branch_sync_info)
}
branch_list_remote_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && echo $r
  done < <(branch_sync_info)
}
branch_list_all_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && {
      [[ -n $l ]] && echo $l
      echo $r
    }
  done < <(branch_sync_info)
}
branch_list_local_redondant()
{
  # list local branches that can be removed safely
  local l r i c
  while read l r i; do
    # keep tracking branches that are merged into tracked branches
    if [[ -n $l && -n $r && $i =~ (=|<) ]]; then
      [[ -z $c ]] && c=$(branch_current)
      # exclude branch 'master' and current branch
      [[ $l =~ (master|$c) ]] || echo $l
    fi
  done < <(branch_sync_info)
}
branch_list_local_untracked()
{
  local branches=( $(branch_list_local) )
  local tracked=( $(branch_list_local_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked()
{
  local branches=( $(branch_list_remote) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_all_untracked()
{
  local branches=( $(branch_list_all) )
  local tracked=( $(branch_list_all_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_flatten()
{
  local b
  for b in $(branch_list_remote_untracked); do
    echo ${b#*/}
  done
}
branch_list_all_flatten()
{
  branch_list_local
  branch_list_remote_untracked_flatten
}
branch_list_tracked_flatten()
{
  branch_list_local_tracked
  branch_list_remote_untracked_flatten
}

branch_remove_remote_tracked()
{
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array $1 tracked[@]
}

# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
# Display error and return empty if branch is unknown
branch_realize()
{
  if branch_is_local "$1" || branch_is_remote "$1" || [[ $1 == HEAD ]]; then
    echo "$1"
  else
    local remote=$(git remote)
    if branch_is_remote "$remote/$1"; then
      echo "$remote/$1"
    else
      return 1
    fi
  fi
}

branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }

branch_ensure_local()
{
  if ! git show-ref -s --verify "refs/heads/$1" 2>/dev/null; then
    git checkout $1 &>/dev/null || return 1
    git checkout - &>/dev/null
  fi
}
branch_checkout()
{
  if [[ -n $1 && $1 != $(branch_current) ]]; then
    git checkout "$(branch_without_remote_prefix $1)" 2>/dev/null
  fi
}
branch_list_attach_candidates()
{
  if ! branch_is_attached; then
    local branches=( $(branch_list_all_at $1) )
    branch_remove_remote_tracked branches[@]
  fi
}
branch_try_attach()
{
  # attach a detached head to the unique local branch that's pointing at
  if ! branch_is_attached; then
    local branches=($(branch_list_attach_candidates $1))
    if (( ${#branches[@]} == 1 )); then
      branch_checkout "${branches[0]}"
      echo "${branches[0]}"
    else
      return 1
    fi
  fi
}
branch_delete_local_redondant()
{
  branch_list_local_redondant | xargs -n1 git branch -d
}
