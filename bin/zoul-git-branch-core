#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core
ZOUL_GIT_BRANCH_CORE=true

[[ -z $ZOUL_CORE ]]     && . zoul-core
[[ -z $ZOUL_GIT_REF ]]  && . zoul-git-ref
[[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core
[[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo

# global options
#   showSwitchingMessage

branchChangedEvent=()

branch_raise_branch_changed_event()
{
  local handler
  for handler in "${branchChangedEvent[@]}"; do
    $handler "$@"
  done
}

branch_exists()         { git rev-parse --quiet --verify $1 >/dev/null; }
branch_upstream()       { git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null; }
branch_list_local()     { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_local_at()
{
  # io_trace "branch_list_local_at ${*@Q}"
  git show-ref --heads | grep $(git_get_commit $1) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,';
}
branch_list_remote()    { git for-each-ref --format='%(refname:short)' refs/remotes | grep -v '/HEAD$'; }
branch_list_remote_at() { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep 'refs/remotes' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_list_all()       { git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | grep -v '/HEAD$'; }
branch_list_all_at()    { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_is_attached()    { git symbolic-ref --short -q HEAD &>/dev/null; }
branch_is_local()       { git show-ref -s --verify "refs/heads/$1" &>/dev/null; }
branch_is_remote()      { git show-ref -s --verify "refs/remotes/$1" &>/dev/null; }
branch_is_prod()        { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_is_current()     { [[ $1 == $(git rev-parse --abbrev-ref HEAD) ]]; }
branch_is_head()
{
  local hash1 hash2
  hash1=$(git rev-parse HEAD 2>/dev/null)
  [ $? -ne 0 ] && return 1
  hash2=$(git_get_commit $1 2>/dev/null)
  [ $? -ne 0 ] && return 1
  [ $hash1 = $hash2 ]
}
branch_current()
{
  local ref=$(git rev-parse --abbrev-ref HEAD)
  echo "$ref"
  branch_is_local "$ref"
}
branch_current_root_branch()
{
  local opwd=$PWD branch ec=0
  cd "$(repo_bundle_root)"
  branch=$(branch_current) || ec=$?
  cd "$opwd"
  echo $branch
  return $ec
}
branch_sync_info()
{
  local patterns=() ref
  if [ $# -eq 0 ]; then
    patterns=( 'refs/heads' )
  else
    for ref in "$@"; do
      patterns+=( "refs/heads/$ref" )
    done
  fi
  git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" "${patterns[@]}"
}
branch_list_local_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $l && -n $r ]] && echo $l
  done < <(branch_sync_info)
}
branch_list_remote_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && echo $r
  done < <(branch_sync_info)
}
branch_list_all_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && {
      [[ -n $l ]] && echo $l
      echo $r
    }
  done < <(branch_sync_info)
}
branch_list_local_tracked_merged()
{
  # list local branches that can be removed safely
  local l r i c
  while read l r i; do
    # list tracking branches
    if [[ -n $l && -n $r ]]; then
      # that are merged into tracked branches...
      # or that have the tracking info broken but are merged in another remote
      if [[ $i =~ (=|<) ]] || [[ -z $i && -n $(git branch -r --contains $l) ]]; then
        echo $l
      fi
    fi
  done < <(branch_sync_info)
}
branch_list_local_can_delete()
{
  # list local branches that can be deleted safely
  local l c
  while read l; do
    # exclude branch 'master' and current branch
    [[ -z $c ]] && c=$(regex_escape $(branch_current))
    [[ $l =~ (master|$c) ]] || echo $l
  done < <(branch_list_local_tracked_merged)
}
branch_list_local_untracked()
{
  local branches=( $(branch_list_local) )
  local tracked=( $(branch_list_local_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked()
{
  local branches=( $(branch_list_remote) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_all_untracked()
{
  local branches=( $(branch_list_all) )
  local tracked=( $(branch_list_all_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_flatten()
{
  local b
  for b in $(branch_list_remote_untracked); do
    echo ${b#*/}
  done
}
branch_list_all_flatten()
{
  branch_list_local
  branch_list_remote_untracked_flatten
}
branch_list_tracked_flatten()
{
  branch_list_local_tracked
  branch_list_remote_untracked_flatten
}

branch_remove_remote_tracked()
{
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array $1 tracked[@]
}

# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
# Display error and return empty if branch is unknown
branch_realize()
{
  if branch_is_local "$1" || branch_is_remote "$1" || [[ $1 == HEAD ]]; then
    echo "$1"
  else
    local remote=$(git remote)
    if branch_is_remote "$remote/$1"; then
      echo "$remote/$1"
    else
      return 1
    fi
  fi
}

branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }

branch_ensure_local()
{
  if ! branch_is_local $1; then
    git branch $1 "$(git remote)/$1" >/dev/null
  fi
}
# out:
#   return code
#   0 local branch
#   1 remote branch
#   2 remote branch without prefix
#   3 tag
#   4 other
branch_ref_type()
{
  if git show-ref -s --verify "refs/heads/$1" &>/dev/null; then
    return 0
  elif git show-ref -s --verify "refs/remotes/$1" &>/dev/null; then
    return 1
  elif git show-ref -s --verify "refs/remotes/origin/$1" &>/dev/null; then
    return 2
  elif git show-ref -s --verify "refs/tags/$1" &>/dev/null; then
    return 3
  else
    return 4
  fi
}
branch_checkout()
{
  # io_trace "branch_checkout ${*@Q}"
  
  local ref=$1 always=$2 alias=$3 refType isCurrent
  [[ $alias == 'HEAD' ]] && unset alias
  branch_ref_type $ref; refType=$?
  branch_is_current $ref; isCurrent=$?
  if [[ $isCurrent -ne 0 || $always == true ]]; then
    # compute symbols
    local symType symRef
    case $refType in
      0) symType='branch'; symRef="$ref";;
      1) symType='new branch'; symRef="$(branch_without_remote_prefix $ref)";;
      2) symType='new branch'; symRef="$ref";;
      3) symType='tag'; symRef="($ref)";;
      4) symType='commit'; symRef="($ref...)";;
    esac

    # switching message
    [[ $isCurrent -ne 0 && $showSwitchingMessage == true ]] && io_message "Switching to $symType '$symRef'" "$moduleTracePrefix" Brown

    # checkout
    local line color info ec=0
    ref=$(branch_without_remote_prefix $ref)
    info=$(git checkout "$ref" 2>&1 >/dev/null); ec=$?

    if [[ $ec -eq 0 && $isCurrent -ne 0 ]]; then
      branch_raise_branch_changed_event $ref
    fi
    
    while read -r line; do
      [[ -z $line ]] && continue
      if [[ $line =~ ^Switched ]]; then
        color=Green
      elif [[ -z $color ]]; then
        if [[ $line =~ ^Already ]]; then
          color=LightBlue
        elif [[ $line =~ ^Warning ]]; then
          color=Brown
        elif [[ $line =~ ^error ]]; then
          color=Red
        elif [[ $line =~ ^Note:\ checking\ out ]]; then
          io_message "Switched to $symType '$symRef'" "$moduleTracePrefix" Green
          break
        elif [[ $line =~ ^Previous\ HEAD ]]; then
          continue
        else
          color=Gray
        fi
      fi
      [[ -n $alias ]] && line="$line (${Brown}$alias${!color})"
      io_message "$line" "$moduleTracePrefix" $color
      unset alias
    done <<< "$info"
    return $ec
  fi
}
branch_push()
{
  local branch=$1 remote=${2:-origin} line
  (git push $remote --set-upstream "$branch" 2>/dev/null) | \
  while read -r line; do
    [[ -z $line ]] && continue
    io_info "  $line" "$moduleTracePrefix"
  done
  return ${PIPESTATUS[0]}
}
branch_move()
{
  local branch1=$1 branch2=$2
  if git checkout $branch1 &>/dev/null; then
    git checkout - &>/dev/null
    git ls-remote --heads --exit-code origin "$branch1" &>/dev/null || git push origin "$branch1"
    git branch "$branch2" "origin/$branch1" >/dev/null 2>&1
    git push origin --set-upstream "$branch2" >/dev/null 2>&1
    git push --delete --force origin "$branch1" >/dev/null 2>&1
    git branch -D "$branch1" >/dev/null 2>&1
    io_warning "Moved branch '$branch1' to '$branch2'" "$moduleTracePrefix"
    return 0;
  fi
  return 1
}
branch_list_attach_candidates()
{
  branch_list_local_at $1
  local remoteBranches=( $(branch_list_remote_at $1) )
  remoteBranches=( $(branch_remove_remote_tracked remoteBranches[@]) )
  printf '%s\n' ${remoteBranches[@]#origin/}
}
branch_filter_hint()
{
  local hintType=$1 branch; shift
  if [[ $hintType == 'prod' ]]; then
    for branch in "$@"; do
      if branch_is_prod $branch; then
        echo $branch
      fi
    done
  elif [[ $hintType == 'dev' ]]; then
    for branch in "$@"; do
      if ! branch_is_prod $branch; then
        echo $branch
      fi
    done
  else
    for branch in "$@"; do
      echo $branch
    done
  fi
}
branch_set_hint_type()
{
  # in:  $1 -- branch or tag
  # out: hintType -- (dev|prod)
  hintType=${1##*/}
  [[ $hintType == 'dev' || $hintType == 'prod' ]] && return 0
  [[ $hintType =~ ^(.*/)?v?[0-9]+\.[0-9]+ ]] && { hintType='prod'; return 0; }
  hintType='dev'
}
branch_set_hint_info()
{ 
  # in:  $1 -- [ branch ref ]
  #      $2 -- [ hint or branch or tag ]
  # out: hintType -- (dev|prod)
  #      refHint  -- ref fallback hint 
  local ref=${1:-HEAD} hint=$2 branch
  branch=$(branch_current_root_branch) || branch="$(git_symbolic_ref $ref)"
  if [[ -z $hint ]]; then
    [[ $branch == 'HEAD' ]] && return 1
    hint=$branch
  fi
  branch_set_hint_type $hint
  [[ $hintType == 'prod' ]] && refHint=${branch/%\/dev/\/prod} || refHint=$branch
}
# try to attach a detached head to a branch that's pointing at it.
branch_try_attach()
{
  # io_trace "branch_try_attach ${*@Q}"

  local ref=$1 hint=$2 showCheckout=${3:-true}
  local branches=( $(branch_list_attach_candidates $ref | grep -v '^other/') )
  # io_trace "branch_try_attach -- $(print_vars ref hint branches[@])"
  [ ${#branches[@]} -eq 0 ] && return 1
  [ ${#branches[@]} -eq 1 ] && { branch_checkout "${branches[0]}" $showCheckout $ref; return 0; }

  # try to discriminate using given hint
  local hint=$2 hintType refHint hintBranches
  if [[ -n $hint ]]; then
    branch_set_hint_type $hint
    hintBranches=( $(branch_filter_hint "$hintType" "${branches[@]}") )
    # io_trace "branch_filter_hint $hintType ${branches[*]@Q} : ${hintBranches[*]@Q}"
    [ ${#hintBranches[@]} -eq 1 ] && { branch_checkout "${hintBranches[0]}" $showCheckout $ref; return 0; }
  fi
  # try to discriminate using root branch or ref and hint
  branch_set_hint_info "$@"
  # no hint, checkout first branch
  [ $? -ne 0 ] && { branch_checkout "${branches[0]}" $showCheckout $ref; return 1; }
  hintBranches=( $(branch_filter_hint "$hintType" "${branches[@]}") )
  # io_trace "branch_filter_hint $hintType ${branches[*]@Q} : ${hintBranches[*]@Q}"
  [ ${#hintBranches[@]} -eq 1 ] && { branch_checkout "${hintBranches[0]}" $showCheckout $ref; return 0; }

  # io_trace "branch_try_attach -- $(print_vars hintType refHint)"
  # try to discriminate using fallbacks
  local branch reHint pHint
  if [[ $hintType == 'prod' ]]; then
    for hint in $(ref_prod_fallback "$refHint"); do
      # replace prod suffix with vbranch regex
      reHint=$(regex_escape "${hint%prod}")
      pHint="^${reHint}[0-9]+\.[0-9]+"
      for branch in ${hintBranches[@]}; do
        [[ $branch =~ $pHint ]] && { branch_checkout "$branch" $showCheckout $ref; return 0; }
      done
    done
  fi
  # dev
  for hint in $(ref_dev_fallback "$refHint"); do
    for branch in ${branches[@]}; do
      [[ $branch == $hint ]] && { branch_checkout "$branch" $showCheckout $ref; return 0; }
    done
  done
  # nothing found try prod
  if [[ $hintType == 'dev' ]]; then
    for hint in $(ref_prod_fallback "${refHint%/dev}/prod"); do
      # replace prod suffix with vbranch regex
      reHint=$(regex_escape "${hint%prod}")
      pHint="^${reHint}[0-9]+\.[0-9]+"
      # io_trace "branch_try_attach -- $(print_vars hintType hint reHint pHint)"
      for branch in ${branches[@]}; do
        [[ $branch =~ $pHint ]] && { branch_checkout "$branch" $showCheckout $ref; return 0; }
      done
    done
  fi
  return 1
}
