#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core
ZOUL_GIT_BRANCH_CORE=true

[[ -z $ZOUL_CORE ]]       && . zoul-core
[[ -z $ZOUL_GIT_REF ]]    && . zoul-git-ref
[[ -z $ZOUL_GIT_CORE ]]   && . zoul-git-core
[[ -z $ZOUL_GIT_REPO ]]   && . zoul-git-repo

# global options
#   showSwitchingMessage

headChangedEvent=()
headNameChangedEvent=()
checkoutNoChangeEvent=()
branchCreatedEvent=()
branchDeletedEvent=()
branch_raise_head_changed_event()        { raise_event 'headChangedEvent[@]' "$@"; }
branch_raise_head_name_changed_event ()  { raise_event 'headNameChangedEvent[@]' "$@"; }
branch_raise_checkout_no_change_event()  { raise_event 'checkoutNoChangeEvent[@]' "$@"; }
branch_raise_branch_created_event()      { raise_event 'branchCreatedEvent[@]' "$@"; }
branch_raise_branch_deleted_event()      { raise_event 'branchDeletedEvent[@]' "$@"; }


# in:
#  lbranch=$1 -- local branch name
# std-out:
#  rbranch    -- remote branch (even if lbranch does not exist)
branch_upstream()
{
  git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null && return 0
  local remote
  for remote in $(git remote); do
    branch_is_remote "$remote/$1" && { echo "$remote/$1"; return 0; }
  done
  return 1
}
# Determine remote branch name
#
# usage:
#  local rbranch
#  branch_set_upstream LBRANCH
# in:
#  lbranch=$1 -- local branch name
# var-out:
#  rbranch    -- remote branch (even if lbranch does not exist)
branch_set_upstream()
{
  # io_trace "branch_set_upstream ${*@Q}"
  rbranch=$(git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null)
  [ $? -eq 0 ] && return 0
  local remote
  for remote in $(git remote); do
    if branch_is_remote "$remote/$1"; then
      rbranch="$remote/$1"
      # io_trace "branch_set_upstream 2 -- $(print_vars rbranch)"
      return 0
    fi
  done
  rbranch=''
  # io_trace "branch_set_upstream 3 -- $(print_vars rbranch)"
  return 1
}
branch_exists()
{
  branch_realize "$1" >/dev/null
  [ $? -le 1 ]
}
branch_is_remote_candidate()
{
  local branch=$1 remote=$2
  ( [[ $branch =~ ^sku/ ]] || branch_is_prod "$branch" ) && ! branch_is_archived "$branch" "$remote"
}
branch_is_archived()
{
  local branch=$1 remote=$2
  ref_exists "other/archive/$branch" &>/dev/null && return 0
  [[ -z $remote ]] && remote=$(git_remote)
  [[ -n $remote ]] && ref_exists "$remote/other/archive/$branch"
}
branch_list_local()     { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_local_at()
{
  # io_trace "branch_list_local_at ${*@Q}"
  git show-ref --heads | grep $(git_get_commit $1) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,';
}
branch_list_remote()    { git for-each-ref --format='%(refname:short)' refs/remotes | grep -v '/HEAD$'; }
branch_list_remote_at() { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep 'refs/remotes' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_list_all()       { git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | grep -v '/HEAD$'; }
branch_list_all_at()    { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_is_attached()    { git symbolic-ref --short -q HEAD &>/dev/null; }
branch_is_local()       { git show-ref -s --verify "refs/heads/$1" &>/dev/null; }
branch_is_remote()      { git show-ref -s --verify "refs/remotes/$1" &>/dev/null; }
branch_is_prod()        { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_is_dev()         { [[ $1 =~ (master|/dev)$ ]] && return 0 || return 1; }
branch_is_wip()         { [[ $1 =~ ^(.*/)?wip/ ]] && return 0 || return 1; }
branch_is_hotfix()      { [[ $1 =~ ^(.*/)?hotfix/ ]] && return 0 || return 1; }
branch_is_head()
{
  local hash1 hash2
  hash1=$(git rev-parse HEAD 2>/dev/null)
  [ $? -ne 0 ] && return 1
  hash2=$(git_get_commit $1 2>/dev/null)
  [ $? -ne 0 ] && return 1
  [ $hash1 = $hash2 ]
}
branch_current()
{
  local ref=$(git rev-parse --abbrev-ref HEAD)
  echo "$ref"
  branch_is_local "$ref"
}
branch_is_ancestor_of_local_trackable()
{
  branch_is_ancestor_of "$1" $(branch_list_local_trackable)
}
branch_is_ancestor_of_local()
{
  branch_is_ancestor_of "$1" $(branch_list_local)
}
branch_is_ancestor_of()
{
  local ref=${1:-HEAD} branch ec; shift
  for branch; do
    git merge-base --is-ancestor "$ref" "$branch"; ec=$?
    # io_trace "branch_is_ancestor_of -- $(print_vars ref branch ec) PWD='$PWD'"
    [ $ec -eq 0 ] && return 0
  done
  return 1
}
branch_current_root_branch()
{
  local opwd=$PWD branch ec=0
  cd "$(repo_bundle_root)"
  branch=$(branch_current) || ec=$?
  cd "$opwd"
  echo $branch
  return $ec
}
branch_sync_info()
{
  # io_trace "branch_sync_info ${*@Q}"
  local patterns=() ref
  if [ $# -eq 0 ]; then
    patterns=( 'refs/heads' )
  else
    for ref in "$@"; do
      patterns+=( "refs/heads/$ref" )
    done
  fi
  # io_trace "branch_sync_info -- $(print_vars patterns[@])"
  git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" "${patterns[@]}"
}
branch_list_local_tracked()
{
  local l r i
  while read -r l r i; do
    [[ -n $l && -n $r ]] && echo $l
  done < <(branch_sync_info)
}
branch_list_remote_tracked()
{
  local l r i
  while read -r l r i; do
    [[ -n $r ]] && echo $r
  done < <(branch_sync_info)
}
branch_list_all_tracked()
{
  local l r i
  while read -r l r i; do
    [[ -n $r ]] && {
      [[ -n $l ]] && echo $l
      echo $r
    }
  done < <(branch_sync_info)
}
branch_list_local_can_delete()
{
  # list local branches that can be removed safely
  local l r i c remote
  remote=$(git_remote)
  while read l r i; do
    # exclude branch 'master' and current branch
    [[ -z $c ]] && c=$(wildcard_to_regex ${moduleHead:-$(branch_current)})
    [[ $l =~ (master|$c) ]] && continue
    # tracking branches
    #   that are merged into tracked branches...
    #   or that have the tracking info broken but are merged in another remote
    if [[ -n $l && -n $r ]] && ([[ $i =~ (=|<) ]] || [[ -z $i && -n $(git branch -r --contains $l) ]]); then
      echo $l
    # archived branches merged in another remote
    elif [[ -n $l ]] && branch_is_archived "$l" "$remote" && [[ -n $(git branch -r --contains $l) ]]; then
      echo $l
    fi
  done < <(branch_sync_info)
}
branch_list_local_untracked()
{
  local branches=( $(branch_list_local) )
  local tracked=( $(branch_list_local_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_local_trackable()
{
  local l r i remote
  remote=$(git_remote)
  while read -r l r i; do
    if [ -z $r ]; then
      branch_is_remote_candidate "$l" "$remote" && echo "$l"
    else
      echo $l
    fi
  done < <(branch_sync_info)
}
branch_list_remote_untracked()
{
  local branches=( $(branch_list_remote) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_at()
{
  local branches=( $(branch_list_remote_at $1) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_all_untracked()
{
  local branches=( $(branch_list_all) )
  local tracked=( $(branch_list_all_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_flatten()
{
  local b
  for b in $(branch_list_remote_untracked); do
    echo ${b#*/}
  done
}
branch_list_all_flatten()
{
  branch_list_local
  branch_list_remote_untracked_flatten
}
branch_list_all_at_flatten()
{
  local b
  branch_list_local_at $1
  for b in $(branch_list_remote_untracked_at "$1"); do
    echo ${b#*/}
  done
}
branch_list_tracked_flatten()
{
  branch_list_local_tracked
  branch_list_remote_untracked_flatten
}

branch_remove_remote_tracked()
{
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array $1 tracked[@]
}

# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
# out:
#   return codes:
#     0 -- branch is local
#     1 -- branch is remote
#     2 -- branch does not exists
branch_realize()
{
  local ref=${1:-HEAD}
  if [[ $ref == 'HEAD' ]]; then
    ref=$(git symbolic-ref --short HEAD 2>/dev/null)
    [ $? -ne 0 ] && return 2
  fi
  if branch_is_local "$ref"; then
    echo "$ref"
    return 0
  elif branch_is_remote "$ref"; then
    echo "$ref"
    return 1
  else
    local upstream
    upstream=$(branch_upstream "$ref")
    [ $? -ne 0 ] && return 2
    echo "$upstream"
    return 1
  fi
}
# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
#
# usage:
#   local branch lbranch bref
#   branch_set_realize BRANCH
# in:
#   ref=$1      -- local or remote branch ref
#   ensureLocal -- if true and ref is remote only, fetch and create local branch
# var-out:
#   branch    -- local branch name (0) if it exists || remote branch name (1) if it exists || empty (2) 
#   lbranch   -- local branch name (even if it does not exist)
#   bref      -- branch reference (refs/heads/$lbranch || refs/remotes/$branch)
# return:
#   0 -- branch is local
#   1 -- branch is remote
#   2 -- branch does not exists
branch_set_realize()
{
  # io_trace "branch_set_realize ${*@Q}"
  branch=''; lbranch=''; bref=''
  local ref=${1:-HEAD} ensureLocal=${2:-false}
  if [[ $ref == 'HEAD' ]]; then
    ref=$(branch_list_all_at 'HEAD' | cut -f 1 -d ' ')
    # io_trace "branch_set_realize 0 -- $(print_vars ref)"
    [[ -z $ref ]] && return 2
  fi
  if branch_is_local "$ref"; then
    branch=$ref
    lbranch=$branch
    bref="refs/heads/$lbranch"
    # io_trace "branch_set_realize 1 -- $(print_vars ref branch lbranch bref)"
    return 0
  else
    if branch_is_remote "$ref"; then
      branch=$ref
      lbranch=${branch#*/}
      bref="refs/remotes/$branch"
      # io_trace "branch_set_realize 2 -- $(print_vars ref branch lbranch bref)"
    else
      local rbranch
      branch_set_upstream "$ref" || return 2
      branch=$rbranch
      lbranch=${branch#*/}
      bref="refs/remotes/$branch"
      # io_trace "branch_set_realize 3 -- $(print_vars ref branch lbranch bref)"
    fi

    if [[ $ensureLocal == 'true' ]]; then
      local remote=${branch%%/*}
      git fetch "$remote" "$lbranch":"$lbranch" &>/dev/null
      io_eval "git push "$remote" --set-upstream "$lbranch" 2>/dev/null" : ${DarkGray}
      bref="refs/heads/$lbranch"
      # io_trace "branch_set_realize 4 -- $(print_vars ref branch lbranch bref)"
      return 0
    else
      # branch is remote
      return 1
    fi
  fi
}
branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }

branch_ensure_local()
{
  if ! branch_is_local $1; then
    git branch "$1" "$(branch_upstream $1)" >/dev/null
  fi
}
branch_ensure_local_vbranch()
{
  local vbranch=$1 vtag=$2 rvbranch
  rvbranch=$(branch_realize "$vbranch")
  case $? in
  0) ;;
  1) local line
     (git branch "$vbranch" "$rvbranch" 2>/dev/null) | \
     while read -r line; do
       [[ -z $line ]] && continue
       mio_message "  $line" ${DarkGray}
     done;;
  *) git branch "$vbranch" "$vtag";;
  esac
}
# usage:
#   local refSym
#   branch_ref_type REF
# out:
#   refSym  -- ref symbol
# return code
#   0 local branch
#   1 remote branch without prefix
#   2 tag
#   3 remote branch
#   4 other
branch_ref_type()
{
  if git show-ref -s --verify "refs/heads/$1" &>/dev/null; then
    refSym=$1
    return 0
  elif git show-ref -s --verify "refs/remotes/origin/$1" &>/dev/null; then
    refSym=$1
    return 1
  elif git show-ref -s --verify "refs/tags/$1" &>/dev/null; then
    refSym=$1
    return 2
  elif git show-ref -s --verify "refs/remotes/$1" &>/dev/null; then
    refSym=${1#*/}
    return 3
  else
    local tags=( $(git tag --points-at "$1^{}" 2>/dev/null) )
    if [ ${#tags[@]} -eq 0 ]; then
      refSym="$(git rev-parse --short "$1^{}" 2>/dev/null)"
      return 4
    else
      refSym=${tags[-1]}
      return 2
    fi
  fi
}
branch_checkout()
{
  # io_trace "branch_checkout ${*@Q}"
  local ref=$1 forceCheckout=$2 refType refSym checkout raiseEvent isCurrent=0
  # io_trace "branch_checkout 1 -- $(print_vars ref forceCheckout)"

  # checkout = force || !current
  # raise = !current || symChanged
  if [[ $ref == $(git rev-parse --abbrev-ref HEAD 2>/dev/null) ]]; then
    # no sym change
    [[ $forceCheckout == true ]]; checkout=$?
    raiseEvent=1
    # io_trace "branch_checkout 2.1 -- $(print_vars ref refSym forceCheckout checkout raiseEvent isCurrent)"
  elif ref_is_head "$ref"; then
    # no hash change
    checkout=0
    raiseEvent=1
    # io_trace "branch_checkout 2.2 -- $(print_vars ref refSym forceCheckout checkout raiseEvent isCurrent)"
  else
    checkout=0
    raiseEvent=0
    isCurrent=1
    # io_trace "branch_checkout 2.3 -- $(print_vars ref refSym forceCheckout checkout raiseEvent isCurrent)"
  fi
  branch_ref_type $ref; refType=$?
  # io_trace "branch_checkout 2 -- $(print_vars ref forceCheckout ref refSym refType)"
  if [ $checkout -eq 0 ]; then
    # compute symbols
    local ioType ioRef=$refSym ec=0
    case $refType in
      0) ioType='branch';;
      1) ioType='new branch';;
      2) ioType='tag'; ioRef="($ioRef)";;
      3) ioType='new branch';;
      4) ioType='commit'; ioRef="($ioRef)";;
    esac
    # io_trace "branch_checkout 3 -- $(print_vars ref forceCheckout checkout raiseEvent isCurrent refType refSym ioType ioRef)"

    # switching message
    [[ $showSwitchingMessage == true ]] && mio_info "Switching to $ioType $ioRef"
    # checkout
    [ $isCurrent -ne 0 ] && repo_discard_internal_ignore_list
    _branch_checkout_core "$refSym"; ec=$?
    return $ec
  else
    branch_raise_checkout_no_change_event "$refSym"
  fi
}
_branch_raise_checked_out_events()
{
  if [[ $raiseEvent -eq 0 ]]; then
    branch_raise_head_changed_event "$refSym"
  elif [[ $moduleHead != $refSym ]]; then
    branch_raise_head_name_changed_event "$refSym"
  else
    branch_raise_checkout_no_change_event "$refSym"
  fi
}
_branch_checkout_core()
{
  local ref=$1 skipNextLines skipCurrentLine ec line lines color alias
  # io_trace ">>>> _branch_checkout_core ${*@Q}"

  IFS=$'\n' lines=( $(git checkout "$ref" 2>&1) ); ec=$?; IFS=$OIFS
  if [[ $ec -eq 0 ]]; then
    _branch_raise_checked_out_events
  fi
  
  io_lock_enter
  # for line in "${lines[@]}"; do
  #   io_message_unsafe "--$line" "$moduleTracePrefix" "${DarkGray}"
  # done
  for line in "${lines[@]}"; do
    _branch_checkout_selector
    [[ $skipCurrentLine == true ]] && continue
    io_message_unsafe "${indent}$line" "$moduleTracePrefix" "$color"
    [[ $skipNextLines == true ]] && break
  done
  io_lock_exit
  # io_trace "<<<< _branch_checkout_core ${*@Q}"
  return $ec
}
_branch_checkout_selector()
{
  # io_trace_unsafe "_branch_checkout_selector 1 -- $(print_vars ioType ioRef alias line)"
  skipNextLines=''; skipCurrentLine=''; skipAllLines=''; indent=''; alias=''
  # [[ -z $line ]] && continue
  if [[ $line =~ ^Switched ]]; then
    line="Switched to $ioType ${VC}$ioRef"
    color=${Green}
    alias=$moduleAlias
    skipNextLines=true
  elif [[ $line =~ ^(Note:\ checking\ out|Previous\ HEAD) ]]; then
    line="Switched to $ioType ${VC}$ioRef"
    color=${Green}
    alias=$moduleAlias
    skipNextLines=true
  elif [[ $line =~ ^Already ]]; then
    line="Already on ${VC}$ioRef"
    color=${LightBlue}
    alias=$moduleAlias
    skipNextLines=true
  elif [[ $line =~ ^HEAD\ is\ now\ at\ ([0-9a-f]+) && $isCurrent -eq 0 ]]; then
    line="Already at ${VC}$ioRef"
    color=${LightBlue}
    alias=$moduleAlias
    skipNextLines=true
  elif [[ $line =~ ^([wW]arning:)(.*) ]]; then
    line="${Brown}${BASH_REMATCH[1]}${DarkGray}${BASH_REMATCH[2]}"
    color=${DarkGray}
  elif [[ $line =~ ^(error|fatal)(:[[:blank:]]*)(.*) ]]; then
    line="${Red}${BASH_REMATCH[1]}${BASH_REMATCH[2]}${BASH_REMATCH[3],}"
    color=${Cyan}
  elif [[ $line =~ ^M[[:space:]]+ ]]; then
    skipCurrentLine=true
  elif [[ -z $color ]]; then
    skipCurrentLine=true
    # color=${DarkGray}
    # indent='  '
  fi
  if [[ -n $alias ]]; then
    line="${color}$line${DarkGray} -- $alias"
  else
    line="${color}$line"
  fi
}
branch_show_status()
{
  io_buffered_eval 'git status -s --porcelain | sort' _branch_show_status_line_selector ${Gray} "$1"
}
_branch_show_status_line_selector()
{
  if [[ $line =~ ^([[:blank:]]*[A-Z\?]+[[:blank:]]+)(.+)$ ]]; then
    line=${Red}${BASH_REMATCH[1]}${Gray}${BASH_REMATCH[2]}
  fi
}
branch_ensure_remote()
{
  local branch=$1 remote=${2:-origin}
  branch_upstream "$branch" >/dev/null && return 0
  io_eval "git push "$remote" --set-upstream "$branch" 2>/dev/null" : ${DarkGray}
}
branch_force_delete()
{
  local branch=$1 ec=0
  if branch_is_local "$branch"; then
    git branch -D "$branch" >/dev/null 2>&1
  elif branch_is_remote "$branch"; then
    local remote=${branch%%/*} lbranch=${branch#*/}
    git branch --unset-upstream "$lbranch"
    git push --delete --force "$remote" "$lbranch" >/dev/null 2>&1
  fi
}
branch_move()
{
  # io_trace "branch_move ${*@Q}"
  local branch1=$1 branch2=$2 rbranch1 ec=0
  [[ -z "$branch1" || -z "$branch2" ]] && { mio_error "branch_move: missing argument[s]"; return 1; }
  [[ $branch1 == $branch2 ]] && return 0
  [[ $branch1 == 'master' ]] && { mio_error "branch_move: branch 'master' cannot be renamed"; return 1; }
  branch_exists "$branch2" && { mio_error "branch_move: destination branch '$branch2' already exists"; return 1; }

  branch1=$(branch_realize "$branch1"); ec=$?
  if [ $ec -eq 0 ]; then
    # local branch1 exists
    rbranch1=$(branch_upstream "$branch1")
    if [ $? -eq 0 ]; then
      local remote=${rbranch1%%/*}
      # io_trace "branch_move (RENAME BOTH) -- $(print_vars branch1 branch2 rbranch1 remote)"
      # remote branch1 exists : rename both
      local tmpBranch
      if ref_is_current "$branch1"; then
        tmpBranch='zou/branch_move'
        if ! git checkout -b "$tmpBranch" "$branch1" &>/dev/null; then
          git branch -D "$tmpBranch" >/dev/null 2>&1
          repo_require_clean_work_tree 'Cannot move branch[es]'
          return 1
        fi
      fi
      # create branch2 at rbranch1
      git branch "$branch2" "$rbranch1" >/dev/null 2>&1
      # create remote branch2
      git push -u "$remote" "$branch2" >/dev/null 2>&1
      # delete remote branch1
      git push --delete --force "$remote" "$branch1" >/dev/null 2>&1
      # delete local branch1
      git branch -D "$branch1" >/dev/null 2>&1
      # restore active branch (renamed)
      if [[ -n $tmpBranch ]]; then
        branch_checkout "$branch2" >/dev/null 2>&1
        git branch -D "$tmpBranch" >/dev/null 2>&1
        git push --delete --force "$remote" "$tmpBranch" >/dev/null 2>&1
      fi
    else
      # remote branch1 does not exist : rename local only
      # io_trace "branch_move (RENAME LOCAL ONLY) -- $(print_vars branch1 branch2)"
      git branch -m "$branch1" "$branch2"
    fi 
  elif [ $ec -eq 1 ]; then
    # local branch1 does not exist : rename remote only
    local remote=${branch1%%/*}
    # io_trace "branch_move (RENAME REMOTE ONLY) -- $(print_vars branch1 branch2 remote)"
    # create branch2 at rbranch1
    git branch "$branch2" "$branch1" >/dev/null 2>&1
    # create remote branch2
    git push -u "$remote" "$branch2" >/dev/null 2>&1
    # delete remote branch1
    git push --delete --force "$remote" "${branch1#*/}" >/dev/null 2>&1
    # delete local branch2
    git branch -D "$branch2" >/dev/null 2>&1
    branch2="$remote/$branch2"
  else
    mio_error "branch_move: branch '$branch1' does not exist"
    return 1
  fi
  mio_success "Moved branch '$branch1' to '$branch2'"
}
branch_delete()
{
  # io_trace "branch_delete ${*@Q}"
  local ref=$1 remoteOnly=$2 branch lbranch bref rbranch remote ec=0
  [[ -z "$ref" ]] && { mio_error "branch_delete: missing argument[s]"; return 1; }
  [[ $ref == 'master' ]] && { mio_error "branch_delete: branch 'master' cannot be deleted"; return 1; }
  branch_set_realize "$ref"; ec=$?
  ref_is_current "$lbranch" &&  { mio_error "branch_delete: current branch '$lbranch' cannot be deleted"; return 1; }
  # io_trace "branch_delete 1 -- $(print_vars branch lbranch bref)"
  if [ $ec -eq 0 ]; then
    # local branch exists
    rbranch=$(branch_upstream "$branch")
    if [ $? -eq 0 ]; then
      remote=${rbranch%%/*}
      # io_trace "branch_delete (DELETE BOTH) -- $(print_vars branch branch2 rbranch remote)"
      # delete remote branch
      git push --delete --force "$remote" "$branch" >/dev/null 2>&1
      if [[ $remoteOnly == true ]]; then
        branch_raise_branch_deleted_event "$rbranch"
      else
        # delete local branch
        git branch -D "$branch" >/dev/null 2>&1
        branch_raise_branch_deleted_event "$branch" "$rbranch"
      fi
    elif [[ $remoteOnly != true ]]; then
      # remote branch does not exist : delete local only
      # io_trace "branch_delete (DELETE LOCAL ONLY) -- $(print_vars branch branch2)"
      git branch -D "$branch" >/dev/null 2>&1
      branch_raise_branch_deleted_event "$branch"
    fi
  elif [ $ec -eq 1 ]; then
    # local branch does not exist : delete remote only
    remote=${branch%%/*}
    # io_trace "branch_delete (DELETE REMOTE ONLY) -- $(print_vars branch branch2 remote)"
    # delete remote branch
    git push --delete --force "$remote" "${branch#*/}" >/dev/null 2>&1
    branch_raise_branch_deleted_event "$branch"
  else
    mio_error "branch_delete: branch '$branch' does not exist"
    return 1
  fi
  mio_success "Deleted branch ${VC}$branch"
}
branch_create()
{
  local branch=$1 commit=${2:-HEAD}
  if ! ref_exists $branch; then
    git branch "$branch" "$commit"
    branch_raise_branch_created_event "$branch"
    mio_success "Created branch ${VC}$branch"
  fi
}
# in:
#   $1:branchOrTag
# out:
#   hintType -- (dev|prod)
branch_set_hint_type()
{
  hintType=${1##*/}
  [[ $hintType == 'dev' || $hintType == 'prod' ]] && return 0
  [[ $hintType =~ ^(.*/)?v?[0-9]+\.[0-9]+ ]] && { hintType='prod'; return 0; }
  hintType='dev'
}
branch_list_attach_candidates()
{
  # io_trace "branch_list_attach_candidates ${*@Q}"
  local ref=$1 sku=$2 branches folder version hint branch
  
  if vtag_is_semver $ref; then
    folder=${BASH_REMATCH[1]}
    version="${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
    if [[ -n $folder ]]; then
      branches=()
      hint=$(wildcard_to_regex $folder)
      for branch in $(branch_list_all_at_flatten $ref); do
        [[ $branch =~ ^$hint ]] && branches+=( $branch )
      done
    else
      branches=( $(branch_list_all_at_flatten $ref) )
    fi
  else
    branches=( $(branch_list_all_at_flatten $ref) )
  fi
  [ ${#branches[@]} -eq 0 ] && return 0
  
  # io_trace "branch_list_attach_candidates -- $(print_vars ref sku branches[@])"
  if [[ $sku == 'master' ]]; then
    for branch in ${branches[@]}; do
      [[ $branch == 'master' ]] && { echo 'master'; break; }
    done
    for branch in ${branches[@]}; do
      [[ $branch == "$version" ]] && { echo $branch; break; }
    done
  else
    for hint in $(ref_dev_fallback "$sku"); do
      # io_trace "branch_list_attach_candidates -- $(print_vars ref sku hint)"
      for branch in ${branches[@]}; do
        [[ $branch == $hint ]] && { echo $branch; break 2; }
      done
    done
    if [[ -n $version ]]; then
      for hint in $(ref_prod_fallback "${sku%/dev}/prod"); do
        # replace prod suffix with vbranch regex
        hint=$(wildcard_to_regex "${hint/%prod/$version}")
        # io_trace "branch_list_attach_candidates -- $(print_vars ref sku hint)"
        for branch in ${branches[@]}; do
          [[ $branch =~ ^$hint ]] && { echo $branch; break 2; }
        done
      done
    fi
  fi
}
# try to attach a detached head to a branch that's pointing at it.
# in:
#   $1:ref
#   $2:sku = bundleDevBranch
#   $3:forceCheckout = true
#   $4:alias = ref
# out:
#   $?:branch_checkout
branch_try_attach()
{

  local ref=$1 sku=$2 forceCheckout=${3:-true} alias=$4
  [[ -z $sku ]] && sku=$bundleDevBranch
  [[ -z $sku ]] && sku=$(branch_current_root_branch)
  [[ -z $alias ]] && alias=$ref

  local branches=( $(branch_list_attach_candidates $ref $sku) )
  # io_trace "branch_try_attach -- $(print_vars ref sku forceCheckout alias branches[@])"
  if [ ${#branches[@]} -eq 0 ]; then
    branch_checkout "$ref" $forceCheckout "$alias"
  else
    branch_checkout "${branches[0]}" $forceCheckout "$alias"
  fi
}
# Use this method to find the development branch which best matches any superproject branch (dev|prod)
#
# usage:
#   local branch lbranch
#   branch_set_best_match_dev $bundleDevBranch
# in:
#   $1:sku=bundleDevBranch
# out:
#   branch   -- local or remote
#   lbranch  -- local branch
# return:
#   1 -- not found
branch_set_best_match_dev()
{
  branch=''; lbranch=''
  local sku=${1:-$bundleDevBranch} patterns branches remoteIndex pattern b i
  patterns=( $(ref_dev_fallback $sku) )
  branches=( $(branch_list_local) )
  remoteIndex=${#branches[@]}
  branches+=( $(branch_list_remote_untracked) )

  # io_trace "branch_set_best_match_dev -- ${*@Q} -- $(print_vars patterns[@] branches[@])"
  # try to find a branch matching bundle branch name
  for pattern in "${patterns[@]}"; do
    for i in ${!branches[@]}; do
      b=${branches[i]}
      (( $i < $remoteIndex )) && lbranch=$b || lbranch=${b#*/}
      [[ $lbranch == $pattern ]] && {
        branch=$b
        return 0
      }
    done
  done
  return 1
}
