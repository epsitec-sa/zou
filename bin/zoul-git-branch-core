#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core
ZOUL_GIT_BRANCH_CORE=true

[[ -z $ZOUL_CORE ]]       && . zoul-core
[[ -z $ZOUL_GIT_REF ]]    && . zoul-git-ref
[[ -z $ZOUL_GIT_CORE ]]   && . zoul-git-core
[[ -z $ZOUL_GIT_REPO ]]   && . zoul-git-repo

# global options
#   showSwitchingMessage

branchChangedEvent=()
branch_raise_branch_changed_event() { local handler; for handler in "${branchChangedEvent[@]}"; do $handler "$@"; done; }
# in:
#  lbranch=$1 -- local branch name
# std-out:
#  rbranch    -- remote branch (even if lbranch does not exist)
branch_upstream()
{
  git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null && return 0
  local remote
  for remote in $(git remote); do
    branch_is_remote "$remote/$1" && { echo "$remote/$1"; return 0; }
  done
  return 1
}
# Determine remote branch name
#
# usage:
#  local rbranch
#  branch_set_upstream LBRANCH
# in:
#  lbranch=$1 -- local branch name
# var-out:
#  rbranch    -- remote branch (even if lbranch does not exist)
branch_set_upstream()
{
  rbranch=$(git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null)
  [ $? -eq 0 ] && return 0
  local remote
  for remote in $(git remote); do
    if branch_is_remote "$remote/$1"; then
      rbranch="$remote/$1"
      return 0
    fi
  done
  unset rbranch
  return 1
}
branch_exists()
{
  branch_realize "$1" >/dev/null
  [ $? -le 1 ]
}
branch_is_archived()
{
  local branch=$1 remote=$2
  ref_exists "other/archive/$branch" &>/dev/null && return 0
  [[ -z $remote ]] && remote=$(git_remote)
  [[ -n $remote ]] && ref_exists "$remote/other/archive/$branch"
}
branch_list_local()     { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_local_at()
{
  # io_trace "branch_list_local_at ${*@Q}"
  git show-ref --heads | grep $(git_get_commit $1) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,';
}
branch_list_remote()    { git for-each-ref --format='%(refname:short)' refs/remotes | grep -v '/HEAD$'; }
branch_list_remote_at() { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep 'refs/remotes' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_list_all()       { git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | grep -v '/HEAD$'; }
branch_list_all_at()    { git show-ref | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_is_attached()    { git symbolic-ref --short -q HEAD &>/dev/null; }
branch_is_local()       { git show-ref -s --verify "refs/heads/$1" &>/dev/null; }
branch_is_remote()      { git show-ref -s --verify "refs/remotes/$1" &>/dev/null; }
branch_is_prod()        { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_is_current()     { [[ $1 == $(git rev-parse --abbrev-ref HEAD) ]]; }
branch_is_head()
{
  local hash1 hash2
  hash1=$(git rev-parse HEAD 2>/dev/null)
  [ $? -ne 0 ] && return 1
  hash2=$(git_get_commit $1 2>/dev/null)
  [ $? -ne 0 ] && return 1
  [ $hash1 = $hash2 ]
}
branch_current()
{
  local ref=$(git rev-parse --abbrev-ref HEAD)
  echo "$ref"
  branch_is_local "$ref"
}
branch_current_root_branch()
{
  local opwd=$PWD branch ec=0
  cd "$(repo_bundle_root)"
  branch=$(branch_current) || ec=$?
  cd "$opwd"
  echo $branch
  return $ec
}
branch_sync_info()
{
  # io_trace "branch_sync_info ${*@Q}"
  local patterns=() ref
  if [ $# -eq 0 ]; then
    patterns=( 'refs/heads' )
  else
    for ref in "$@"; do
      patterns+=( "refs/heads/$ref" )
    done
  fi
  # io_trace "branch_sync_info -- $(print_vars patterns[@])"
  git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" "${patterns[@]}"
}
branch_list_local_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $l && -n $r ]] && echo $l
  done < <(branch_sync_info)
}
branch_list_remote_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && echo $r
  done < <(branch_sync_info)
}
branch_list_all_tracked()
{
  local l r i
  while read l r i; do
    [[ -n $r ]] && {
      [[ -n $l ]] && echo $l
      echo $r
    }
  done < <(branch_sync_info)
}
branch_list_local_can_delete()
{
  # list local branches that can be removed safely
  local l r i c remote=$(git_remote)
  while read l r i; do
    # exclude branch 'master' and current branch
    [[ -z $c ]] && c=$(wildcard_to_regex ${moduleBranch:-$(branch_current)})
    [[ $l =~ (master|$c) ]] && continue
    # tracking branches
    #   that are merged into tracked branches...
    #   or that have the tracking info broken but are merged in another remote
    if [[ -n $l && -n $r ]] && ([[ $i =~ (=|<) ]] || [[ -z $i && -n $(git branch -r --contains $l) ]]); then
      echo $l
    # archived branches merged in another remote
    elif [[ -n $l ]] && branch_is_archived "$l" "$remote" && [[ -n $(git branch -r --contains $l) ]]; then
      echo $l
    fi
  done < <(branch_sync_info)
}
branch_list_local_untracked()
{
  local branches=( $(branch_list_local) )
  local tracked=( $(branch_list_local_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked()
{
  local branches=( $(branch_list_remote) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_at()
{
  local branches=( $(branch_list_remote_at $1) )
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_all_untracked()
{
  local branches=( $(branch_list_all) )
  local tracked=( $(branch_list_all_tracked) )
  array_remove_array branches[@] tracked[@]
}
branch_list_remote_untracked_flatten()
{
  local b
  for b in $(branch_list_remote_untracked); do
    echo ${b#*/}
  done
}
branch_list_all_flatten()
{
  branch_list_local
  branch_list_remote_untracked_flatten
}
branch_list_all_at_flatten()
{
  local b
  branch_list_local_at $1
  for b in $(branch_list_remote_untracked_at "$1"); do
    echo ${b#*/}
  done
}
branch_list_tracked_flatten()
{
  branch_list_local_tracked
  branch_list_remote_untracked_flatten
}

branch_remove_remote_tracked()
{
  local tracked=( $(branch_list_remote_tracked) )
  array_remove_array $1 tracked[@]
}

# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
# out:
#   return codes:
#     0 -- branch is local
#     1 -- branch is remote
#     2 -- branch does not exists
branch_realize()
{
  local ref=${1:-HEAD}
  if [[ $ref == 'HEAD' ]]; then
    ref=$(git symbolic-ref --short HEAD 2>/dev/null)
    [ $? -ne 0 ] && return 2
  fi
  if branch_is_local "$ref"; then
    echo "$ref"
    return 0
  elif branch_is_remote "$ref"; then
    echo "$ref"
    return 1
  else
    local upstream
    upstream=$(branch_upstream "$ref")
    [ $? -ne 0 ] && return 2
    echo "$upstream"
    return 1
  fi
}
# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
#
# usage:
#   local branch lbranch bref
#   branch_set_realize BRANCH
# in:
#   ref=$1    -- local or remote branch ref
# var-out:
#   branch    -- local branch name (0) if it exists || remote branch name (1) if it exists || empty (2) 
#   lbranch   -- local branch name (even if it does not exist)
#   bref      -- branch reference (refs/heads/$lbranch || refs/remotes/$branch)
# return:
#   0 -- branch is local
#   1 -- branch is remote
#   2 -- branch does not exists
branch_set_realize()
{
  unset branch lbranch bref
  local ref=${1:-HEAD}
  if [[ $ref == 'HEAD' ]]; then
    ref=$(git symbolic-ref --short HEAD 2>/dev/null)
    [ $? -ne 0 ] && return 2
  fi
  if branch_is_local "$ref"; then
    branch=$ref
    lbranch=$branch
    bref="refs/heads/$branch"
    return 0
  elif branch_is_remote "$ref"; then
    branch=$ref
    lbranch=${branch#*/}
    bref="refs/remotes/$branch"
    return 1
  else
    local rbranch
    branch_set_upstream "$ref"
    [ $? -ne 0 ] && return 2
    branch=$rbranch
    lbranch=${branch#*/}
    bref="refs/remotes/$branch"
    return 1
  fi
}

branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }

branch_ensure_local()
{
  if ! branch_is_local $1; then
    git branch "$1" "$(branch_upstream $1)" >/dev/null
  fi
}
branch_ensure_local_vbranch()
{
  local vbranch=$1 vtag=$2 rvbranch
  rvbranch=$(branch_realize "$vbranch")
  case $? in
  0) ;;
  1) local line
     (git branch "$vbranch" "$rvbranch" 2>/dev/null) | \
     while read -r line; do
       [[ -z $line ]] && continue
       io_message "  $line" "$moduleTracePrefix" DarkGray
     done;;
  *) git branch "$vbranch" "$vtag";;
  esac
}

# out:
#   return code
#   0 local branch
#   1 remote branch
#   2 remote branch without prefix
#   3 tag
#   4 other
branch_ref_type()
{
  if git show-ref -s --verify "refs/heads/$1" &>/dev/null; then
    return 0
  elif git show-ref -s --verify "refs/remotes/$1" &>/dev/null; then
    return 1
  elif git show-ref -s --verify "refs/remotes/origin/$1" &>/dev/null; then
    return 2
  elif git show-ref -s --verify "refs/tags/$1" &>/dev/null; then
    return 3
  else
    return 4
  fi
}
branch_checkout()
{
  local ref=$1 always=$2 alias=$3 refType isCurrent

  # io_trace "branch_checkout 1 -- $(print_vars ref always alias)"
  
  [[ $alias == 'HEAD' ]] && unset alias
  branch_ref_type $ref; refType=$?
  case $refType in
    0) branch_is_current $ref; isCurrent=$?;; # local branch
    1) isCurrent=1; ref=$(branch_without_remote_prefix $ref);; # remote branch
    2) isCurrent=1;; # remote branch without remote prefix
    3|4) ref_is_head $ref; isCurrent=$?;; # tag | commit
  esac
  if [[ $isCurrent -ne 0 || $always == true ]]; then
    # compute symbols
    local symType symRef
    case $refType in
      0) symType='branch'; symRef="'$ref'";;
      1|2) symType='new branch'; symRef="'$ref'";;
      3) symType='version'; symRef="($ref)";;
      4) symType='commit'; symRef="($(git rev-parse --short $ref^{})";;
    esac

    # switching message
    [[ $isCurrent -ne 0 && $showSwitchingMessage == true ]] && io_info "Switching to $symType $symRef" "$moduleTracePrefix"

    # io_trace "branch_checkout 2 -- $(print_vars ref always alias refType isCurrent symType symRef)"

    # checkout
    local line color info breakLoop deferIndent indent ec=0
    info=$(git checkout "$ref" 2>&1 >/dev/null); ec=$?

    if [[ $ec -eq 0 && $isCurrent -ne 0 ]]; then
      branch_raise_branch_changed_event $ref
    fi
    
    io_lock_enter
    while read -r line; do
      # [[ -z $line ]] && continue
      if [[ $line =~ ^Switched ]]; then
        color=Green
      elif [[ -z $color ]]; then
        if [[ $line =~ ^Already ]]; then
          color=LightBlue
        elif [[ $line =~ ^HEAD\ is\ now\ at\ ([0-9a-f]+) ]]; then
          commit=${BASH_REMATCH[1]}
          line="Already at '$ref'"
          color=LightBlue
          [[ -z $alias ]] && alias=$ref
        elif [[ $line =~ ^Warning:(.*) ]]; then
          line="${Brown}Warning${NC} : ${DarkGray}${BASH_REMATCH[1]}"
          unset alias
          deferIndent=true
          color=DarkGray
        elif [[ $line =~ ^error ]]; then
          color=Red
        elif [[ $line =~ ^Note:\ checking\ out ]]; then
          line="Switched to $symType $symRef"
          color=Green
          breakLoop=true
        elif [[ $line =~ ^Previous\ HEAD ]]; then
          continue
        else
          color=Gray
        fi
      fi
      branch_io_message_unsafe "$indent$line" "$alias" "$color"
      [[ $deferIndent == true ]] && indent='  '
      unset alias deferIndent
      [[ $breakLoop == true ]] && break
    done <<< "$info"
    io_lock_exit
    return $ec
  fi
}
branch_io_message()
{
  io_lock_enter
  branch_io_message_unsafe "$@"
  io_lock_exit
}
branch_io_message_unsafe()
{
  local message=$1 alias=$2 color=$3
  if [[ -n $alias ]]; then
    local acolor
    if [[ $alias =~ \< ]]; then
      # delta < 0
      acolor=Purple
    elif [[ $alias =~ \> ]]; then
      # delta > 0
      if [[ -n $moduleRoot && $moduleRoot == $bundleRoot ]]; then
        acolor=Cyan
      else
        [[ $alias =~ -@ ]] && acolor=Cyan || acolor=Brown
      fi
    else
      # delta == 0
      acolor=Green
    fi
    message="$message ${!acolor}($alias)"
  fi
  io_message_unsafe "$message" "$moduleTracePrefix" "$color"
}
branch_ensure_remote()
{
  local branch=$1 remote=${2:-origin}
  branch_upstream "$branch" >/dev/null && return 0
  io_eval "git push "$remote" --set-upstream "$branch" 2>/dev/null" : DarkGray
}
branch_force_delete()
{
  local branch=$1 ec=0
  if branch_is_local "$branch"; then
    git branch -D "$branch" >/dev/null 2>&1
  elif branch_is_remote "$branch"; then
    local remote=${branch%%/*} lbranch=${branch#*/}
    git branch --unset-upstream "$lbranch"
    git push --delete --force "$remote" "$lbranch" >/dev/null 2>&1
  fi
}
branch_move()
{
  # io_trace "branch_move ${*@Q}"
  local branch1=$1 branch2=$2 ec=0
  [[ -z "$branch1" || -z "$branch2" ]] && { io_error "branch_move: missing argument[s]" "$moduleTracePrefix"; return 1; }
  [[ $branch1 == $branch2 ]] && return 0
  [[ $branch1 == 'master' ]] && { io_error "branch_move: branch 'master' cannot be renamed" "$moduleTracePrefix"; return 1; }
  branch_exists "$branch2" && { io_error "branch_move: destination branch '$branch2' already exists" "$moduleTracePrefix"; return 1; }

  branch1=$(branch_realize "$branch1"); ec=$?
  if [ $ec -eq 0 ]; then
    # local branch1 exists
    rbranch1=$(branch_upstream "$branch1")
    if [ $? -eq 0 ]; then
      local remote=${rbranch1%%/*}
      # io_trace "branch_move (RENAME BOTH) -- $(print_vars branch1 branch2 rbranch1 remote)"
      # remote branch1 exists : rename both
      local tmpBranch
      if branch_is_current "$branch1"; then
        tmpBranch='zou/branch_move'
        if ! git checkout -b "$tmpBranch" "$branch1" &>/dev/null; then
          git branch -D "$tmpBranch" >/dev/null 2>&1
          repo_require_clean_work_tree 'Cannot move branch[es]'
          return 1
        fi
      fi
      # create branch2 at rbranch1
      git branch "$branch2" "$rbranch1" >/dev/null 2>&1
      # create remote branch2
      git push -u "$remote" "$branch2" >/dev/null 2>&1
      # delete remote branch1
      git push --delete --force "$remote" "$branch1" >/dev/null 2>&1
      # delete local branch1
      git branch -D "$branch1" >/dev/null 2>&1
      # restore active branch (renamed)
      if [[ -n $tmpBranch ]]; then
        branch_checkout "$branch2" >/dev/null 2>&1
        git branch -D "$tmpBranch" >/dev/null 2>&1
        git push --delete --force "$remote" "$tmpBranch" >/dev/null 2>&1
      fi
    else
      # remote branch1 does not exist : rename local only
      # io_trace "branch_move (RENAME LOCAL ONLY) -- $(print_vars branch1 branch2)"
      git branch -m "$branch1" "$branch2"
    fi 
  elif [ $ec -eq 1 ]; then
    # local branch1 does not exist : rename remote only
    local remote=${branch1%%/*}
    # io_trace "branch_move (RENAME REMOTE ONLY) -- $(print_vars branch1 branch2 remote)"
    # create branch2 at rbranch1
    git branch "$branch2" "$branch1" >/dev/null 2>&1
    # create remote branch2
    git push -u "$remote" "$branch2" >/dev/null 2>&1
    # delete remote branch1
    git push --delete --force "$remote" "${branch1#*/}" >/dev/null 2>&1
    # delete local branch2
    git branch -D "$branch2" >/dev/null 2>&1
    branch2="$remote/$branch2"
  else
    io_error "branch_move: branch '$branch1' does not exist" "$moduleTracePrefix"
    return 1
  fi
  io_success "Moved branch '$branch1' to '$branch2'" "$moduleTracePrefix"
}
# in:
#   $1:branchOrTag
# out:
#   hintType -- (dev|prod)
branch_set_hint_type()
{
  hintType=${1##*/}
  [[ $hintType == 'dev' || $hintType == 'prod' ]] && return 0
  [[ $hintType =~ ^(.*/)?v?[0-9]+\.[0-9]+ ]] && { hintType='prod'; return 0; }
  hintType='dev'
}
branch_list_attach_candidates()
{
  # io_trace "branch_list_attach_candidates ${*@Q}"
  local ref=$1 sku=$2 branches folder version hint branch
  
  if vtag_is_semver $ref; then
    folder=${BASH_REMATCH[1]}
    version="${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
    if [[ -n $folder ]]; then
      branches=()
      hint=$(wildcard_to_regex $folder)
      for branch in $(branch_list_all_at_flatten $ref); do
        [[ $branch =~ ^$hint ]] && branches+=( $branch )
      done
    else
      branches=( $(branch_list_all_at_flatten $ref) )
    fi
  else
    branches=( $(branch_list_all_at_flatten $ref) )
  fi
  [ ${#branches[@]} -eq 0 ] && return 0
  
  # io_trace "branch_list_attach_candidates -- $(print_vars ref sku branches[@])"
  if [[ $sku == 'master' ]]; then
    for branch in ${branches[@]}; do
      [[ $branch == 'master' ]] && { echo 'master'; break; }
    done
    for branch in ${branches[@]}; do
      [[ $branch == "$version" ]] && { echo $branch; break; }
    done
  else
    for hint in $(ref_dev_fallback "$sku"); do
      # io_trace "branch_list_attach_candidates -- $(print_vars ref sku hint)"
      for branch in ${branches[@]}; do
        [[ $branch == $hint ]] && { echo $branch; break 2; }
      done
    done
    if [[ -n $version ]]; then
      for hint in $(ref_prod_fallback "${sku%/dev}/prod"); do
        # replace prod suffix with vbranch regex
        hint=$(wildcard_to_regex "${hint/%prod/$version}")
        # io_trace "branch_list_attach_candidates -- $(print_vars ref sku hint)"
        for branch in ${branches[@]}; do
          [[ $branch =~ ^$hint ]] && { echo $branch; break 2; }
        done
      done
    fi
  fi
}
# try to attach a detached head to a branch that's pointing at it.
# in:
#   $1:ref
#   $2:sku = bundleBranch
#   $3:forceCheckout = true
#   $4:alias = ref
# out:
#   $?:branch_checkout
branch_try_attach()
{

  local ref=$1 sku=$2 forceCheckout=${3:-true} alias=$4
  [[ -z $sku ]] && sku=$bundleBranch
  [[ -z $sku ]] && sku=$(branch_current_root_branch)
  [[ -z $alias ]] && alias=$ref

  local branches=( $(branch_list_attach_candidates $ref $sku) )
  # io_trace "branch_try_attach -- $(print_vars ref sku forceCheckout alias branches[@])"
  if [ ${#branches[@]} -eq 0 ]; then
    branch_checkout "$ref" $forceCheckout "$alias"
  else
    branch_checkout "${branches[0]}" $forceCheckout "$alias"
  fi
}
