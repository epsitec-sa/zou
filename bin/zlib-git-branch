#! /bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

. zlib-git-repo

branch_current()     { git rev-parse --abbrev-ref HEAD; }
branch_list_local()  { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_remote() { git for-each-ref --format='%(refname:short)' refs/remotes; }
branch_list_all()    { branch_list_local; branch_list_remote; }
branch_list_local_at() { git show-ref --heads | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,'; }
branch_list_all_at() { git show-ref | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_upstream()    { git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null; }
branch_sync_info()   { git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" refs/heads "$@"; }
branch_is_attached() { git symbolic-ref --short -q HEAD >/dev/null; }
branch_is_remote()   { branch_list_remote | grep -q "$1"; }
branch_is_head()     { [ $(git rev-parse HEAD^{}) = $(git rev-parse $1^{}) ]; }
branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }

branch_merge_in_memory()
{
  local r=$1 l=$2 mbase=$(git merge-base $r $l)
  git merge-tree $mbase $l $r
}
branch_merge_dry_run()
{
  local conflicts=$(branch_merge_in_memory "$@")
  echo "$conflicts" | grep -q -E '^[+-\ ]>{7}' && return 1 || return 0
}
branch_merge_interactive()
{
  local ec=0
  git mergetool >/dev/null || ec=1
  if (( $ec == 0 )); then
    git commit --no-edit >/dev/null
    git push &>/dev/null
  fi
  # clean temp merge files
  repo_list_untracked | grep -E '(\.orig$|_(BACKUP|BASE|LOCAL|REMOTE)_[0-9]+)' | xargs --no-run-if-empty rm --
  return $ec
}
branch_push()
{
  local r=$1 l=$2
  git push ${r%%/*} $l &>/dev/null
}
branch_merge()
{
  local r=$1 l=$2 ec=0
  # try fast-forward merge
  if ! branch_merge_ff $l $r &>/dev/null; then
    # fast forward failed
    # on active branch...
    if branch_is_head $l; then
      # ... merge even if conflicts
      if ! git merge $r &>/dev/null; then
        if repo_is_merging; then
          branch_merge_interactive || {
            local conflicts=$(git diff)
            io_error "while auto-merging $r into $l."
            io_message >&2 "$(echo "$conflicts" | sed 's/^/  /')" '' Red
            io_message >&2 "  configure your mergetool and run 'git sync' again" '' LightCyan
            io_message >&2 "  ... or finaliuze the merge using the following commands:" '' LightCyan
            io_message >&2 "    <merge-tool>" '' Brown
            io_message >&2 "    git commit --no-edit" '' DarkGray
            io_message >&2 "    git push" '' DarkGray
          }
        else
          ec=$?
        fi
      fi
    # on inactive branch check if there will be merge conflicts before switching
    else
      if branch_merge_dry_run $r $l; then
        # no conflicts: merge
        git checkout $l &>/dev/null && {
          git merge $r &>/dev/null || ec=$?
          git checkout - &>/dev/null || ec=$?
        }
      else
        git checkout $l &>/dev/null && {
          git merge $r &>/dev/null || branch_merge_interactive ||
          {
            local conflicts=$(git diff)
            io_error "while auto-merging $r into $l."
            io_message >&2 "$(echo "$conflicts" | sed 's/^/  /')" '' Red
            io_message >&2 "  configure your mergetool and run 'git sync' again" '' LightCyan
            io_message >&2 "  ... or merge $r into $l using the following commands:" '' LightCyan
            io_message >&2 "    git checkout $l" '' DarkGray
            io_message >&2 "    git pull" '' DarkGray
            io_message >&2 "    <merge-tool>" '' Brown
            io_message >&2 "    git commit --no-edit" '' DarkGray
            io_message >&2 "    git push" '' DarkGray
            io_message >&2 "    git checkout -" '' DarkGray
            git merge --abort
          }
          git checkout - &>/dev/null || ec=$?
        }

      fi
    fi
  fi
  (( $ec == 0 )) || io_error "while merging $r branch"
  return $ec
}
branch_sync()
{
  local r=$1 l=$2
  branch_merge $r $l && branch_push $r $l
}

branch_list_attach_candidates()
{
  if ! branch_is_attached; then
    local branches=($(branch_list_all_at $1))
    local l r i b
    while read l r i; do
        for i in "${!branches[@]}"; do
          if [[ ${branches[i]} == $r ]]; then
            unset 'branches[i]'
          fi
        done
    done < <(branch_sync_info)
    # get local name of remote branch (origin/wip -> wip)
    for b in ${branches[@]}; do
      echo $(branch_without_remote_prefix $b)
    done
  fi
}
branch_attach()
{
  # attach a detached head to the unique local branch that's pointing at
  if ! branch_is_attached; then
    local branches=($(branch_list_attach_candidates $1))
    if (( ${#branches[@]} == 1 )); then
      git checkout ${branches[0]} &>/dev/null
    fi
  fi
}

branch_sync_all()
{
#   io_info branch_sync_all
  local moduleId=$(repo_module_id)
  repo_require_clean_work_tree "synchronize [$moduleId]" || return 1
  git fetch --prune --all &>/dev/null
  while read l r i; do
    case $i in
      '>')  color=Brown;;  # ahead
      '<')  color=Yellow;; # behind
      '<>') color=Yellow;; # ahead and behind
      '=')  color=Green;;
      *) color=DarkGray
    esac
    io_message "$l $i $r" "[$moduleId] synchronizing" $color
    case $i in
      '>')  branch_push $r $l || return 1;; # ahead
      '<')  branch_merge $r $l || return 1;; # behind
      '<>') branch_sync $r $l || return 1;; # ahead and behind
    esac
  done < <(branch_sync_info)
  git submodule update --recursive # --remote
  branch_attach
}

# https://stackoverflow.com/questions/3216360/merge-update-and-pull-git-branches-without-using-checkouts
branch_merge_ff() {
    local branch=$1
    local commit=$2

    local branch_orig_hash=$(git show-ref -s --verify refs/heads/$branch 2>/dev/null)
    if [ $? -ne 0 ]; then
        io_error "unknown branch $branch"
        return 1
    fi

    local commit_orig_hash="$(git rev-parse --verify $commit 2> /dev/null)"
    if [ $? -ne 0 ]; then
        io_error "unknown revision $commit"
        return 1
    fi

    if [ "$(git symbolic-ref HEAD)" = "refs/heads/$branch" ]; then
        git merge --ff-only "$commit"
    else
        if [ "$(git merge-base $branch_orig_hash $commit_orig_hash)" != "$branch_orig_hash" ]; then
            io_error "merging $commit into $branch would not be a fast-forward"
            return 1
        fi
        io_info "Updating ${branch_orig_hash:0:7}..${commit_orig_hash:0:7}"
        if git update-ref -m "merge $commit: Fast forward" "refs/heads/$branch" "$commit_orig_hash" "$branch_orig_hash"; then
            if [ -z $quiet ]; then
                echo "Fast forward"
                git diff --stat "$branch@{1}" "$branch"
            fi
        else
            io_error "fast forward using update-ref failed"
            return 1
        fi
    fi
}