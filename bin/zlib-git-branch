#! /bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/

. zlib-git-repo

branch_current()     { git rev-parse --abbrev-ref HEAD; }
branch_list_local()  { git for-each-ref --format='%(refname:short)' refs/heads/*; }
branch_list_remote() { git for-each-ref --format='%(refname:short)' refs/remotes/origin/*; }
branch_list_all()    { branch_list_local; branch_list_remote; }
branch_upstream()    { git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null; }
branch_sync_info()   { git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" refs/heads "$@"; }

branch_push()
{
  local r=$1 l=$2
  git push ${r%%/*} $l &>/dev/null
}
branch_pull()
{
  local r=$1 l=$2 ec=0
  git fetch ${r%%/*} $l:$l &>/dev/null || {
    git checkout $l &>/dev/null
    if ! git pull ${r%%/*} $l &>/dev/null; then
        ec=$?
        io_error 'your have unmerged paths.'
        io_message >&2 "$(repo_list_unmerged | sed 's/^/  /')" '' Red
        io_message >&2 "  fix conflicts and run 'git commit'." '' Yellow
        return $ec
    fi
    git checkout - &>/dev/null;
  }
  return $ec
}
branch_sync()
{
  local r=$1 l=$2
  branch_pull $r $l && branch_push $r $l
}

branch_sync_all()
{
#   io_info branch_sync_all
  repo_require_clean_work_tree 'synchronize' || return 1
  git fetch --prune --all &>/dev/null
  while read l r i; do
    case $i in
      '>')  color=Brown;;  # ahead
      '<')  color=Yellow;; # behind
      '<>') color=Yellow;; # ahead and behind
      '=')  color=Green;;
    esac
    io_message "$l $i $r" 'synchronizing' $color
    case $i in
      '>')  branch_push $r $l || return 1;; # ahead
      '<')  branch_pull $r $l || return 1;; # behind
      '<>') branch_sync $r $l || return 1;; # ahead and behind
    esac
  done < <(branch_sync_info)
}

# https://stackoverflow.com/questions/3216360/merge-update-and-pull-git-branches-without-using-checkouts
branch_merge_ff() {
    local branch=$1
    local commit=$2

    local branch_orig_hash=$(git show-ref -s --verify refs/heads/$branch 2>/dev/null)
    if [ $? -ne 0 ]; then
        io_error "unknown branch $branch"
        return 1
    fi

    local commit_orig_hash="$(git rev-parse --verify $commit 2> /dev/null)"
    if [ $? -ne 0 ]; then
        io_error "unknown revision $commit"
        return 1
    fi

    if [ "$(git symbolic-ref HEAD)" = "refs/heads/$branch" ]; then
        git merge --ff-only "$commit"
    else
        if [ "$(git merge-base $branch_orig_hash $commit_orig_hash)" != "$branch_orig_hash" ]; then
            io_error "merging $commit into $branch would not be a fast-forward"
            exit 1
        fi
        io_info "Updating ${branch_orig_hash:0:7}..${commit_orig_hash:0:7}"
        if git update-ref -m "merge $commit: Fast forward" "refs/heads/$branch" "$commit_orig_hash" "$branch_orig_hash"; then
            if [ -z $quiet ]; then
                echo "Fast forward"
                git diff --stat "$branch@{1}" "$branch"
            fi
        else
            io_error "fast forward using update-ref failed"
        fi
    fi
}