#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select
ZOUL_GIT_BRANCH_SELECT=true

[[ -z $ZOUL_GIT_REF ]]         && . zoul-git-ref
[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_VTAG ]]        && . zoul-git-vtag
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

branch_ensure_current()
{
  local branch=$(git rev-parse --abbrev-ref HEAD)
  if ! branch_is_local "$branch"; then
    branch=$(branch_select "$bundleBranch" 'dev')
  fi
  echo $branch
}
# Use this method to find the development branch which best matches
# any superproject branch (dev|prod)
branch_best_match_dev()
{
  local patterns=$(ref_dev_fallback $1) \
        branches=( $(branch_list_local) ) \
        remoteIndex=${#branches[@]}
        
  branches+=( $(branch_list_remote_untracked) )
  local pattern i branch lbranch
  # try to find a branch matching bundle branch name
  for pattern in $patterns; do
    for i in ${!branches[@]}; do
      branch=${branches[i]}
      (( $i < $remoteIndex )) && lbranch=$branch || lbranch=${branch#*/}
      [[ $lbranch == $pattern ]] && {
        echo $branch
        return 0
      }
    done
  done
  return 1
}
branch_best_match_prod()
{
  local target=$1 branch
  branch=$(branch_realize $target 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo $branch
  else
    vtag_get_vbranch_name $(vtag_describe $(branch_best_match_dev $target))
  fi
}
branch_best_match()
{
  local target=$1 hint=$2
  if [[ $hint == 'prod' ]]; then
    vtag_get_vbranch_name $(vtag_describe $(branch_best_match_dev $target))
  elif [[ $hint == 'dev' ]]; then
    branch_best_match_dev $target
  else
    if branch_is_prod $target; then
      branch_best_match_prod $target
    else
      branch_best_match_dev $target
    fi
  fi
}
branch_select()
{
  local rootBranch=$1 hint=$2 showCheckout=${3:-true} bestMatch
  [[ -z $rootBranch ]] && io_error 'branch_select: specify a branch to match' && return 1
  bestMatch=$(branch_best_match $rootBranch $hint)

  # io_trace "branch_select ${*@Q} -> $bestMatch"
  
  branch_checkout "$bestMatch" $showCheckout >/dev/null
  if ! branch_upstream $bestMatch >/dev/null; then
    git push -u origin $bestMatch &>/dev/null
  fi
  echo $bestMatch
  if [ $? -ne 0 ]; then
    repo_require_clean_work_tree 'cannot select'
    return 1
  fi
}
branch_select_vtag()
{
  # io_trace "branch_select_vtag ${*@Q}"

  local branch=$1 ltag stag lsuf vtag
  branch=$(branch_realize $1)
  if ! branch_is_local $branch; then
    branch=$(branch_list_local_at $branch | head -n1)
  fi
  ltag=$(vtag_describe "$branch") || {
    echo $branch
    return 2  # no vtag
  }

  [[ -z $ltag ]] && {
    io_error "No vtag found for branch '$branch'" "$moduleTracePrefix"
    return 2  # no vtag
  }

  stag=${ltag%-*-g*}
  vtag=$(vtag_most_recent $stag)
  # trace_method branch_select_vtag stag vtag
  if vtag_is_vnode $vtag; then
    echo $vtag
    return 2  # vnode
  fi

  if [[ $vtag == $stag ]]; then
    lsuf=${ltag#$stag}
    if [[ -z $lsuf ]]; then
      branch_try_attach "$vtag" 'dev'
      echo $stag
      return 1  # branch == vtag
    fi
  fi

  if git merge-base --is-ancestor "$branch" "$vtag" >&2; then
    echo $vtag
    return 3  # vtag is more recent
  fi

  branch_try_attach "$vtag" 'dev' || branch_checkout "$vtag"
  repo_update_submodules
  echo $vtag
  return 0  # switch to vtag ( or vbranch )
}
