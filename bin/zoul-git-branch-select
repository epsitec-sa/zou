#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select
ZOUL_GIT_BRANCH_SELECT=true

[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_VTAG ]]        && . zoul-git-vtag
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

# csm = children selection mode (enabled/disabled)
# modify .zou-flow configuration file
#
# csm_disable master
#   [select]
#     default = enabled
#     disabled = master
#
# csm_enable master
#   [select]
#     default = disabled
#     enabled = master

csm_get_default()
{
  git config --file "$ZOU_FLOW_CONFIG" --get 'select.default' || {
    repo_is_root && echo 'enabled' || echo 'disabled'
  }
}
csm_set_default()
{
  local default=${1:-enabled}
  git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.$default"
  git config --file "$ZOU_FLOW_CONFIG" 'select.default' $default
}

# csm_enable
#   [select]
#     default = enabled
# csm_enable master
#   [select]
#     default = disabled
#     enabled = master
csm_enable()
{
  local branch branchLabel
  if [ $# -eq 0 ]; then
    branchLabel='all branches'
    csm_set_default 'enabled'
    git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.disabled" &>/dev/null
  else
    branchLabel="branch '$branch'"
    csm_set_default 'disabled'
    for branch in "$@"; do
      git config --file "$ZOU_FLOW_CONFIG" --add 'select.enabled' "$branch" &>/dev/null
    done
  fi
  git update-index --add -- "$ZOU_FLOW_CONFIG" &>/dev/null && \
  git commit -m "zou-flow: enable child selection mode for $branchLabel" -- "$ZOU_FLOW_CONFIG" &>/dev/null
}
# csm_disable
#   [select]
#     default = disabled
# csm_disable master
#   [select]
#     default = enabled
#     disabled = master
csm_disable()
{
  local branch branchLabel
  if [ $# -eq 0 ]; then
    branchLabel='all branches'
    csm_set_default 'disabled'
    git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.enabled" &>/dev/null
  else
    branchLabel="branch '$branch'"
    csm_set_default 'enabled'
    for branch in "$@"; do
      git config --file "$ZOU_FLOW_CONFIG" --add 'select.disabled' "$branch" &>/dev/null
    done
  fi
  git update-index --add -- "$ZOU_FLOW_CONFIG" &>/dev/null && \
  git commit -m "zou-flow: disable child selection mode for $branchLabel" -- "$ZOU_FLOW_CONFIG" &>/dev/null
}
csm_is_disabled()
{
  local branch=${1:-$(branch_current)}
  local default=$(csm_get_default)
  if [[ $default == 'enabled' ]]; then
    git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.disabled' "$branch" &>/dev/null || return 1
  else
    git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.enabled' "$branch" &>/dev/null && return 1 || return 0
  fi
}
csm_status()
{ 
  local default=$(csm_get_default) branch
  io_message "\n  default = $default" "child selection mode"
  if [[ $default == 'enabled' ]]; then
    for branch in $(git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.disabled'); do
      io_message "  disabled = $branch" ''
    done
  else
    for branch in $(git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.enabled'); do
      io_message "  enabled = $branch" ''
    done
  fi
}
branch_scan_sku()
{
  echo $1
  local name00=$1 name10=$1
  local name01=${1#*/} name11=${1%/*}
  while [[ $name00 != $name01 ]]; do
    echo $name01
    name00=$name01
    name01=${name01#*/}
    echo $name11
    name10=$name11
    name11=${name11%/*}
  done
}
# Convert any branch (dev or prod) to a fallback list of development branches.
#   branch:: kind[/name][/mode]
#   kind:: word
#   name:: word[/word]...
#   mode:: 'dev' | n.n
# example:
#   master                kind = master
#   sku/sal/dev           kind = sku, name = sal,              mode = dev
#   sku/sal/13.1          kind = sku, name = sal,              mode = 13.1  (prod)
#   sku/compta/mch/dev    kind = sku, name = compta/mch,       mode = dev
#   wip/zou/git-commands  kind = wip, name = zou/git-commands, mode = 
branch_dev_fallback()
{
  local branch=$1 kind name mode

  kind=${branch%%/*}
  mode=${branch##*/}
  io_debug kind

  if [[ $mode =~ ^(dev|[0-9]+\.[0-9]+)$ ]]; then
    # mode is dev or prod
    io_debug mode
    if [[ $mode == $branch ]]; then
      echo 'dev'
      echo 'master'
      return 0
    fi

    name=${branch#*/}
    name=${name%/*}
    [[ $name == $mode ]] && name=""
    [[ $mode != 'dev' ]] && mode=""
    io_debug name

    if [[ -z $name ]]; then
      echo "$kind/dev"
    else
      for name in $(branch_scan_sku $name); do
        echo "$kind/$name/dev"
      done
      [[ "$kind/dev" != "$branch" ]] && echo "$kind/dev"
    fi
  else
    # mode not defined
    name=${branch#*/}
    [[ $name == $kind ]] && name=""
    io_debug name
    if [[ -n $name ]]; then
      for name in $(branch_scan_sku $name); do
        echo "$kind/$name/dev"
      done
    fi
    echo "$kind/dev"
  fi
  [[ $branch != master ]] && echo master
}
# Convert any branch to a fallback list of regex patterns.
branch_dev_patterns()
{
  local branch
  for branch in $(branch_dev_fallback $1); do
    regex_whole $(regex_escape $branch)
  done
}
# Use this method to find the development branch which best matches
# any superproject branch (dev|prod)
branch_best_match_dev()
{
  local patterns=$(branch_dev_patterns $1)
  local branches=( $(branch_list_local_tracked) )
  local remoteIndex=${#branches[@]}
  branches+=( $(branch_list_remote_untracked) )
  local pattern i branch lbranch
  # try to find a branch matching bundle branch name
  for pattern in $patterns; do
    for i in ${!branches[@]}; do
      branch=${branches[i]}
      (( $i < $remoteIndex )) && lbranch=$branch || lbranch=${branch#*/}
      [[ $lbranch =~ $pattern ]] && {
        echo $branch
        return 0
      }
    done
  done
  return 1
}
branch_best_match_prod()
{
  local branch
  branch=$(branch_realize $1 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo $branch
  else
    local dev=$(branch_best_match_dev $1)
    local ltag=$(vtag_describe $dev)
    vtag_get_vbranch_name $ltag
  fi
}
branch_is_prod() { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_best_match()
{
  local target=$1
  if branch_is_prod $target; then
    branch_best_match_prod $target
  else
    branch_best_match_dev $target
  fi
}
branch_select()
{
  local branch=$1
  [[ -z $branch ]] && io_error 'branch_select: specify a branch to match' && return 1
  local bestMatch=$(branch_best_match $branch)
  local info=$(branch_checkout "$bestMatch" 2>&1)
  if [ $? -ne 0 ]; then
    repo_require_clean_work_tree 'cannot select'
    return 1
  else
    [[ -n $info ]] && io_info "$info" "[$(repo_module_id)]"
  fi
  echo "$bestMatch"
}
