#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select
ZOUL_GIT_BRANCH_SELECT=true

[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_VTAG ]]        && . zoul-git-vtag
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

# csm = children selection mode (enabled/disabled)
# modify .zou-flow configuration file
#
# csm_disable master
#   [select]
#     default = enabled
#     disabled = master
#
# csm_enable master
#   [select]
#     default = disabled
#     enabled = master

csm_get_default()
{
  git config --file "$ZOU_FLOW_CONFIG" --get 'select.default' || {
    repo_is_root && echo 'enabled' || echo 'disabled'
  }
}
csm_set_default()
{
  local default=${1:-enabled}
  local actualDefault
  actualDefault=$(csm_get_default)
  if [[ $default != $actualDefault ]]; then
    git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.$actualDefault"
    git config --file "$ZOU_FLOW_CONFIG" 'select.default' $default
  else
    return 1 # no change
  fi
}

# csm_enable '*'
#   [select]
#     default = enabled
#     disabled = master
# csm_enable '**'
#   [select]
#     default = enabled
# csm_enable master
#   [select]
#     default = disabled
#     enabled = master
csm_enable()
{
  set -f
  local branch=$1 branchLabel='all branches'
  [[ -z $branch ]] && branch="$(branch_current)"
  if [[ $branch == '*' ]]; then
    csm_set_default 'enabled'
  elif [[ $branch == '**' ]]; then
    csm_set_default 'enabled'
    git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.disabled" &>/dev/null
  else
    branchLabel="'$branch' only"
    csm_set_default 'disabled'
    git config --file "$ZOU_FLOW_CONFIG" --add 'select.enabled' "$branch" &>/dev/null
  fi
  git update-index --add -- "$ZOU_FLOW_CONFIG" &>/dev/null && \
  git commit -m "zou-flow: enable select for $branchLabel" -- "$ZOU_FLOW_CONFIG" &>/dev/null
  set +f
}
# csm_disable '*'
#   [select]
#     default = disabled
#     enabled = master
# csm_disable '**'
#   [select]
#     default = disabled
# csm_disable master
#   [select]
#     default = enabled
#     disabled = master

csm_disable()
{
  set -f
  local branch=$1 branchLabel='all branches'
  [[ -z $branch ]] && branch="$(branch_current)"
  if [[ $branch == '*' ]]; then
    csm_set_default 'disabled'
  elif [[ $branch == '**' ]]; then
    csm_set_default 'disabled'
    git config --file "$ZOU_FLOW_CONFIG" --unset-all "select.enabled" &>/dev/null
  else
    branchLabel="'$branch' branch"
    csm_set_default 'enabled'
    git config --file "$ZOU_FLOW_CONFIG" --add 'select.disabled' "$branch" &>/dev/null
  fi
  git update-index --add -- "$ZOU_FLOW_CONFIG" &>/dev/null && \
  git commit -m "zou-flow: disable select for $branchLabel" -- "$ZOU_FLOW_CONFIG" &>/dev/null
  set +f
}
csm_is_disabled()
{
  set -f
  local branch=${1:-$(branch_current)} ec=0
  local default=$(csm_get_default)
  if [[ $default == 'enabled' ]]; then
    git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.disabled' "$branch" &>/dev/null
    ec=$?
  else
    git config --file "$ZOU_FLOW_CONFIG" --get-all 'select.enabled' "$branch" &>/dev/null
    [ $? -eq 0 ] && ec=1
  fi
  set +f
  return $ec
}
# Convert a development branch to a fallback list of development branches.
branch_dev_fallback()
{
  local branch=$1
  if [[ $branch =~ ^([^/]+)/(.+)$ ]]; then
    local kind=${BASH_REMATCH[1]}; io_debug kind
    local config=${BASH_REMATCH[2]}; io_debug config
    case $kind in
      sku|wip|issue) echo $branch;;
    esac
    if [[ $config =~ ^([^/]+)/(.*)$ ]]; then
      local product=${BASH_REMATCH[1]}; io_debug product
      config=${BASH_REMATCH[2]}; io_debug config
      case $kind in
        sku|wip|issue) echo "$kind/$config";;
        *) echo $branch;;
      esac
      if [[ $config =~ ^([^/]+)/(.*)$ ]]; then
        local subkind=${BASH_REMATCH[1]}; io_debug subkind
        config=${BASH_REMATCH[2]}; io_debug config
        case $subkind in
          sku|wip|issue) echo "$subkind/$config";;
          *) echo $branch;;
        esac
      fi
    fi
  fi
  echo 'master'
}
# Convert any branch (dev or prod) to a fallback list of development branches.
branch_best_match_dev_fallback()
{
  local branch=$1
  [[ $debug == true ]] && io_message "$branch" 'branch_best_match_dev_fallback' Brown >&2
  if [[ $branch =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]]; then
    # prod branch
    local prefix=${BASH_REMATCH[1]}
    io_debug prefix
    local version=${BASH_REMATCH[2]}
    io_debug version
    [[ -z $prefix ]] && branch_dev_fallback 'master' || branch_dev_fallback "${prefix}dev"
  else
    branch_dev_fallback $branch
  fi
}
# Convert any branch to a fallback list of regex patterns.
branch_best_match_dev_patterns()
{
  local branch
  for branch in $(branch_best_match_dev_fallback $1); do
    regex_whole $(regex_escape $branch)
  done
}
# Use this method to find the development branch which best matches
# any superproject branch (dev|prod)
branch_best_match_dev()
{
  local patterns=( $(branch_best_match_dev_patterns $1) )
  local branches=( $(branch_remove_tracked) )
  # try to find a branch matching bundle branch name
  for pattern in "${patterns[@]}"; do
    for candidate in "${branches[@]}"; do
      local lcandidate=$(branch_without_remote_prefix $candidate)
      [[ $lcandidate =~ $pattern ]] && {
        echo $candidate
        return 0
      }
    done
  done
  return 1
}
branch_best_match_prod()
{
  local branch
  branch=$(branch_realize $1 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo $branch
  else
    local dev=$(branch_best_match_dev $1)
    local ltag=$(vtag_describe $dev)
    vtag_get_vbranch_name $ltag
  fi
}
branch_is_prod() { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_best_match()
{
  local target=$1
  if branch_is_prod $target; then
    branch_best_match_prod $target
  else
    branch_best_match_dev $target
  fi
}
branch_select()
{
  local branch=$1
  [[ -z $branch ]] && io_error 'branch_select: specify a branch to match' && return 1
  local bestMatch=$(branch_best_match $branch)
  branch_checkout "$bestMatch" 2>/dev/null
  if [ $? -ne 0 ]; then
    repo_require_clean_work_tree 'cannot select'
    return 1
  fi
  echo "$bestMatch"
}
