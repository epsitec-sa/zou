#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core
ZOUL_GIT_CORE=true

[[ -z $ZOUL_CORE ]] && . zoul-core

# Tokenize other refs
# in:
#   $1:ref
# out:
#  ${BASH_REMATCH[0]} -- ref
#  ${BASH_REMATCH[1]} -- system folder
#  ${BASH_REMATCH[2]} -- archive subfolder
#  ${BASH_REMATCH[2]} -- ref
ref_is_other()   { [[ $1 =~ ^other/(.*)$ ]]; }
ref_is_archive() { [[ $1 =~ ^other/archive/(.*)$ ]]; }
ref_is_orphan()  { [[ $1 =~ ^other/orphan(.*)$ ]]; }
ref_is_marker()  { [[ $1 =~ ^other/marker/(.*)$ ]]; }
ref_is_oldver()  { [[ $1 =~ ^other/oldver/(.*)$ ]]; }     # non semver version tag + big patch (more than 3 digits)
ref_exists()     { git rev-parse --quiet --verify $1 >/dev/null; }
ref_equals()     { [[ $(git rev-parse $1^{} 2>/dev/null) == $(git rev-parse $2^{} 2>/dev/null) ]]; }
ref_is_head()    { [[ $(git rev-parse $1^{} 2>/dev/null) == $(git rev-parse HEAD) ]]; }
ref_is_current() { [[ $1 == $(git rev-parse --abbrev-ref HEAD) ]]; }
ref_rename()     { [[ $1 =~ ^(.*/)? ]] && echo "${BASH_REMATCH[1]}$2"; }
ref_symbol()
{
  local commit=${1:-HEAD} ref
  # io_trace "ref_symbol 1 -- $(print_vars commit)"
  ref=$(git rev-parse --abbrev-ref "$commit" 2>/dev/null)
  if [ $? -ne 0 ] || [[ -z $ref || $ref == 'HEAD' ]]; then
    local tags=( $(git tag --points-at "$commit" 2>/dev/null) )
    if [ ${#tags[@]} -eq 0 ]; then
      ref="$(git rev-parse --short "$commit" 2>/dev/null)"
    else
      ref=${tags[-1]}
    fi
    echo "$ref"
    # io_trace "ref_symbol 2 -- $(print_vars commit ref tags[@])"
    return 1
  else
    echo "$ref"
    # io_trace "ref_symbol 3 -- $(print_vars commit ref)"
  fi
}

ref_timespan()
{
  local t0 t1
  t0=$(git show -s --format=%ct $1^{} 2>/dev/null) || return $?
  t1=$(date +%s)
  echo $(( t1 - t0 ))
}

git_remote()     { git remote | head -n1; }

git_get_commit()
{
  # io_trace "git_get_commit ${*@Q}"
  local rev=${1:-HEAD}
  git rev-parse "${rev}^{commit}"
}
git_symbolic_ref()
{
  # io_trace "git_symbolic_ref ${*@Q}"
  if [[ -z $1 || $1 == 'HEAD' ]]; then
    git symbolic-ref --short HEAD 2>/dev/null || echo 'HEAD'
  else
    echo $1
  fi
}
git_object_exists() { git cat-file -e "$1" &>/dev/null; }
git_object_type()   { git cat-file -t "$1" 2>/dev/null; }

git_user_abbrev()
{
  local user=${1:-$(git config user.name)} atom abbrev
  for atom in ${user//-/ }; do 
    abbrev="${abbrev}${atom:0:1}"
  done
  echo ${abbrev,,}
}
