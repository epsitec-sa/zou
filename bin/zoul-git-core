#!/usr/bin/env bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core
ZOUL_GIT_CORE=true

[[ -z $ZOUL_CORE ]] && . zoul-core

gitx_clone()     { local IFS=$'\n'; gitx clone $(gitx_cache_option) "$@"; }
gitx_sm_update() { local IFS=$'\n'; gitx submodule update $(gitx_cache_option) "$@"; }
gitx_sm_add()    { local IFS=$'\n'; gitx submodule add $(gitx_cache_option) "$@"; }

gitx_cache_option()
{ 
  if [[ -n $GIT_CACHE_DIR ]]; then
    echo '--reference'
    echo "$GIT_CACHE_DIR"
  fi
}

# Tokenize other refs
# in:
#   $1:ref
# out:
#  ${BASH_REMATCH[0]} -- ref
#  ${BASH_REMATCH[1]} -- system folder
#  ${BASH_REMATCH[2]} -- archive subfolder
#  ${BASH_REMATCH[2]} -- ref
ref_is_other()   { [[ $1 =~ ^other/(.*)$ ]]; }
ref_is_archive() { [[ $1 =~ ^other/archive/(.*)$ ]]; }
ref_is_orphan()  { [[ $1 =~ ^other/orphan(.*)$ ]]; }
ref_is_marker()  { [[ $1 =~ ^other/marker/(.*)$ ]]; }
ref_is_oldver()  { [[ $1 =~ ^other/oldver/(.*)$ ]]; }     # non semver version tag + big patch (more than 3 digits)
ref_exists()     { gitx rev-parse --quiet --verify $1 &>>"$stdallRedir"; }
ref_equals()     { [[ $(gitx rev-parse $1^{} 2>>"$stderrRedir") == $(gitx rev-parse $2^{} 2>>"$stderrRedir") ]]; }
ref_is_head()    { [[ $(gitx rev-parse $1^{} 2>>"$stderrRedir") == $(gitx rev-parse HEAD 2>>"$stderrRedir") ]]; }
ref_is_current() { [[ $1 == $(gitx rev-parse --abbrev-ref HEAD 2>>"$stderrRedir") ]]; }
ref_rename()     { [[ $1 =~ ^(.*/)? ]] && echo "${BASH_REMATCH[1]}$2"; }
ref_list_all_at(){ gitx show-ref --dereference 2>>"$stderrRedir" | grep $(git_get_commit $1) | cut -d ' ' -f2 | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,; s,\^{}$,,'; }

# usage:
#   cd <submodule-parent>
#   local smref=$(ref_submodule_ref <submodule-name> [<parent-commish>])
# in:
#   $1: submodule name
#   $2: submodule parent commish (default to HEAD)
# out:
#   submodule SHA1
ref_get_submodule_ref() { gitx rev-parse ${2:-HEAD}^{commit}:"$1" 2>>"$stderrRedir"; }
# usage:
#   local refSymbol refType
#   ref_set_symbol REF
# in:
#   $1:commit
# out:
#   refSymbol
#   refType     -- (branch|tag|sha)
ref_set_symbol()
{
  local commit=${1:-HEAD}
  refType='branch'
  # io_trace "ref_set_symbol 1 -- $(print_vars commit)"
  refSymbol=$(gitx rev-parse --abbrev-ref "$commit" 2>>"$stderrRedir")
  if [ $? -ne 0 ] || [[ -z $refSymbol || $refSymbol == 'HEAD' ]]; then
    local tags=( $(gitx tag --points-at "$commit" 2>>"$stderrRedir") )
    if [ ${#tags[@]} -eq 0 ]; then
      refSymbol="$(gitx rev-parse --short "$commit" 2>>"$stderrRedir")"
      refType='sha'
    else
      refSymbol=${tags[-1]}
      refType='tag'
    fi
  elif [[ 'tag' == $(git_object_type "$refSymbol") ]]; then
    refType='tag'
  fi
  # io_trace "ref_set_symbol 2 -- $(print_vars commit tags[@] refSymbol refType)"
}
ref_type()
{
  local refSymbol refType
  ref_set_symbol "$@"
  echo $refType
}

ref_timespan()
{
  local t0 t1
  t0=$(ref_time $1) || return $?
  t1=$(date +%s)
  echo $(( t1 - t0 ))
}
ref_time()
{
  echo $(gitx show -s --format=%ct $1^{} 2>>"$stderrRedir")
}

git_dir() { gitx -C "${1:-.}" rev-parse --absolute-git-dir; }

git_remote()  { gitx remote 2>>"$stderrRedir" | head -n1; }
git_remotes() { gitx remote 2>>"$stderrRedir"; }

git_get_commit()
{
  # io_trace "git_get_commit ${*@Q}"
  local rev=${1:-HEAD}
  gitx rev-parse "${rev}^{commit}" 2>>"$stderrRedir"
}
git_symbolic_ref()
{
  # io_trace "git_symbolic_ref ${*@Q}"
  if [[ -z $1 || $1 == 'HEAD' ]]; then
    gitx symbolic-ref --short HEAD 2>>"$stderrRedir" || echo 'HEAD'
  else
    echo $1
  fi
}
git_object_exists() { gitx cat-file -e "$1" &>>"$stdallRedir"; }
git_object_type()   { gitx cat-file -t "$1" 2>>"$stderrRedir"; }

git_user_abbrev()
{
  local user=${1:-$(gitx config user.name 2>>"$stderrRedir")} atom abbrev
  for atom in ${user//-/ }; do 
    abbrev="${abbrev}${atom:0:1}"
  done
  echo ${abbrev,,}
}

# Usage:
#   local message=( 'title' 'content 1' 'content 2')
#   git_commit [<options>] 'message[@]' file1 file2
git_commit()
{
  # io_trace "git_commit ${*@Q}"
  while [[ $1 =~ ^-- ]]; do
    options+=( "$1" ); shift
  done

  local _messages_ version header footer content
  if [[ "$1" =~ \[@\]$ ]]; then
    _messages_=( "${!1}" )
  else
    _messages_=( "$1" )
  fi
  # io_trace "git_commit -- $(print_vars _messages_[@])"

  shift
  header="zou-flow: ${_messages_[0]}"
  content=( "${_messages_[@]:1}" )
  # insert '- ' to beginning of all content lines
  for i in ${!content[@]}; do
    [[ "${content[i]}" =~ \- ]] || content[i]="- ${content[i]}"
  done
  # concat zou-flow version
  io_set_version
  content+=( "- zou-flow (v$version)" )
  printf -v footer '%s \n' "${content[@]}"
  # io_trace "git_commit -- $(print_vars header content[@] footer)"
  gitx add -- "$@" &>>"$stdallRedir" \
  && gitx commit -m "$header" -m "$footer" "${options[@]}" &>>"$stdallRedir"
}
