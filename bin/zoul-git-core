#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core
ZOUL_GIT_CORE=true

[[ -z $ZOUL_CORE ]] && . zoul-core

# Tokenize other refs
# in:
#   $1:ref
# out:
#  ${BASH_REMATCH[0]} -- ref
#  ${BASH_REMATCH[1]} -- system folder
#  ${BASH_REMATCH[2]} -- archive subfolder
#  ${BASH_REMATCH[2]} -- ref
ref_is_other()   { [[ $1 =~ ^other/(.*)$ ]]; }
ref_is_archive() { [[ $1 =~ ^other/archive/(.*)$ ]]; }
ref_is_orphan()  { [[ $1 =~ ^other/orphan(.*)$ ]]; }
ref_is_marker()  { [[ $1 =~ ^other/marker/(.*)$ ]]; }
ref_is_oldver()  { [[ $1 =~ ^other/oldver/(.*)$ ]]; }     # non semver version tag + big patch (more than 3 digits)
ref_exists()     { git rev-parse --quiet --verify $1 >/dev/null; }
ref_equals()     { [[ $(git rev-parse $1^{}) == $(git rev-parse $2^{}) ]]; }
ref_is_head()    { [[ $(git rev-parse $1^{}) == $(git rev-parse HEAD) ]]; }

ref_timespan()
{
  local t0 t1
  t0=$(git show -s --format=%ct $1^{} 2>/dev/null) || return $?
  t1=$(date +%s)
  echo $(( t1 - t0 ))
}

git_remote()     { git remote | head -n1; }

git_get_commit()
{
  # io_trace "git_get_commit ${*@Q}"
  local rev=${1:-HEAD}
  git rev-parse "${rev}^{commit}"
}
git_symbolic_ref()
{
  # io_trace "git_symbolic_ref ${*@Q}"
  if [[ -z $1 || $1 == 'HEAD' ]]; then
    git symbolic-ref --short HEAD 2>/dev/null || echo 'HEAD'
  else
    echo $1
  fi
}
git_object_exists() { git cat-file -e "$1" &>/dev/null; }
git_object_type()   { git cat-file -t "$1" 2>/dev/null; }
