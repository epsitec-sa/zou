#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_REF ]] && . zoul-git-ref
ZOUL_GIT_REF=true

# Use the following functions to generate fallbacks for zou-flow refs (branches and vtags).
# Fallbacks can be generated to:
# - find submodule dev branch that match bundle branch
# - generate vtag matching pattern for git describe
#
# Exemple:
#   A fallback to find a matching dev branch for `sku/compta/mch/(dev|13.2)`
#   has the following form:
#
#   sku/compta/mch/(dev|13.2) ->
#     sku/compta/mch/dev
#     compta/mch/dev
#     sku/mch/dev
#     mch/dev
#     sku/dev
#     master
#
# Algorithm:
#   We first split a branch ref into an array of ref atoms:
#     sku/compta/mch/dev -> (sku compta mch dev)
#   Then we shift left array and subarray of atoms until only one element remains.
#   Finally, we combine both outputs, sort by atom count and join back them with '/' separator.

# join ref atoms with '/'
# sku sal dev -> sku/sal/dev
ref_join() { local IFS='/'; echo "$*"; }

# scan ref atoms:
#   shift left until only the last element remains
#   return each shift
# sku sal dev ->
#   sku sal dev
#   sal dev
#   dev
ref_scan_shift_left_0()
{
  local IFS=' ' i
  # echo ref_scan_shift_left_0 "[$#] ${*@Q}" >&2
  for (( i=1; i<=$#; i++ )); do
    echo "${@:$i}"
  done
}
# scan ref atoms:
#   shift right until only the first element remains
#   return each shift
# sku sal dev ->
#   sku sal dev
#   sku sal
#   sku
ref_scan_shift_right_0()
{
  local IFS=' ' i
  # echo ref_scan_shift_right_0 "[$#] ${*@Q}" >&2
  for (( i=$#; i>0; i-- )); do
    echo "${@:1:$i}"
  done
}
# scan ref atoms:
#   keep first atom (sku, wip...) and shift left tail.
# sku compta mch dev ->
#   sku compta mch dev
#   sku mch dev
#   sku dev
ref_scan_shift_left_1()
{
  local IFS=$'\n' 
  local first=$1 i
  for i in $(ref_scan_shift_left_0 "${@:2}"); do
    echo $first $i
  done
}
# scan ref atoms:
#   keep last atom (dev, 1.0, v1.0.0) and shift right head.
# sku compta mch dev ->
#   sku compta mch dev
#   sku compta dev
#   sku dev
ref_scan_shift_right_1()
{
  local IFS=$'\n' 
  local last=${@:(-1)} i
  # negative offset won't work
  local count; (( count = $# - 1 ))
  for i in $(ref_scan_shift_right_0 "${@:1:$count}"); do
    echo $i $last
  done
}
# combine scans of ref atoms
# sku compta mch dev ->
#   scan 1
#     sku compta mch dev
#     sku compta dev
#     sku dev
#   scan 2
#     sku mch dev
ref_scan_algo()
{
  # scan 1: keep first atom and shift tail left
  ref_scan_shift_right_1 "${@}"
  # scan 2: keep last atom and shift head right
  ref_scan_shift_left_1 "${@}" | tail -n +2 | head -n -1
}
# scan ref atoms and insert count in front to be able to sort by count
# sku compta mch dev ->
#   4 sku compta mch dev
#   3 sku compta dev
#   2 sku dev
#   3 sku mch dev
ref_scan_insert_count()
{
  local IFS=$'\n' i a
  for i in $(ref_scan_algo "$@"); do
    # convert to array to compute word count (faster than using wc -w)
    IFS=' '; a=( $i )
    # insert count in front 
    echo ${#a[@]} $i
  done
}
# scan ref atoms sort by count and join:
# sku compta mch dev ->
#   sku/compta/mch/dev
#   sku/compta/dev
#   sku/mch/dev
#   sku/dev
ref_scan_sort_join()
{
  # echo ref_scan_sort_join "[$#] ${*@Q}" >&2
  if (( $# <= 1 )); then
    ref_join $@
  else
    local IFS=$'\n' a
    for a in $(ref_scan_insert_count "$@" | sort -n -s -r | cut -d' ' -f2-); do
      IFS=' '; ref_join $a
    done
  fi
}
# scan ref and sort by atoms count:
# sku/compta/mch/dev ->
#   sku/compta/mch/dev
#   sku/compta/dev
#   sku/mch/dev
#   sku/dev
ref_split_scan_join()
{
  # echo ref_scan "[$#] ${*@Q}" >&2
  local IFS=' ';
  local atoms=( ${1//\// } )
  ref_scan_sort_join ${atoms[@]}
}
# split ref, convert prod branch to dev and adjust master:
# ref_dev_fallback sku/compta/mch/13.2 ->
#   sku/compta/mch/dev
#   sku/compta/dev
#   sku/mch/dev
#   sku/dev
#   master
ref_dev_fallback()
{
  local IFS=' ';
  local atoms=( ${1//\// } ) a b
  [[ ${atoms[-1]} =~ ^[0-9]+\.[0-9]+$ ]] && atoms[-1]='dev'

  a=( $(ref_scan_sort_join "${atoms[@]}") )
  if [[ ${a[-1]} == 'dev' ]]; then
    a[-1]='master'
  elif [[ ${a[-1]} != 'master' ]]; then
    a+=( 'master' )
  fi
  for b in ${a[@]}; do
    echo $b
  done
}
# scan ref and return tag fallback patterns
# Exemple for git describe:
# ref_tag_fallback sku/compta/mch/dev 'v[0-9]*' ->
#   sku/compta/mch/v[0-9]*
#   sku/compta/v[0-9]*
#   sku/mch/v[0-9]*
#   sku/v[0-9]*
#   v[0-9]*
ref_tag_fallback()
{
  local IFS=' ';
  local atoms=( ${1//\// } ) tag=$2
  # echo ref_tag_fallback ${atoms[@]@Q} >&2
  # accept vtags, dev and prod branches
  if [[ ${atoms[-1]} == 'dev' || ${atoms[-1]} =~ ^v?[0-9]+\.[0-9]+ ]]; then
    atoms[-1]="$tag"
    ref_scan_sort_join "${atoms[@]}"
  fi
  echo "$tag"
}
ref_vtag_describe_fallback()
{
  ref_tag_fallback $1 'v[0-9]*'
}
# scan ref and return prod fallback
# ref_prod_fallback sku/compta/mch/(prod|13.2)
#   sku/sal/prod
#   sal/prod
#   sku/prod
#   prod
ref_prod_fallback()
{
  local IFS=' ';
  local atoms=( ${1//\// } )
  # accept vtags and prod branches
  if [[ ${atoms[-1]} == 'prod' ]]; then
    ref_scan_sort_join "${atoms[@]}"
  elif [[ ${atoms[-1]} =~ ^v?[0-9]+\.[0-9]+ ]]; then
    atoms[-1]="prod"
    ref_scan_sort_join "${atoms[@]}"
  else
    return 1
  fi
  echo 'prod'
}
