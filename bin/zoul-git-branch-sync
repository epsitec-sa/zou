#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_SYNC ]] && . zoul-git-branch-sync
ZOUL_GIT_BRANCH_SYNC=true

[[ -z $ZOUL_GIT_REPO ]]         && . zoul-git-repo
[[ -z $ZOUL_GIT_BRANCH_CORE ]]  && . zoul-git-branch-core
[[ -z $ZOUL_GIT_BRANCH_MERGE ]] && . zoul-git-branch-merge

# global options
#   syncNoPush

branchSyncEvent=()
_branch_raise_branch_sync_event() { local handler; for handler in "${branchSyncEvent[@]}"; do $handler "$@"; done; }

_branch_sync_push()
{
  [[ $syncNoPush == true ]] && return 0
  # l > r -- move r
  local r=$1 l=$2
  git push --follow-tags ${r%%/*} $l &>/dev/null
}
_branch_sync_merge()
{
  local r=$1 l=$2
  branch_merge "$r" "$l"
}
_branch_sync_sync()
{
  local r=$1 l=$2
  branch_merge "$r" "$l" && \
  _branch_sync_push "$r" "$l"
}
_branch_sync_visitor()
{
  local r=$1 l=$2 i=$3 current=$4
  # io_trace "_branch_sync_visitor -- $(print_vars r l i)"
  case $i in
    '>')  _branch_sync_push  "$r" "$l" || return 1;; # l > r ahead   -- move r
    '<')  _branch_sync_merge "$r" "$l" || return 1;; # l < r behind  -- move l
    '<>') _branch_sync_sync  "$r" "$l" || return 1;; # ahead and behind
    *) return 0;;
  esac
  [[ $l == $current ]] && _branch_raise_branch_sync_event "$r" "$l" "$i" || return 0
}
_branch_oreset_visitor()
{
  local r=$1 l=$2 i=$3 current=$4
  # io_trace "_branch_reset_visitor 1 -- $(print_vars r l i current)"

  [[ -z $r || $(git rev-parse "$l") == $(git rev-parse "$r") ]] && return 0
  # pull changes
  [[ $i =~ ^\< ]] && { _branch_sync_merge "$r" "$l" || return 1; }
  # reset to upstream
  if [[ $l == $current ]]; then
    # prune tags asynchronously
    (
      io_warning "Pruning tags..." "$moduleTracePrefix"
      git tag -d $(git tag -l) &>/dev/null
      git fetch --tags &>/dev/null
    ) &
    git reset --hard @{u} >/dev/null
    _branch_raise_branch_sync_event "$r" "$l" "$i"
  else
    # reset ref
    git update-ref "refs/heads/$l" "$r" >/dev/null
  fi
}
_branch_sync_visit() 
{
  local visitor=$1 fixTracking=$2 current=$moduleBranch color l r i; shift 2
  [[ -z $current ]] && current=$(branch_current)

  if [[ $fixTracking == true ]]; then
    while read l r i; do
      [[ -z $i ]] && _branch_sync_fix_tracking
    done < <(branch_sync_info "$@")
  fi

  while read l r i; do
    [[ $l == $current ]] && linfo="* $l"
    case $i in
      '>')  [[ $l == $current ]] && color=Yellow      || color=Brown;;   # ahead
      '<')  [[ $l == $current ]] && color=Yellow      || color=Brown;;   # behind
      '<>') [[ $l == $current ]] && color=LightPurple || color=Purple;;  # ahead and behind
      '=')  [[ $l == $current ]] && color=LightGreen  || color=Green;;
    esac
    $visitor "$r" "$l" "$i" "$current" || return $?
    local linfo=$(string_pad_right 18 $l)
    [[ $l == $current ]] && linfo="* $linfo" || linfo="  $linfo"
    [[ $syncNoPush == true && $i =~ '>' ]] && color=DarkGray
    io_message "$linfo $(string_pad_right 2 $i) $r" "$moduleTracePrefix" $color
  done < <(branch_sync_info "$@")
  return 0
}
_branch_sync_fix_tracking()
{
  if [[ -n $r ]]; then
    # tracking branch was deleted or renamed
    if branch_is_current "$l"; then
      # detach head
      git checkout "$l^{}" &>/dev/null
    fi
    if git branch -d "$l" &>/dev/null; then
      io_message "  Deleted obsolete branch '$l'" "$moduleTracePrefix" DarkGray
    else
      git branch --unset-upstream "$l"
      color=LightBlue
    fi
  else
    # no tracking info
    if [[ $l =~ ^sku/ ]] || branch_is_prod "$l"; then
      # automatically push sku vbranches
      local remote=$(git_remote)
      [[ -n $remote ]] && ! branch_is_archived "$l" "$remote" && branch_ensure_remote "$l" "$remote"
    else
      # branch has no tracking info
      color=LightBlue
    fi
  fi
}
branch_sync_all()
{
  git fetch --prune --all &>/dev/null
  git fetch --tags --force &>/dev/null

  branch_merge_abort
  repo_require_clean_work_tree 'Cannot synchronize' || return 1

  _branch_sync_visit _branch_sync_visitor true "$@"
}
branch_oreset_all()
{
  local forceReset=$1; shift 1
  
  git fetch --prune --all &>/dev/null
  git fetch --tags --force &>/dev/null

  branch_merge_abort
  if [[ $forceReset == true ]]; then
    git checkout . &>/dev/null
    repo_list_untracked | xargs --no-run-if-empty rm
  else
   repo_require_clean_work_tree 'Cannot reset' || return 1
  fi

  syncNoPush=true _branch_sync_visit _branch_oreset_visitor false "$@"
}