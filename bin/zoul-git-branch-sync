#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH_SYNC ]] && . zoul-git-branch-sync
ZOUL_GIT_BRANCH_SYNC=true

[[ -z $ZOUL_GIT_REPO ]]         && . zoul-git-repo
[[ -z $ZOUL_GIT_BRANCH_CORE ]]  && . zoul-git-branch-core
[[ -z $ZOUL_GIT_BRANCH_MERGE ]] && . zoul-git-branch-merge

_branch_sync_push()
{
  # l > r -- move r
  local r=$1 l=$2
  git push --follow-tags ${r%%/*} $l &>/dev/null
}
_branch_sync_merge()
{
  branch_merge "$@"
}
_branch_sync_sync()
{
  _branch_sync_merge "$@" && _branch_sync_push "$@"
}
_branch_sync_visitor()
{
  local r=$1 l=$2 i=$3 attachHint=$4
  case $i in
    '>')  _branch_sync_push  $r $l || return 1;; # l > r ahead   -- move r
    '<')  _branch_sync_merge $r $l || return 1;; # l < r behind  -- move l
    '<>') _branch_sync_sync  $r $l || return 1;; # ahead and behind
  esac
}
_branch_sync_visit() 
{
  local visitor=$1 attachHint=$2 isCurrent current=$moduleBranch; shift 2
  [[ -z $current ]] && current=$(branch_current)

  while read l r i; do
    [[ $l == $current ]] && linfo="* $l"

    $visitor $r $l $i $attachHint || return 1
    case $i in
      '>'|'<'|'<>') [[ $l == $current ]] && color=Yellow     || color=Brown;;  # ahead, behind, ahead and behind
      '=')          [[ $l == $current ]] && color=LightGreen || color=Green;;
      *)
        if [[ -n $r ]]; then
          # tracking branch was deleted or renamed
          i='?'
          color=Red
        else
          # nothing tracked
          if branch_is_prod "$l"; then
            # automatically track vbranches
            local remote=$(git remote)
            branch_push $l $remote && {
              r="$remote/$l"
              i='>'
              [[ $l == $current ]] && color=Yellow || color=Brown
            }
          else
            color=LightBlue
          fi
        fi;;
    esac
    local linfo="  $l"
    [[ $l == $(branch_current) ]] && linfo="* $l"
    if [[ $i == '?' ]]; then
      if [[ $cleanLocalBranches == true ]]; then
        io_message "$linfo $i $r (delete pending)" "$moduleTracePrefix" $color
      else
        io_message "$linfo $i $r" "$moduleTracePrefix" $color

        io_message "  Remote branch $r was deleted or renamed." "$moduleTracePrefix"
        io_message "  Either rename $l and update its tracking information:" "$moduleTracePrefix"
        io_message "    git branch -m $l <newbranch>" "$moduleTracePrefix" Gray
        io_message "    git branch -u <upstream> <newbranch>" "$moduleTracePrefix" Gray
        io_message "  Or clean local tracked branches with:" "$moduleTracePrefix"
        io_message "    git sync --clean" "$moduleTracePrefix" Gray
      fi
    else
      io_message "$linfo $i $r" "$moduleTracePrefix" $color
    fi
  done < <(branch_sync_info "$@")
  return 0
}
branch_sync_all()
{
  local attachHint=$1; shift 1

  git fetch --prune --all &>/dev/null
  git fetch --tags --force &>/dev/null
  repo_require_clean_work_tree 'Cannot synchronize' || return 1

  _branch_sync_visit _branch_sync_visitor "$attachHint" "$@"
  repo_discard_clean_submodules_async
  branch_try_attach 'HEAD' "$attachHint" >/dev/null || true
}