#!/usr/bin/env bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_NOTES ]] && . zoul-git-notes
ZOUL_GIT_NOTES=true

# https://gist.github.com/topheman/ec8cde7c54e24a785e5

[[ -z $ZOUL_CORE ]] && . zoul-core

# Available zou channels
# - zou-vtable
# - zou-ops

# Configure fetch and merge strategy
#   merge strategies: ours | theirs | union | cat_sort_uniq
notes_configure()
{
  # configure automatic notes fetching
  local remote
  for remote in $(git_remotes); do
    gitx config --get-all "remote.$remote.fetch" 'notes' &>>"$stdallRedir" || \
    gitx config --add "remote.$remote.fetch" "+refs/notes/*:refs/notes/$remote/*"
  done

  # configure notes merge strategies
  gitx config notes.commits.mergeStrategy union
  gitx config notes.zou-vtable.mergeStrategy ours
  gitx config notes.zou-ops.mergeStrategy cat_sort_uniq
}
notes_is_configured()
{
  [[ -n $(gitx config "notes.zou-vtable.mergeStrategy") ]]
}

# Add a channel note on object
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- the object to annotate
#   ${@:4}      -- additional options (-f)
notes_add()      { io_trace "notes_add ${*@Q}"; gitx notes --ref "$1" add -m "$2" "${3:-HEAD}" ${*:4}; }
notes_add_file() { gitx notes --ref "$1" add -F "$2" "${3:-HEAD}" "${@:5}"; }

# Append a channel note to object
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- default to 'HEAD'
notes_append()      { gitx notes --ref "$1" append -m "$2" "${3:-HEAD}"; }
notes_append_file() { gitx notes --ref "$1" append -F "$2" "${3:-HEAD}"; }

# Remove a channel note
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- default to 'HEAD'
notes_remove() { gitx notes --ref "$1" remove --ignore-missing "${2:-HEAD}"; }

# Display a channel note
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:object   -- default to 'HEAD'
#   -*:option   -- git rev-parse option (--short)
# out:
#   <channel>/<object-SHA>:<note-line>
notes_show()
{
  # io_trace "notes_show -1- ${*@Q}"

  local opts=() args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -*)  opts+=("$1");;
    *)   args+=("$1");;
  esac; shift; done

  local note channel="${args[0]}" object="${args[1]:-HEAD}" IFS=$'\n'
  # io_trace "notes_show -2- $(print_vars opts[@] args[@] channel object)"
  for note in $(gitx notes --ref "$channel" show "$object"); do
    # skip blank lines
    [[ $note =~ ^[[:blank:]]*$ ]] && continue
    echo "$channel/$(gitx rev-parse ${opts[@]} "$object"):$note"
  done
}

# List channel notes
# in:
#   $1:channel  -- notes channel (--ref)
#   -*:option   -- git rev-parse option (--short)
notes_list()
{
  # io_trace "notes_list ${*@Q}"
  local opts=() channel
  while [[ "$#" > 0 ]]; do case "$1" in
    -*) opts+=("$1");;
    *)  channel="$1";;
  esac; shift; done
  [[ -z $channel ]] && channel="$zouNotesChannel"

  # io_trace "notes_list -2- $(print_vars opts[@] channel)"
  for obj in $(notes_objects "$channel"); do
    notes_show "${opts[@]}" "$channel" "$obj"
  done
}
notes_list_all()
{
  # io_trace "notes_list_all ${*@Q}"
  for channel in $(notes_channel_names); do
    notes_list "$channel" "$@"
  done
}

# List objects SHAs that have associated channel notes
# in:
#   $1:channel  -- notes channel (--ref)
# out:
#   object SHA
notes_objects()
{
  local line IFS=$'\n'
  for line in $(gitx notes --ref "$1" list); do
    # 5716ca5 272d938 -> 272d938
    if [[ $line =~ [[:blank:]]+([^[:blank:]]+)$ ]]; then
      echo ${BASH_REMATCH[1]}
    fi
  done
}

# Push all channels to specified remote
# in:
#   $1:remote -- default to 'origin'
notes_push()
{
  # io_trace "notes_push ${*@Q}"
  gitx push ${1:-origin} 'refs/notes/*' &>>"$stdallRedir"
}
notes_push_all()
{
  # io_trace "notes_push_all"
  local remote
  for remote in $(git_remotes); do
    notes_push "$remote"
  done
}

# Fetch all channels from specified remote
# in:
#   $1:channel -- notes channel (--ref)
#   $2:remote  -- default to 'origin'
notes_fetch()
{
  # io_trace "notes_fetch ${*@Q}"
  local channel="$1" remote="${2:-origin}"
  # io_trace "notes_fetch -1- $(print_vars channel remote)"
  gitx fetch "$remote" "refs/notes/$channel:refs/notes/$remote/$channel" &>>"$stdallRedir"
}
notes_fetch_all()
{
  # io_trace "notes_fetch_all"
  local remote
  for remote in $(git_remotes); do
    gitx fetch "$remote" "refs/notes/*:refs/notes/$remote/*" &>>"$stdallRedir"
  done
}

# Merge notes
# in:
#   $1:srcChannel     -- source channel
#   $2:dstChannel     -- destination channel
#   $3:mergeStrategy  -- ours | theirs | union | cat_sort_uniq
#                     -- default are configured in notes_config
#                     -- union         for 'commits' channel
#                     -- cat_sort_uniq for 'zou*'    channel
notes_merge()
{
  # io_trace "notes_pull ${*@Q}"
  local srcChannel="$1" dstChannel="$2" mergeStrategy=$3 mergeOpt
  [[ -n $mergeStrategy ]] && mergeOpt="-s $mergeStrategy"

  # io_trace "notes_merge -1- $(print_vars srcChannel dstChannel mergeStrategy)"
  gitx notes --ref "$srcChannel" merge -v $mergeOpt "$dstChannel" &>>"$stdallRedir"
}

# Pull notes
# in:
#   $1:channel        -- notes channel (--ref)
#   $2:remote         -- default to 'origin'
#   $3:mergeStrategy  -- see notes_merge
notes_pull()
{
  # io_trace "notes_pull ${*@Q}"
  local channel="$1" remote="${2:-origin}" mergeStrategy=$3
  # io_trace "notes_pull -1- $(print_vars channel remote mergeStrategy)"
  notes_fetch "$channel" "$remote"
  notes_merge "$channel" "$remote/$channel" "$mergeStrategy"
  # TODO : use ours or theirs depending on commits dates
}
notes_pull_all()
{
  # io_trace "notes_pull_all"
  local remote channel names
  notes_fetch_all
  names=( $(notes_channel_names) )
  for remote in $(git_remotes); do
    for channel in ${names[@]}; do
      notes_merge "$channel" "$remote/$channel"
    done
  done
}

# List channels names ('commits', ...)
notes_channel_names()
{
  local names=()
  for name in $(gitx for-each-ref --format="%(refname)" refs/notes); do
    name=${name##*/}
    array_contains_element "$name" "${names[@]}" || names+=("$name")
  done
  printf '%s\n' "${names[@]}"
}
