#!/usr/bin/env bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_NOTES ]] && . zoul-git-notes
ZOUL_GIT_NOTES=true

# https://gist.github.com/topheman/ec8cde7c54e24a785e5

[[ -z $ZOUL_CORE ]] && . zoul-core

# Define remote notes ref directory
# make remote notes appear as separate branches in git clients like Fork
notes_remote_ref_dir() { echo "refs/remotes/${1:-origin}/notes"; }

# BUGBUG: uncomment following function to create recursion issue 
# notes_remote_ref_dir() { echo "refs/notes/${1:-origin}"; }

# BUGBUG: repair recursion issue
notes_repair()
{
  local remote ec=0 notesDir="$(git_dir)/refs/notes"
  for remote in $(git_remotes); do
    # io_trace "notes_repair -- $notesDir/$remote"
    if [[ -d "$notesDir/$remote" ]]; then
      rm -rf "$notesDir/$remote"
      gitx config --unset "remote.$remote.fetch" "refs/notes"
      gitx config --add "remote.$remote.fetch" "+refs/notes/*:$(notes_remote_ref_dir "$remote")/*"
      ec=1
    fi
  done
  # tree "$(git_dir)/refs"
  return $ec
}

# Available zou channels
# - zou-vtable
# - zou-ops

# Configure fetch and merge strategy
#   merge strategies: ours | theirs | union | cat_sort_uniq
notes_configure()
{
  # configure automatic notes fetching
  local remote
  for remote in $(git_remotes); do
    gitx config --get-all "remote.$remote.fetch" 'notes' &>>"$stdallRedir" || \
    gitx config --add "remote.$remote.fetch" "+refs/notes/*:$(notes_remote_ref_dir "$remote")/*"
  done

  # configure notes merge strategies
  gitx config notes.commits.mergeStrategy union
  gitx config notes.zou-vtable.mergeStrategy ours
  gitx config notes.zou-ops.mergeStrategy cat_sort_uniq
}
notes_is_configured()
{
  [[ -n $(gitx config "notes.zou-vtable.mergeStrategy") ]]
}

# Add a channel note on object
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- the object to annotate
#   ${@:4}      -- additional options (-f)
notes_add()      { gitx notes --ref "$1" add -m "$2" "${3:-HEAD}" "${@:4}"; }
notes_add_file() { gitx notes --ref "$1" add -F "$2" "${3:-HEAD}" "${@:4}"; }

# Append a channel note to object
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- default to 'HEAD'
notes_append()      { gitx notes --ref "$1" append -m "$2" "${3:-HEAD}"; }
notes_append_file() { gitx notes --ref "$1" append -F "$2" "${3:-HEAD}"; }

# Remove a channel note
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:note     -- the note
#   $3:object   -- default to 'HEAD'
notes_remove() { gitx notes --ref "$1" remove --ignore-missing "${2:-HEAD}"; }

# Display a channel note
# in:
#   $1:channel  -- notes channel (--ref)
#   $2:object   -- default to 'HEAD'
#   -*:option   -- git rev-parse option (--short)
# out:
#   <channel>/<object-SHA>:<note-line>
notes_show()
{
  # io_trace "notes_show -1- ${*@Q}"

  local opts=() args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -*)  opts+=("$1");;
    *)   args+=("$1");;
  esac; shift; done

  local note channel="${args[0]}" object="${args[1]:-HEAD}" IFS=$'\n'
  # io_trace "notes_show -2- $(print_vars opts[@] args[@] channel object)"
  for note in $(gitx notes --ref "$channel" show "$object"); do
    # skip blank lines
    [[ $note =~ ^[[:blank:]]*$ ]] && continue
    echo "$channel/$(gitx rev-parse ${opts[@]} "$object"):$note"
  done
}

# List channel notes
# in:
#   $1:channel  -- notes channel (--ref)
#   -*:option   -- git rev-parse option (--short)
notes_list()
{
  # io_trace "notes_list ${*@Q}"
  local opts=() channel
  while [[ "$#" > 0 ]]; do case "$1" in
    -*) opts+=("$1");;
    *)  channel="$1";;
  esac; shift; done
  [[ -z $channel ]] && channel="$zouNotesChannel"

  # io_trace "notes_list -2- $(print_vars opts[@] channel)"
  for obj in $(notes_objects "$channel"); do
    notes_show "${opts[@]}" "$channel" "$obj"
  done
}
notes_list_all()
{
  # io_trace "notes_list_all ${*@Q}"
  for channel in $(notes_channel_names); do
    notes_list "$channel" "$@"
  done
}

# List objects SHAs that have associated channel notes
# in:
#   $1:channel  -- notes channel (--ref)
# out:
#   object SHA
notes_objects()
{
  local line IFS=$'\n'
  for line in $(gitx notes --ref "$1" list); do
    # 5716ca5 272d938 -> 272d938
    if [[ $line =~ [[:blank:]]+([^[:blank:]]+)$ ]]; then
      echo ${BASH_REMATCH[1]}
    fi
  done
}

# Push all channels to specified remote
# in:
#   $1:remote -- default to 'origin'
notes_push()
{
  # io_trace ">>>> notes_push -- ${*@Q}"
  gitx push ${1:-origin} 'refs/notes/*' &>>"$stdallRedir"
  # io_trace "<<<< notes_push -- ${*@Q}"
}
notes_push_all()
{
  # io_trace ">>>> notes_push_all"
  local remote
  for remote in $(git_remotes); do
    notes_push "$remote"
  done
  # io_trace "<<<< notes_push_all"
}

# Fetch all channels from specified remote
# in:
#   $1:channel -- notes channel (--ref)
#   $2:remote  -- default to 'origin'
notes_fetch()
{
  local channel="$1" remote="${2:-origin}"
  # io_trace ">>>> notes_fetch -- ${*@Q} -- $(print_vars channel remote)"
  gitx fetch "$remote" "refs/notes/$channel:$(notes_remote_ref_dir "$remote")/$channel" &>>"$stdallRedir"
  # io_trace "<<<< notes_fetch -- ${*@Q} -- $(print_vars channel remote)"
}
notes_fetch_all()
{
  local remote
  for remote in $(git_remotes); do
    # io_trace "#### notes_fetch_all-- $(print_vars remote)"
    gitx fetch "$remote" "refs/notes/*:$(notes_remote_ref_dir "$remote")/*" &>>"$stdallRedir"
  done
}

# Merge notes
# in:
#   $1:srcChannel     -- source channel
#   $2:dstChannel     -- destination channel
#   $3:mergeStrategy  -- ours | theirs | union | cat_sort_uniq
#                     -- default are configured in notes_config
#                     -- union         for 'commits' channel
#                     -- cat_sort_uniq for 'zou*'    channel
notes_merge()
{
  local srcChannel="$1" dstChannel="$2" mergeStrategy=$3 mergeOpt
  [[ -n $mergeStrategy ]] && mergeOpt="-s $mergeStrategy"

  # io_trace ">>>> notes_merge -- ${*@Q}"
  gitx notes --ref "$srcChannel" merge -v $mergeOpt "$dstChannel" &>>"$stdallRedir"
  # tree "$(git_dir)/refs"
  # io_trace "<<<< notes_merge -- ${*@Q}"
}

# Pull notes
# in:
#   $1:channel        -- notes channel (--ref)
#   $2:remote         -- default to 'origin'
#   $3:mergeStrategy  -- see notes_merge
notes_pull()
{
  local channel="$1" remote="${2:-origin}" mergeStrategy=$3
  # io_trace ">>>> notes_pull -- ${*@Q} -- $(print_vars channel remote mergeStrategy)"
  notes_fetch "$channel" "$remote"
  notes_merge "$channel" "$(notes_remote_ref_dir "$remote")/$channel" "$mergeStrategy"
  # TODO : use ours or theirs depending on commits dates
  # io_trace "<<<< notes_pull -- ${*@Q} -- $(print_vars channel remote mergeStrategy)"
}
notes_pull_all()
{
  # io_trace ">>>> notes_pull_all"
  local remote channel names
  notes_fetch_all
  names=( $(notes_channel_names) )
  for remote in $(git_remotes); do
    for channel in ${names[@]}; do
      notes_merge "$channel" "$(notes_remote_ref_dir "$remote")/$channel"
    done
  done
  # io_trace "<<<< notes_pull_all"
}

# List channels names ('commits', ...)
notes_channel_names()
{
  local names=()
  for name in $(gitx for-each-ref --format="%(refname)" refs/notes); do
    name=${name##*/}
    array_contains_element "$name" "${names[@]}" || names+=("$name")
  done
  printf '%s\n' "${names[@]}"
}
