#!/bin/bash

[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

wip_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    start|enter)    subcommand=$1;;
    release|finish) subcommand=$1;;
    share)          subcommand=$1;;
    --prod)         wipOnProd=true;;
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'start' 'enter' 'share' 'release' 'finish'

  wipModulePaths=( "$@" )
  wip_parse_wip "${args[@]}"
  cmd_check_args "${args[@]:1}"

  [[ $wipOnProd == true ]] && wipPrefix=${wipPrefix:-hotfix} || wipPrefix=${wipPrefix:-wip}
  wipSuffix=${wipSuffix:-work}
  # io_trace "wip_parse -- $(print_vars recursive wipPrefix wipSuffix subcommand wipModulePaths[@])"
}
wip_parse_wip()
{
  # skip options
  [[ ${1:0:1} != '-' && $1 =~ ^([^:]+:)?([^[:blank:]]*) ]] || return 1
  wipPrefix=${BASH_REMATCH[1]%:}
  wipSuffix=${BASH_REMATCH[2]}
}
wip_run()
{
  # parse command line
  local jobsCount recursive command='wip' subcommand \
        cmdScopes=( prod_scope config_scope ) \
        wipOnProd wipPrefix wipSuffix wipModulePaths=()
        
  wip_parse "$@" || return $?

  case $subcommand in
    start)   startupMessage="Starting ${Brown}$wipPrefix:$wipSuffix${White}, please wait...";;
    enter)   startupMessage="Entering ${Brown}$wipPrefix:$wipSuffix${White}, please wait...";;
    share)   startupMessage="Sharing ${Brown}current WIP${White}, please wait...";;
    release) startupMessage="Releasing WIP, please wait...";;
    finish)  startupMessage="Finishing WIP, please wait...";;
  esac

  module_run "${cmdScopes[@]}" wip_command
}
wip_command()
{
  # io_trace "wip_command -- $(print_vars subcommand wipPrefix wipSuffix wipModulePaths[@])"
  [ ${#wipModulePaths[@]} -eq 0 ] && wipModulePaths+=( './' )
  cmd_register_module_paths "$recursive" "${wipModulePaths[@]}"

  case $subcommand in
    start|enter) cmd_register_module_paths false "$bundleRoot";;
    share)       cmd_register_module_paths true  "$bundleRoot";;
  esac

  cmd_visit_modules
}
wip_start_epilog()
{
  local devBranch=$(wip_to_ref "$moduleDevBranch")
  local wipBranch=$(ref_to_wip "$devBranch" "$wipSuffix" "$wipPrefix")
  if [[ $moduleHead != $wipBranch ]]; then
    if [[ $wipOnProd == true && -n $prodBranchPath ]]; then
      git branch "$wipBranch" "$prodBranchPath" &>/dev/null
    else
      git branch "$wipBranch" "$moduleDevBranchPath" &>/dev/null
    fi
  fi
  branch_checkout "$wipBranch" true
}
wip_enter_epilog()
{
  local devBranch=$(wip_to_ref "$moduleDevBranch")
  local wipBranch=$(ref_to_wip "$devBranch" "$wipSuffix" "$wipPrefix")
  # checkout wip branch if it exists
  if [[ $moduleHead == $wipBranch ]]; then
    branch_checkout "$wipBranch" true
  elif branch_exists "$wipBranch"; then
    branch_checkout "$wipBranch" true
  elif module_is_bundle; then
    mio_error "SKU ${VC}$wipPrefix:$wipSuffix${Red} not found"
  fi
}
wip_share_epilog()
{
  _wip_check_wip_mode || return 0

  branch_ensure_remote "$moduleDevBranch"
}

#########
# RELEASE
#########

wip_release_epilog()
{
  _wip_check_wip_mode || return 0

  local devBranch=$(wip_to_ref $moduleDevBranch)
  local wipBranch=$moduleHead
  # io_trace "wip_release_epilog 1 -- $(print_vars wipBranch devBranch)"
  if [[ $wipBranch != $devBranch ]]; then
    # io_trace "wip_release_epilog 2 -- $(print_vars wipBranch devBranch)"
    # merge, checkout prod || vtag || dev and del wip
    _wip_merge _wip_release_merge_dev _wip_release_merge_prod
  fi
}
# scope: devBranch
_wip_release_merge_dev()
{
  local wipBranch=$1 mergeTarget=$2
  branch_merge "$wipBranch" "$mergeTarget"
}
# scope: devBranch
_wip_release_merge_prod()
{
  local wipBranch=$1 mergeTarget=$2
  branch_merge "$wipBranch" "$mergeTarget" \
  && branch_merge "$wipBranch" "$devBranch"
}

########
# FINISH
########

wip_finish_epilog()
{
  _wip_check_wip_mode || return 0

  local devBranch=$(wip_to_ref $moduleDevBranch)
  local wipBranch=$moduleHead
  # io_trace "wip_finish 1 -- $(print_vars wipBranch devBranch)"
  if [[ $wipBranch != $devBranch ]]; then
    # io_trace "wip_finish 2 -- $(print_vars wipBranch devBranch)"
    # merge, checkout prod || vtag || dev and del wip
    _wip_merge _wip_finish_merge_dev _wip_finish_merge_prod
  fi
}
# scope: devBranch
_wip_finish_merge_dev()
{
  local wipBranch=$1 mergeTarget=$2
  branch_merge "$wipBranch" "$mergeTarget" \
  && dev_checkout true "$devBranch" \
  && branch_delete "$wipBranch"
}
# scope: devBranch
_wip_finish_merge_prod()
{
  local wipBranch=$1 mergeTarget=$2
  branch_merge "$wipBranch" "$mergeTarget" \
  && branch_merge "$wipBranch" "$devBranch" \
  && branch_checkout "$prodBranch" true \
  && branch_delete "$wipBranch"
}

#########
# HELPERS
#########

_wip_check_wip_mode()
{
  module_in_wip_mode && return 0
  mio_warning "Use ${VC}git wip enter${Brown} to switch to WIP mode"
  return 1
}
# scope: wipBranch devBranch
# in:
#   $1:devAction  wipBranch mergeTarget
#   $2:prodAction wipBranch mergeTarget
_wip_merge()
{
  local devAction=$1 prodAction=$2 mergeTarget action
  if branch_is_merged "$wipBranch" "$devBranch"; then
    if [[ $wipOnProd == true && -n $prodBranchPath ]]; then
      mergeTarget=$prodBranchPath
      action=$prodAction
    else
      mergeTarget=$devBranch
      action=$devAction
    fi
  elif [[ -n $prodBranchPath ]]; then
    mergeTarget=$prodBranchPath
    action=$prodAction
  else
    mergeTarget=$devBranch
    action=$devAction
  fi
  # io_trace "$action $wipBranch $mergeTarget"
  $action "$wipBranch" "$mergeTarget"
}

wip_run  "$@"
