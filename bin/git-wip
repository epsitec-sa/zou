#!/bin/bash

[[ -z $ZOUL_GIT_MODULE ]]        && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]]        && . zoul-git-config
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

wip_parse()
{
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    --start)        wipCommand='start'; wip_parse_start $2 && shift;;
    --finish)       wipCommand='finish';;
    --)             shift; wipModulePaths+=("$@"); break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  io_error "invalid argument ${VC}$1${Red}, use ${VC}--${Red} to specify modules paths\n"; io_help $0; return 1;;
  esac; shift; done

  wipPrefix=${wipPrefix:-wip}
  wipSuffix=${wipSuffix:-work}
  # io_trace "wip_parse -- $(print_vars recursive wipPrefix wipSuffix wipFinish wipModulePaths[@])"
  if [[ -z $wipCommand ]]; then
    io_error "missing ${VC}--start${Red} or ${VC}--finish${Red} option\n"
    io_help $0
    exit 0
  fi
}
wip_parse_start()
{
  [[ $1 =~ ^([^-][^:]+:)?([^-]*) ]] || return 1
  wipPrefix=${BASH_REMATCH[1]%:}
  wipSuffix=${BASH_REMATCH[2]}
}
wip_run()
{
  # parse command line
  local jobsCount recursive wipCommand wipPrefix wipSuffix wipModulePaths=()
  wip_parse "$@" || return $?

  local wipScopes=( config_scope cosm_scope )
  
  case $wipCommand in
    start)  startupMessage="Starting wip '$wipSuffix', please wait...";;
    finish) startupMessage="Finishing wip, please wait..."
  esac

  module_run "${wipScopes[@]}" wip_$wipCommand
}
wip_start()
{
  # io_trace "wip_start -- $(print_vars wipPrefix wipSuffix moduleRoot bundleRoot wipModulePaths[@])"

  if [ ${#wipModulePaths[@]} -gt 0 ]; then
    module_visit_submodules_async 'wipModulePaths[@]' "${wipScopes[@]}" 'wip_start_tree'
  else
    wip_start_tree
  fi

  # always create wip SKU
  if ! module_is_bundle; then
    module_visit "$bundleRoot" "${wipScopes[@]}" wip_start_node
  fi
}
wip_start_tree()
{
  # io_trace "wip_start_tree -- $(print_vars wipPrefix wipSuffix moduleRoot bundleRoot wipModulePaths[@])"
  wip_start_submodules || return $?
  wip_start_node
}
wip_start_submodules()
{
  [[ $recursive == true ]] || return 0
  module_visit_submodules_async 'configSelectInclude[@]' "${wipScopes[@]}" 'wip_start_tree'
}
wip_start_node()
{
  local skuBranch=$(ref_wip_to_sku "$moduleBranch")
  local wipBranch=$(ref_sku_to_wip "$skuBranch" "$wipSuffix" "$wipPrefix")
  # io_trace "wip_start_node 1 -- $(prints_vars moduleBranch skuBranch wipBranch)"

  # ensure we are in dev mode in submodules
  if [[ $moduleBranch != $wipBranch && $moduleRoot != $bundleRoot ]]; then
    # switch to dev mode
    local lbranch vbranch vtag htag publishStatus
    branch_set_select_auto "$bundleBranch" true false
    skuBranch=$(ref_wip_to_sku "$moduleBranch")
    wipBranch=$(ref_sku_to_wip "$skuBranch" "$wipSuffix" "$wipPrefix")
    # io_trace "wip_start_node 2 -- $(print_vars moduleBranch skuBranch wipBranch)"
  fi

  # create and checkout wip branch
  if [[ $moduleBranch != $wipBranch ]]; then
    git branch "$wipBranch" &>/dev/null
    branch_checkout "$wipBranch"
    # io_trace "wip_start_node 3 -- $(print_vars wipSuffix moduleBranch skuBranch wipBranch)"
  fi
}

wip_finish()
{
  # io_trace "wip_finish -- $(print_vars moduleRoot bundleRoot)"

  if [ ${#wipModulePaths[@]} -gt 0 ]; then
    module_visit_submodules_async 'wipModulePaths[@]' "${wipScopes[@]}" 'wip_finish_tree'
  else
    wip_finish_tree
  fi
}
wip_finish_tree()
{
  module_is_bundle && recursive=true

  wip_finish_submodules || return $?
  wip_finish_node
}
wip_finish_node()
{
  local skuBranch=$(ref_wip_to_sku $moduleBranch)
  local wipBranch=$moduleBranch
  if [[ $wipBranch != $skuBranch ]]; then
    # repo_require_clean_work_tree 'Cannot finish wip' || return $?
    # io_trace "wip_finish_node -- $(print_vars moduleBranch skuBranch)"
    branch_merge "$wipBranch" "$skuBranch" \
    && branch_checkout "$skuBranch" true \
    && branch_delete "$wipBranch"
  fi
}
wip_finish_submodules()
{
  [[ $recursive == true ]] || return 0
  module_visit_submodules_async 'configSelectInclude[@]' "${wipScopes[@]}" 'wip_finish_tree'
}
wip_run  "$@"
