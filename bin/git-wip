#!/bin/bash

[[ -z $ZOUL_GIT_MODULE ]]        && . zoul-git-module
[[ -z $ZOUL_GIT_CONFIG ]]        && . zoul-git-config
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

wip_parse()
{
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    --start)        wipCommand='start'; wip_parse_wip $2 && shift;;
    --enter)        wipCommand='enter'; wip_parse_wip $2 && shift;;
    --exit)         wipCommand='exit';;
    --finish)       wipCommand='finish';;
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  io_error "invalid argument ${VC}$1${Red}, use ${VC}--${Red} to specify modules paths\n"; io_help $0; return 1;;
  esac; shift; done

  local path
  for path; do
    wipModulePaths+=( "$(realpath "$path")" )
  done
  if [[ -z $wipCommand ]]; then
    io_error "missing command option ${VC}--(start|enter|exit|finish)${Red}\n"
    io_help $0
    exit 0
  fi
  wipPrefix=${wipPrefix:-wip}
  wipSuffix=${wipSuffix:-work}
  # io_trace "wip_parse -- $(print_vars recursive wipPrefix wipSuffix wipCommand wipModulePaths[@])"
}
wip_parse_wip()
{
  # skip options
  [[ ${1:0:1} != '-' && $1 =~ ^([^:]+:)?([^-]*) ]] || return 1
  wipPrefix=${BASH_REMATCH[1]%:}
  wipSuffix=${BASH_REMATCH[2]}
}
wip_run()
{
  # parse command line
  local jobsCount recursive wipCommand wipPrefix wipSuffix wipModulePaths=()
  wip_parse "$@" || return $?

  local wipScopes=( config_scope cosm_scope )
  
  case $wipCommand in
    start)  startupMessage="Starting ${Brown}$wipPrefix:$wipSuffix${White}, please wait...";;
    enter)  startupMessage="Entering ${Brown}$wipPrefix:$wipSuffix${White}, please wait...";;
    exit)   startupMessage="Exiting WIP mode, please wait...";;
    finish) startupMessage="Finishing WIP, please wait...";;
  esac

  module_run "${wipScopes[@]}" wip_command
}

wip_start()
{
  local devBranch wipBranch
  wip_set_branches
  if [[ $moduleBranch != $wipBranch ]]; then
    # create wip branch on dev branch
    [[ $moduleBranch != $devBranch ]] && branch_checkout "$devBranch"
    git branch "$wipBranch" &>/dev/null
  fi
  branch_checkout "$wipBranch" true
}
wip_enter()
{
  local devBranch wipBranch
  wip_set_branches
  # checkout wip branch if it exists
  if [[ $moduleBranch != $wipBranch ]] && branch_exists "$wipBranch"; then
    branch_checkout "$wipBranch" true
  fi
}
wip_exit()
{
  [[ $moduleBranch == 'HEAD' ]] && return 0

  # check if we are in WIP mode
  local devBranch=$(ref_wip_to_dev $moduleBranch)
  local wipBranch=$moduleBranch
  # io_trace "wip_exit 1 -- $(print_vars moduleBranch devBranch)"

  if [[ $wipBranch != $devBranch ]]; then
    # io_trace "wip_exit 2 -- $(print_vars moduleBranch devBranch wipBranch)"
    # back to VTAG mode
    local lbranch vbranch vtag htag publishStatus
    branch_set_select_auto "$devBranch" false false
  fi
}
wip_finish()
{
  [[ $moduleBranch == 'HEAD' ]] && return 0

  local devBranch=$(ref_wip_to_dev $moduleBranch)
  local wipBranch=$moduleBranch
  # io_trace "wip_finish 1 -- $(print_vars moduleBranch devBranch wipBranch)"
  if [[ $wipBranch != $devBranch ]]; then
    # repo_require_clean_work_tree 'Cannot finish wip' || return $?
    # io_trace "wip_finish 2 -- $(print_vars moduleBranch devBranch wipBranch)"
    # back to VTAG mode
    local lbranch vbranch vtag htag publishStatus
    branch_merge "$wipBranch" "$devBranch" \
    && branch_set_select_auto "$devBranch" false false \
    && branch_delete "$wipBranch"
  fi
}
# Infer dev and wip branches
#
# usage:
#   local devBranch wipBranch
#   wip_set_branches
# out:
#   devBranch
#   wipBranch
wip_set_branches()
{
  # check if we are in WIP mode
  devBranch=$(ref_wip_to_dev "$moduleBranch")
  wipBranch=$(ref_dev_to_wip "$devBranch" "$wipSuffix" "$wipPrefix")
  # io_trace "wip_set_branches 1 -- $(print_vars bundleDevBranch moduleBranch devBranch wipBranch)"

  # if we are not in WIP mode, infer dev branch from bundle dev branch
  if [[ $moduleBranch != $wipBranch ]]; then
    local branch lbranch
    devBranch=$(ref_wip_to_dev "$bundleDevBranch")
    branch_set_best_match_dev "$devBranch"  # -> branch lbranch
    devBranch=$lbranch
    wipBranch=$(ref_dev_to_wip "$devBranch" "$wipSuffix" "$wipPrefix")
    # io_trace "wip_set_branches 2 -- $(print_vars bundleDevBranch moduleBranch devBranch wipBranch)"
  fi
}

####################
# COMMAND MANAGEMENT
####################

wip_command()
{
  # io_trace "wip_command -- $(print_vars wipCommand wipPrefix wipSuffix wipModulePaths[@])"
  if [[ $wipCommand =~ (exit|finish) ]] && wip_bundle_visited; then
    recursive=true
  fi

  if [ ${#wipModulePaths[@]} -gt 0 ]; then
    wip_visit_modules wip_tree
  else
    wip_tree
  fi

  if [[ $wipCommand =~ (start|enter) ]] && ! wip_bundle_visited; then
    wip_visit_bundle wip_node
  fi
}
wip_tree()
{
  # io_trace "wip_tree -- $(print_vars wipCommand wipPrefix wipSuffix wipModulePaths[@])"
  repo_discard_internal_ignore_list

  wip_visit_tree || return $?
  wip_node
}
wip_node()
{
  # io_trace "wip_node -- $(print_vars wipCommand wipPrefix wipSuffix wipModulePaths[@])"
  wip_${wipCommand}
}
wip_visit_tree()
{
  [[ $recursive == true ]] || return 0
  module_visit_submodules_async 'configSelectInclude[@]' "${wipScopes[@]}" wip_tree
}
wip_visit_modules()
{
  # io_trace "wip_visit_modules -- ${*@Q} -- $(print_vars wipModulePaths[@])"
  module_visit_submodules_async 'wipModulePaths[@]' "${wipScopes[@]}" "$@"
}
wip_visit_bundle()
{
  # io_trace "wip_visit_bundle -- ${*@Q}"
  module_visit "$bundleRoot" "${wipScopes[@]}" "$@"
}
wip_bundle_visited()
{
  module_is_bundle || array_contains_element "$bundleRoot" "${wipModulePaths[@]}"
}

wip_run  "$@"
