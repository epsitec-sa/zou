#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_PUBLISH ]] && . zoul-git-publish
ZOUL_GIT_PUBLISH=true

[[ -z $ZOUL_GIT_PROD ]]           && . zoul-git-prod
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]   && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_CONFIG_VERSION ]] && . zoul-git-config-version

# io_trace "headChangedEvent+=( publish_reset_scope )"
headChangedEvent+=( _publish_on_head_changed )
branchCreatedEvent+=( _publish_on_branch_created )
branchDeletedEvent+=( _publish_on_branch_deleted )

# usage:
#   module_run prod_scope publish_scope $*
publish_scope()
{
  # setup publish context
  local publishScopeInitialized=true \
        publishBranch publishBranchPath publishVTag publishHTag \
        publishNTag publishPrerelPrefix \
        publishDelta publishVTagStatus publishAlias \
        publishStatus
  
  publish_reset_scope

  # execute next russian doll
  $1 "${@:2}"
}
publish_reset_scope()
{
  [[ $publishScopeInitialized == true ]] || return 0
  [[ -n $prodBranch ]] || return 0

  local branch=$1 lbranch=$2 vbranch vtag htag delta alias status
  branch_set_vtag_info "$prodBranchPath" "$prodBranch" 'auto'
  # io_create_alias_color "$alias"

  publishVTag=$vtag
  publishHTag=$htag
  publishDelta=$delta
  publishAlias=$alias
  publishVTagStatus=$status
  if [[ -z $vbranch ]]; then
    publishBranchPath=''; publishBranch=''
  else
    local branch lbranch bref
    branch_set_realize "$vbranch"
    publishBranchPath=$branch
    publishBranch=$lbranch
  fi
  [[ $publishHTag =~ ^(.*/)?v[0-9]+\.[0-9]+(-@|.([0-9]+))-(alpha|beta|rc)[0-9]+ ]] \
  && publishPrerelPrefix=${BASH_REMATCH[3]}

  _publish_init_status

  # io_lock_enter
  # io_trace_unsafe "publish_reset_scope -- $(print_vars publishStatus publishPrerelPrefix)"
  # io_trace_unsafe "publish_reset_scope -- $(print_vars publishVTag publishHTag publishNTag)"
  # io_trace_unsafe "publish_reset_scope -- $(print_vars publishBranch publishBranchPath)"
  # io_trace_unsafe "publish_reset_scope -- $(print_vars publishDelta publishVTagStatus publishAlias)"
  # io_lock_exit
}
publish_init_next_version()
{
  local prerelPrefix=$1 noIncrement
  # get principal module version
  _publish_refresh_bundle_htag # update publishHTag and noIncrement
  _publish_increment_version "$prerelPrefix" "$noIncrement" # -> publishNTag publishPrerelPrefix

  # io_lock_enter
  # io_trace_unsafe "publish_init_next_version -- $(print_vars publishStatus publishPrerelPrefix)"
  # io_trace_unsafe "publish_init_next_version -- $(print_vars publishVTag publishHTag publishNTag)"
  # io_lock_exit
}
publish_commit()
{
  if [[ $publishPrerelPrefix == 'reuse' ]]; then
    _publish_commit_core
    tag_move "$publishNTag" "$publishBranch"
    # io_trace "publish_commit 1 -- $(print_vars publishPrerelPrefix publishNTag publishBranch)"
  else
    # update technical version
    _publish_commit_core 'version_update'
    local comment="publish branch '$publishBranch' as '$publishNTag'"
    git tag -a -m "zou-flow: $comment" "$publishNTag" "$publishBranch"
    # io_trace "publish_commit 2 -- $(print_vars publishPrerelPrefix publishNTag publishBranch)"
  fi
}
_publish_commit_core()
{
  # io_trace "_publish_commit_core ${*@Q}"
  local updater=$1 vresources=()
  # update technical version - modify resources files
  if [[ -n $updater ]]; then
    # IFS=$'\n' vresources=( $($updater $publishNTag) ); IFS=$OIFS
    vresources=( $($updater $publishNTag) )
  fi
  # io_trace "_publish_commit_core -- $(print_vars updater vresources[@])"
  # commit resources and clean submodules in dev branch
  # version_commit_files "$publishNTag" "${vresources[@]}" $(repo_list_unstaged_clean_submodules)
  version_commit_files "$publishNTag" "${vresources[@]}" ${unstagedCleanSubmodules[@]}
  # branch_merge "$publishBranch" "$moduleDevBranchPath" &>/dev/null
}

# out:
#   publishStatus -- error
#                    unpublishable
#                    published
#                    notPublished
#                    ffPublish
_publish_init_status()
{
  # local lbranch=$1 vtag=$2 delta=$3 status=$4 forceDev=$5
  # # io_trace "branch_set_publish_info -- $(print_vars lbranch vtag status)"
  # nextHead=$lbranch   # default branch to checkout
  publishStatus='error'
  if [[ $status == 'vtagMissing' ]]; then
    # no vtag, stay in dev mode
    publishStatus='unpublishable'
  elif [[ $status == 'vtag' ]]; then
    # published at least once on this vbranch
    if [ $delta -eq 0 ]; then
      # head has not been moved since last publish, stay in dev mode
      publishStatus='published'
    elif [ $delta -gt 0 ]; then
      publishStatus='notPublished'
    else
      # prod branch is behind vtag
      publishStatus='ffPublish'
    fi
  elif [[ $status == 'vnode' ]]; then
    # never published on this vbranch
    publishStatus='notPublished'
  else
    mio_error "_publish_init_status: status '$status' not implemented"
    return 1
  fi
  # io_trace "_publish_init_status -> $(print_vars nextHead publishStatus)"
}
_publish_refresh_bundle_htag()
{
  # io_trace "_publish_refresh_bundle_htag 1 -- $(print_vars principalModuleId publishHTag noIncrement)"
  [[ -n $principalModuleId ]] && module_is_bundle  || return 0

  local pinfo pstatus ptag pver hver \
        principalScopes=(prod_scope publish_scope)

  pinfo=$(module_visit "$principalModuleId" "${principalScopes[@]}" _publish_principal_info)
  pstatus=${pinfo%;*}
  ptag=${pinfo#*;}
  [ -z $ptag ] && return 0

  pver=${ptag##*/}
  hver=${publishHTag##*/}
  # io_trace "_publish_refresh_bundle_htag 1 -- $(print_vars principalModuleId ptag pstatus publishHTag pinfo pstatus ptag hver pver)"
  if [[ $pstatus == 'published' && $hver == $pver ]]; then
    mio_message "Bundle ${VC}$bundleId${LightPurple} and module ${VC}$principalModuleId${LightPurple} have same version" ${LightPurple}
  else
    noIncrement=true
  fi
  hver=$(vtag_highest_of $pver $hver)
  # restore folder
  [[ $publishHTag =~ ^.*/ ]]
  publishHTag=${BASH_REMATCH[0]}$hver
  # io_trace "_publish_refresh_bundle_htag 2 -- $(print_vars principalModuleId ptag pstatus publishHTag noIncrement)"
}
# run in principal module context
_publish_principal_info()
{
  # io_trace "_publish_principal_info 1 -- $(print_vars publishStatus publishVTag publishHTag publishNTag)"
  # [[ $dryRun == true && -n $principalPublishStatus ]] && publishStatus=$principalPublishStatus
  # io_trace "_publish_principal_info 2 -- $(print_vars lbranch vbranch vtag htag delta status nextHead publishStatus)"
  local prerelPrefix noIncrement
  _publish_increment_version
  # io_trace "_publish_principal_info 2 -- $(print_vars publishStatus publishVTag publishHTag publishNTag)"
  echo "$publishStatus;$publishNTag"
}

# Compute next version
#
# usage:
#  local prerelPrefix='reuse' vnext
#  branch_set_vnext $noIncrement
# in:
#  prerelPrefix=$1  -- prerelease prefix (alpha, beta, rc, rtm, reuse)
#  $1:noIncrement   -- do not increment 
# out:
#  prerelPrefix=     -- prerelease prefix (alpha, beta, rc, rtm, reuse)
_publish_increment_version()
{
  if [[ $publishStatus == 'published' ]]; then
    publishNTag=$publishHTag
  else
    local prerelPrefix=$1 noIncrement=$2 vnext
    publishPrerelPrefix=$prerelPrefix
    if [[ $prerelPrefix == 'reuse' ]]; then
      # reuse previous vtag if it's not a vnode
      if vtag_is_vnode $publishVTag; then
        publishPrerelPrefix=''
        _publish_increment_version_core || return 1
      else
        publishNTag=$publishVTag
      fi
    else
      _publish_increment_version_core || return 1
    fi
  fi
}
# out:
#  vnext
_publish_increment_version_core()
{
  local vnext
  if [[ $noIncrement == true ]]; then
    if vtag_is_vnode $publishHTag; then
      vtag_set_increment "$publishHTag" "$publishPrerelPrefix" || return 1
      publishNTag=$vnext
    else
      publishNTag=$publishHTag
    fi
  else
    vtag_set_increment "$publishHTag" "$publishPrerelPrefix" || return 1
    publishNTag=$vnext
  fi
}

_publish_on_head_changed()
{
  publish_reset_scope
}
_publish_on_branch_created()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && publish_reset_scope
}
_publish_on_branch_deleted()
{
  [[ $1 =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && publish_reset_scope
}
