#!/bin/bash
# https://longair.net/blog/2009/04/16/git-fetch-and-merge/
# https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_BRANCH ]] && . zoul-git-branch
ZOUL_GIT_BRANCH=true

[[ -z $ZOUL_GIT_REPO ]] && . zoul-git-repo
[[ -z $ZOUL_GIT_VTAG ]] && . zoul-git-vtag

branch_exists()         { git rev-parse --quiet --verify $1 >/dev/null; }
branch_current()        { git rev-parse --abbrev-ref HEAD; }
branch_upstream()       { git rev-parse --abbrev-ref $1@{upstream} 2>/dev/null; }
branch_sync_info()      { git for-each-ref --format="%(refname:short) %(upstream:short) %(upstream:trackshort)" refs/heads "$@"; }
branch_list_local()     { git for-each-ref --format='%(refname:short)' refs/heads; }
branch_list_local_at()  { git show-ref --heads | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | sed 's,^refs/[^/]*/,,'; }
branch_list_remote()    { git for-each-ref --format='%(refname:short)' refs/remotes | grep -v '/HEAD$'; }
branch_list_remote_at() { git show-ref | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | grep 'refs/remotes' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_list_all()       { branch_list_local; branch_list_remote; }
branch_list_all_at()    { git show-ref | grep $(git rev-parse ${1:-HEAD}) | cut -d ' ' -f2 | grep -v '^refs/tags/' | grep -v '/HEAD$' | sed 's,^refs/[^/]*/,,'; }
branch_is_attached()    { git symbolic-ref --short -q HEAD &>/dev/null; }
branch_is_local()       { git show-ref -s --verify "refs/heads/$1" &>/dev/null; }
branch_is_remote()      { git show-ref -s --verify "refs/remotes/$1" &>/dev/null; }
branch_is_head()
{
  local hash1 hash2
  hash1=$(git rev-parse HEAD^{} 2>/dev/null)
  [ $? -ne 0 ] && return 1
  hash2=$(git rev-parse $1^{} 2>/dev/null)
  [ $? -ne 0 ] && return 1
  [ $hash1 = $hash2 ]
}
branch_list_tracked()
{
  local l r i
  while read l r i; do
    echo $r
  done < <(branch_sync_info)
}
branch_remove_tracked()
{
  local tracked=( $(branch_list_tracked) )
  if [[ -z $1 ]]; then
    local branches=( $(branch_list_all) )
    array_remove_array branches[@] tracked[@]
  else
    array_remove_array $1 tracked[@]
  fi
}

# Check if a given branch name exists and convert it to its remote counterpart if it does not exist
# Display error and return empty if branch is unknown
branch_realize()
{
  if branch_is_local "$1" || branch_is_remote "$1"; then
    echo "$1"
  else
    local remote=$(git remote)
    if branch_is_remote "$remote/$1"; then
      echo "$remote/$1"
    else
      return 1
    fi
  fi
}

branch_without_remote_prefix() { branch_is_remote $1 && echo ${1#*/} || echo $1; }
branch_checkout() { [[ -n $1 ]] && git checkout "$(branch_without_remote_prefix $1)" >/dev/null; }

# https://stackoverflow.com/questions/3216360/merge-update-and-pull-git-branches-without-using-checkouts
branch_merge_ff() {
    # merge 'branchToMerge' (invariant) into 'branchMergeInto' < 'branchToMerge'
    # 'branchMergeInto' should be a local branch with a symbolic name
    local branchToMerge=$1
    local branchMergeInto=$2
    local hashToMerge hashMergeInto

    hashMergeInto=$(git show-ref -s --verify "refs/heads/$branchMergeInto" 2>/dev/null)
    if [ $? -ne 0 ]; then
      io_error "not a local branch $branchMergeInto"
      return 1
    fi

    hashToMerge="$(git rev-parse --verify $branchToMerge 2> /dev/null)"
    if [ $? -ne 0 ]; then
      io_error "unknown branch to merge $branchToMerge"
      return 2
    fi

    if [ "$(git symbolic-ref HEAD)" = "refs/heads/$branchMergeInto" ]; then
        if ! git merge --ff-only "$branchToMerge"; then
          io_error "merging $branchToMerge into $branchMergeInto would not be a fast-forward"
          return 3
        fi
    else
      if [ "$(git merge-base $hashMergeInto $hashToMerge)" != "$hashMergeInto" ]; then
        io_error "merging $branchToMerge into $branchMergeInto would not be a fast-forward"
        return 4
      fi
      io_info "Updating ${hashMergeInto:0:7}..${hashToMerge:0:7}"
      if ! git update-ref -m "merge $branchToMerge into $branchMergeInto (fast forward)" "refs/heads/$branchMergeInto" "$hashToMerge" "$hashMergeInto"; then
        io_error "fast forward using update-ref failed"
        return 5
      fi
    fi
}
branch_merge_in_memory()
{
  local branchToMerge=$1 branchMergeInto=$2 mbase
  mbase=$(git merge-base $branchToMerge $branchMergeInto)
  git merge-tree $mbase $branchMergeInto $branchToMerge
}
branch_merge_dry_run()
{
  local conflicts
  conflicts=$(branch_merge_in_memory "$@")
  echo "$conflicts" | grep -q -E '^[+-\ ]>{7}' && return 1 || return 0
}
branch_merge_interactive()
{
  local ec=0
  git mergetool >/dev/null || ec=1
  if (( $ec == 0 )); then
    git commit --no-edit >/dev/null
    git push &>/dev/null
  fi
  # clean temp merge files
  repo_list_untracked | grep -E '(\.orig$|_(BACKUP|BASE|LOCAL|REMOTE)_[0-9]+)' | xargs --no-run-if-empty rm --
  return $ec
}
branch_merge()
{
  # merge branchToMerge into branchMergeInto
  # before: branchMergeInto < branchToMerge
  # after : branchMergeInto = branchToMerge -- branchMergeInto moved towards branchToMerge
  local branchToMerge=$1 branchMergeInto=$2 ec=0
  local targetBranchIsNotLocal
  # try fast-forward merge
  branch_merge_ff $branchToMerge $branchMergeInto &>/dev/null || ec=$?
  if (( $ec != 0 )); then
    # fast forward failed
    if (( $ec == 1 )); then
      targetBranchIsNotLocal=true
      # ensure target branch name is realized
      branchMergeInto=$(branch_realize $branchMergeInto 2>/dev/null)
      ec=0
    fi
    # on active branch...
    if [[ -z $targetBranchIsNotLocal ]] && branch_is_head $branchMergeInto; then
      # ... merge even if conflicts
      if ! git merge $branchToMerge &>/dev/null; then
        if repo_is_merging; then
          branch_merge_interactive || {
            local conflicts=$(git diff)
            io_error "while auto-merging $branchToMerge into $branchMergeInto."
            io_message >&2 "$(echo "$conflicts" | sed 's/^/  /')" '' Red
            io_message >&2 "  configure your mergetool and run 'git sync' again" '' LightCyan
            io_message >&2 "  ... or finalize the merge using the following commands:" '' LightCyan
            io_message >&2 "    <merge-tool>" '' Brown
            io_message >&2 "    git commit --no-edit" '' DarkGray
            io_message >&2 "    git push" '' DarkGray
            return 1
          }
        else
          return 1
        fi
      fi
    # on inactive branch check if there will be merge conflicts before switching
    else
      if branch_merge_dry_run $branchToMerge $branchMergeInto; then
        # no conflicts: merge
        [[ $targetBranchIsNotLocal == true ]] && branchMergeInto=$(branch_without_remote_prefix $branchMergeInto)
        if git checkout $branchMergeInto &>/dev/null; then
          git merge $branchToMerge &>/dev/null || {
            io_error "unable to merge $branchToMerge into $branchMergeInto branch"
            ec=1
          }
          git checkout - &>/dev/null
          return $ec
        else
          io_error "unable to checkout $branchMergeInto branch"
          return 1
        fi
      else
        if git checkout $branchMergeInto &>/dev/null; then
          git merge $branchToMerge &>/dev/null || branch_merge_interactive ||
          {
            local conflicts=$(git diff)
            io_error "while auto-merging $branchToMerge into $branchMergeInto."
            io_message >&2 "$(echo "$conflicts" | sed 's/^/  /')" '' Red
            io_message >&2 "  configure your mergetool and run 'git sync' again" '' LightCyan
            io_message >&2 "  ... or merge $branchToMerge into $branchMergeInto using the following commands:" '' LightCyan
            io_message >&2 "    git checkout $branchMergeInto" '' DarkGray
            io_message >&2 "    git pull" '' DarkGray
            io_message >&2 "    <merge-tool>" '' Brown
            io_message >&2 "    git commit --no-edit" '' DarkGray
            io_message >&2 "    git push" '' DarkGray
            io_message >&2 "    git checkout -" '' DarkGray
            git merge --abort
            ec=1
          }
          git checkout - &>/dev/null
          return $ec
        else
          io_error "unable to checkout $branchMergeInto branch"
          return 1
        fi
      fi
    fi
  fi
}
branch_push()
{
  # l > r -- move r
  local r=$1 l=$2
  git push ${r%%/*} $l &>/dev/null
}
branch_sync() { branch_merge "$@" && branch_push "$@"; }

branch_list_attach_candidates()
{
  if ! branch_is_attached; then
    local branches=( $(branch_list_all_at $1) )
    branch_remove_tracked branches[@]
  fi
}
branch_attach()
{
  # attach a detached head to the unique local branch that's pointing at
  if ! branch_is_attached; then
    local branches=($(branch_list_attach_candidates $1))
    if (( ${#branches[@]} == 1 )); then
      branch_checkout "${branches[0]}"
    fi
  fi
}


branch_sync_all()
{
#   io_info branch_sync_all
  local moduleId=$(repo_module_id)
  git fetch --prune --all &>/dev/null
  repo_require_clean_work_tree "synchronize [$moduleId]" || return 1
  while read l r i; do
    case $i in
      '>')  color=Brown;;  # ahead
      '<')  color=Yellow;; # behind
      '<>') color=Yellow;; # ahead and behind
      '=')  color=Green;;
      *)
        if [[ -n $r ]]; then
          # tracking branch was deleted or renamed
          i='?'
          color=Red
        else
          # nothing tracked
          color=DarkGray
        fi;;
    esac
    local linfo="  $l"
    [[ $l == $(branch_current) ]] && linfo="* $l"
    io_message "$linfo $i $r" "[$moduleId] synchronizing" $color
    [[ $i == '?' ]] && {
      io_message >&2 "  remote branch $r was deleted or renamed" ''
      io_message >&2 "  rename $l and update its tracking information:" ''
      io_message >&2 "    git branch -m $l <newbranch>" '' Gray
      io_message >&2 "    git branch -u <upstream> <newbranch>" '' Gray
    }
    case $i in
      '>')  branch_push  $r $l || return 1;; # l > r ahead   -- move r
      '<')  branch_merge $r $l || return 1;; # l < r behind  -- move l
      '<>') branch_sync  $r $l || return 1;; # ahead and behind
    esac
  done < <(branch_sync_info)
  git submodule update --recursive # --remote
}

# Convert a development branch to a fallback list of development branches.
branch_dev_fallback()
{
  local branch=$1
  if [[ $branch =~ ^([^/]+)/(.+)$ ]]; then
    local kind=${BASH_REMATCH[1]}; io_debug kind
    local config=${BASH_REMATCH[2]}; io_debug config
    case $kind in
      sku|wip|issue) echo $branch;;
    esac
    if [[ $config =~ ^([^/]+)/(.*)$ ]]; then
      local product=${BASH_REMATCH[1]}; io_debug product
      config=${BASH_REMATCH[2]}; io_debug config
      case $kind in
        sku|wip|issue) echo "$kind/$config";;
        *) echo $branch;;
      esac
      if [[ $config =~ ^([^/]+)/(.*)$ ]]; then
        local subkind=${BASH_REMATCH[1]}; io_debug subkind
        config=${BASH_REMATCH[2]}; io_debug config
        case $subkind in
          sku|wip|issue) echo "$subkind/$config";;
          *) echo $branch;;
        esac
      fi
    fi
  fi
  echo 'master'
}
# Convert any branch (dev or prod) to a fallback list of development branches.
branch_best_match_dev_fallback()
{
  local branch=$1
  [[ $debug == true ]] && io_message "$branch" 'branch_best_match_dev_fallback' Brown >&2
  if [[ $branch =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]]; then
    # prod branch
    local prefix=${BASH_REMATCH[1]}
    io_debug prefix
    local version=${BASH_REMATCH[2]}
    io_debug version
    [[ -z $prefix ]] && branch_dev_fallback 'master' || branch_dev_fallback "${prefix}dev"
  else
    branch_dev_fallback $branch
  fi
}
# Convert any branch to a fallback list of regex patterns.
branch_best_match_dev_patterns()
{
  local branch
  for branch in $(branch_best_match_dev_fallback $1); do
    regex_whole $(regex_escape $branch)
  done
}
# Use this method to find the development branch which best matches
# any superproject branch (dev|prod)
branch_best_match_dev()
{
  local patterns=( $(branch_best_match_dev_patterns $1) )
  local branches=( $(branch_remove_tracked) )
  # try to find a branch matching bundle branch name
  for pattern in "${patterns[@]}"; do
    for candidate in "${branches[@]}"; do
      local lcandidate=$(branch_without_remote_prefix $candidate)
      [[ $lcandidate =~ $pattern ]] && {
        echo $candidate
        return 0
      }
    done
  done
  return 1
}
branch_best_match_prod()
{
  local branch
  branch=$(branch_realize $1 2>/dev/null)
  if [ $? -eq 0 ]; then
    echo $branch
  else
    local dev=$(branch_best_match_dev $1)
    local ltag=$(vtag_describe $dev)
    vtag_get_vbranch_name $ltag
  fi
}
branch_is_prod() { [[ $1 =~ ^(.*/)?([0-9]+\.[0-9]+)$ ]] && return 0 || return 1; }
branch_best_match()
{
  local target=$1
  if branch_is_prod $target; then
    branch_best_match_prod $target
  else
    branch_best_match_dev $target
  fi
}
branch_select_update_submodules()
{
  local update=true
  if [[ $FOR_INSIDE_ROOT == true ]]; then
    unset update
  else
    [[ $FOR_RECURSIVE == true ]] && unset update
  fi
  [[ $update == true ]] && git submodule update --recursive
}
branch_select()
{
  local bestMatch=$(branch_best_match $1)
  if branch_is_head $bestMatch; then
    branch_checkout "$bestMatch"
  elif repo_require_clean_work_tree; then
    branch_checkout "$bestMatch"
    branch_select_update_submodules
  fi
}

