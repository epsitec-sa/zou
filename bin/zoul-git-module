#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_MODULE ]] && . zoul-git-module
ZOUL_GIT_MODULE=true

[[ -z $ZOUL_CORE ]]            && . zoul-core
[[ -z $ZOUL_PROCESS ]]         && . zoul-process
[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

# module state variables
readonly moduleScope='moduleRoot moduleId moduleBranch moduleTracePrefix'
readonly moduleStartupScope='startupDir startupRoot bundleRoot bundleId bundleBranch'

module_run()
{
  module_scope_startup module_scope $*
}
module_scope_startup()
{
  # setup startup context
  local \
    startupDir=$PWD \
    startupRoot=$(repo_module_root) \
    bundleId=$(repo_bundle_id) \
    bundleRoot=$(repo_bundle_root) \
    bundleBranch=$(branch_current_root_branch)

  # enter startup module
  module_enter "$startupRoot" || return $?

  # execute next russian doll
  $*
}
# usage:
#   module_enter "$moduleDir" || return $?
#   module_scope $*
module_scope()
{
  # setup module context
  local \
    moduleRoot="$PWD" \
    moduleId=$(repo_module_id) \
    moduleBranch=$(branch_current) \
    moduleTracePrefix

  if [[ $useLongModuleTracePrefix == true ]]; then
    local spaces sep
    (( spaces = 30 - ${#moduleId} - ${#moduleBranch} ))
    (( spaces < 1 )) && spaces=1
    printf -v sep '%0.s ' $(seq 1 $spaces)
    printf -v moduleTracePrefix '%s' "[$moduleId]" "$sep" "($moduleBranch)"
  else
    printf -v moduleTracePrefix '%-25s' "[$moduleId]"
  fi

  # execute next russian doll
  $*
}
# usage:
#   module_enter "$moduleDir" || return $?
module_enter()
{
  cd "$1" &>/dev/null || {
    io_error "No such [sub]module directory '$1'" "$moduleTracePrefix"
    return 1
  }
  [[ $quiet == true ]] || echo Entering "'$(path_make_relative '.' "$startupDir")'"
}

# usage:
#   module_visit_submodules enumerator next ...
# in:
#   $1     -- enumerator
#   ${@:2} -- next ...
module_visit_submodules()
{
  visit $1 module_submodule_visitor "${@:2}"
}
# usage:
#   module_visit_submodules_async enumerator next ...
# in:
#   $1     -- enumerator
#   ${@:2} -- next ...
module_visit_submodules_async()
{
  visit_async $1 module_submodule_visitor "${@:2}"
}
# usage:
#   module_submodule_visitor path next ...
# in:
#   $1     -- path
#   ${@:2} -- next ...
module_submodule_visitor()
{
  module_enter "$1" || return $?
  module_scope "${@:2}" || return $?
}
