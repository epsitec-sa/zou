#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_MODULE ]] && . zoul-git-module
ZOUL_GIT_MODULE=true

[[ -z $ZOUL_CORE ]]            && . zoul-core
[[ -z $ZOUL_PROCESS ]]         && . zoul-process
[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_BUNDLE ]]      && . zoul-git-bundle
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

# global variables
startupMessage=''

# global options
useLongModuleTracePrefix=true
showVisitModuleMessage=false
doNotRegisterBundle=false

# events registration
branchChangedEvent+=( _module_reset_scope )

# run a function in the startup module root folder with startup, bundle and module scopes defined
module_run()
{
  # io_trace "module_run ${*@Q}"
  if [[ $moduleScopeInitialized == true ]]; then
    # execute next russian doll
    $1 "${@:2}"
  else
    _module_scope_startup _module_scope "$@"
  fi
}
# usage:
#   module_visit sm-path next ...
# in:
#   $1     -- submodule path
#   ${@:2} -- next ...
module_visit()
{
  local sm=( "$1" )
  visit 'sm[@]' _module_submodule_visitor "${@:2}"
}
# usage:
#   module_visit_submodules enumerator next ...
#   module_visit_submodules array[@] next ...
# in:
#   $1     -- enumerator or array name
#   ${@:2} -- next ...
module_visit_submodules()
{
  visit $1 _module_submodule_visitor "${@:2}"
}
# usage:
#   module_visit_submodules_async enumerator next ...
#   module_visit_submodules_async array[@] next ...
# in:
#   $1     -- enumerator or array name
#   ${@:2} -- next ...
module_visit_submodules_async()
{
  visit_async $1 _module_submodule_visitor "${@:2}"
}
module_visit_submodules_async_fast()
{
  visit_async_fast $1 _module_submodule_visitor "${@:2}"
}
module_has_submodules() { [ ${#moduleSubmodulePaths[@]} -gt 0 ]; }
module_is_bundle()      { [[ -n "$moduleRoot" && "$moduleRoot" == "$bundleRoot" ]]; }

# run a function in the startup module root folder with startup and bundle scopes defined
_module_scope_startup()
{
  # io_trace "_module_scope_startup ${*@Q}"

  # setup startup context
  local startupDir=$PWD startupRoot \
        bundleId bundleRoot bundleBranch \
        bundleUrl bundleUrlName \
        bundleTracePrefix \
        principalModuleId \
        submodulePathMaxLength

  startupRoot=$(repo_module_root)
  [[ -z $startupRoot ]] && {
    io_error "Not a git repository '$PWD' (or any of the parent directories)"
    return 1
  }
  # enter startup module
  _module_enter "$startupRoot" || return $?

  bundleId=$(repo_bundle_id)
  bundleRoot=$(repo_bundle_root)
  bundleBranch=$(branch_current_root_branch)

  repo_set_bundle_url_info "$bundleRoot"  # -> bundleUrl bundleUrlName
  _module_set_bundle_trace_prefix
  _module_set_principal_module_id

  _module_startup_message
  _module_register_bundle

  # io_trace "_module_scope_startup -- $(print_vars startupDir startupRoot bundleId bundleRoot bundleBranch)"
  # io_trace "_module_scope_startup -- $(print_vars bundleUrl bundleUrlName principalModuleId)"

  # execute next russian doll
  $1 "${@:2}"
}
_module_startup_message()
{
  if [[ -n $startupMessage ]]; then
    io_message "$startupMessage" "$bundleTracePrefix" ${White}
  fi
}
_module_register_bundle()
{
  [[ $doNotRegisterBundle == true ]] && return 0
  if [[ $startupRoot == $bundleRoot ]]; then
    bundle_register "$bundleUrl" "$bundleRoot"
    # io_trace "_module_register_bundle ${*@Q} -- $(print_vars bundleUrl bundleRoot)"
  fi
}
# run a function in the module root folder with module scope defined
_module_scope()
{
  # io_trace "_module_scope ${*@Q}"
  # setup module context
  local \
    moduleRoot="$PWD" \
    moduleParent=$(repo_module_parent) \
    moduleId=$(repo_module_id) \
    moduleBranch=$(branch_current) \
    moduleConfigFile="$PWD/.zou-flow" \
    moduleSubmodulePaths=( $(repo_list_submodule_paths $PWD) ) \
    modulePath moduleBundlePath \
    moduleTracePrefix \
    moduleScopeInitialized=true
  
  [[ -n $moduleParent ]] && modulePath=${moduleRoot#$moduleParent/}
  moduleBundlePath=${moduleRoot#$bundleRoot}
  moduleBundlePath=${moduleBundlePath#/}

  if [[ $moduleRoot == $startupRoot ]]; then
    # initialize startup module context
    _module_set_submodule_path_max_length
  fi

  _module_set_trace_prefix

  if [[ $showVisitModuleMessage == true ]]; then
    local startupRelativeDir=$(path_make_relative '.' "$startupDir")
    mio_message "Entering '$startupRelativeDir'" '' ${Gray}
  fi

  # io_trace "_module_scope -- $(print_vars moduleId modulePath moduleBundlePath)"

  # execute next russian doll
  $1 "${@:2}"
}
# usage:
#   _module_submodule_visitor path next ...
# in:
#   $1     -- path
#   ${@:2} -- next ...
_module_submodule_visitor()
{
  _module_enter "$1" || return $?
  repo_check_submodule "$1" || return $?
  _module_scope "${@:2}" || return $?
}
# usage:
#   _module_enter "$moduleDir" || return $?
_module_enter()
{
  cd "$1" &>/dev/null || {
    io_error "No such [sub]module directory '$1'" "$moduleTracePrefix"
    return 1
  }
}
_module_reset_scope()
{
  [[ $moduleScopeInitialized == true ]] || return 0

  moduleSubmodulePaths=( $(repo_list_submodule_paths $PWD) )
  
  if [[ "$PWD" == "$bundleRoot" ]]; then
    bundleBranch=$1
    _module_set_principal_module_id
    _module_set_bundle_trace_prefix
  fi

  moduleBranch=$1
  _module_set_trace_prefix
  
  # io_trace "_module_reset_scope ${*@Q} -> $(print_vars bundleBranch moduleBranch principalModuleId)"
  # io_trace "_module_reset_scope ${*@Q} -> $(print_vars moduleBranchPrefix)"
}

##################
# PRINCIPAL MODULE
##################

_module_set_principal_module_id()
{
  # if the bundle branch name starts with 'sku/', use the following part as the principal module ID
  # else use the bundle name without '-dev' suffix

  if [[ $bundleBranch =~ ^sku/([^/]+) ]]; then
    principalModuleId=${BASH_REMATCH[1]}
    [ -d "$bundleRoot/$principalModuleId" ] && return 0
  fi
  principalModuleId=${bundleUrlName%-dev}
  [ -d "$bundleRoot/$principalModuleId" ] && return 0
  unset principalModuleId
  return 1
}

##############
# TRACE PREFIX
##############

_module_set_submodule_path_max_length()
{
  local maxLength
  string_set_max_length "${moduleSubmodulePaths[@]}"
  submodulePathMaxLength=$maxLength
}
# in:
#   $1 -- id
#   $2 -- len
#   $3 -- color
# out:
#   sid -- smart colored id
#   rlen -- remaining length
_module_set_smart_id()
{
  # io_trace "_module_set_smart_id0 <- ${*@Q}"
  local len=$1 id=$2 color=$3
  rlen=$len
  if (( ${#id} <= $len )); then
    sid="${color}$id"
  else
    local atoms=( ${id//\// } ) ratoms
    if (( ${#atoms[@]} > 1 )); then
      local i j
      (( rlen -= 1 ))
      for i in $(seq 1 ${#atoms[@]}); do
        # start from the end
        j=$(( ${#atoms[@]} - $i ))
        (( rlen -= ${#atoms[$j]} ))
        # io_trace "_module_set_smart_id0 -> $(print_vars i j rlen)"
        (( rlen <= 0 )) && break
        (( rlen -= 1 ))
      done
      (( j += 1 ))
      ratoms=( "${atoms[@]:$j}" )
      (( ${#ratoms[@]} == 0 )) && ratoms=( ${atoms[-1]} )
      id=${ratoms[*]}
      id=${id// /\/}
      sid="${Purple}\u2026/${color}${id}"
      id="./${id}"
    else
      id=${atoms[0]}
      sid="${color}${id}"
    fi
  fi
  (( rlen = len - ${#id} ))
  # io_trace "_module_set_smart_id0 -> $(print_vars rlen sid)"
}
_module_set_smart_id2()
{
  local len=$1 mid=$2 mcolor=$3 bid=$4 bcolor=$5 spaces sep
  (( spaces = $len - ${#mid} - ${#bid} - 4 ))
  if (( spaces <= 0 )); then
    # no enough space
    # |-----------------------------------|
    # |----------mid---------|-|----------bid----------|
    local grlen mrlen brlen rlen
    (( grlen = -spaces + 1 ))
    (( brlen = ( grlen * ${#bid} ) / ( ${#bid} + ${#mid} ) + 4 ))
    (( mrlen = grlen - brlen ))
    # io_trace "_module_set_smart_id2 -- $(print_vars spaces grlen mrlen brlen)"
    _module_set_smart_id $(( ${#bid} - brlen )) $bid ${bcolor}
    bid=$sid
    (( mrlen -= rlen ))
    # io_trace "_module_set_smart_id2 -- $(print_vars spaces grlen mrlen brlen)"
    _module_set_smart_id $(( ${#mid} - mrlen )) $mid ${mcolor}
    mid=$sid
    # io_trace "_module_set_smart_id2 -- $(print_vars spaces grlen mrlen brlen rlen sid)"
    printf -v sep '%0.s-' $(seq 1 $spaces)
    sid="${mcolor}[$mid]${DarkGray}${sep}${bcolor}($bid)${NC}"
    (( spaces = rlen + 1 ))
  fi
  printf -v sep '%0.s-' $(seq 1 $spaces)
  sid="${mcolor}[$mid]${DarkGray}${sep}${bcolor}($bid)${NC}"
  # io_trace "_module_set_smart_id2 -- $(print_vars spaces sid)"
}
_module_set_trace_prefix()
{
  local mcolor=${LightCyan}
  if [[ $useLongModuleTracePrefix == true ]]; then
    local sid bcolor bid mid=$moduleId
    bid=$(branch_head_symbol)
    [ $? -eq 0 ] && bcolor=${Cyan} || bcolor=${Brown}
    _module_set_smart_id2 42 "$mid" "$mcolor" "$bid" "$bcolor"
    moduleTracePrefix=$sid
  else
    local len; (( len = ${submodulePathMaxLength} + 2 ))
    printf -v moduleTracePrefix "%-${len}s" "[$moduleId]"
    moduleTracePrefix="${mcolor}$moduleTracePrefix${NC}"
  fi
}
_module_set_bundle_trace_prefix()
{
  if [[ $useLongModuleTracePrefix == true ]]; then
    local sid bid mid=$bundleId
    cd "$bundleRoot"
    
    bid=$(branch_head_symbol)
    # [ $? -eq 0 ] && bcolor=Cyan || bcolor=Brown
    _module_set_smart_id2 42 "$mid" ${White} "$bid" ${White}
    bundleTracePrefix=$sid
    
    cd - &>/dev/null
  else
    local len; (( len = ${submodulePathMaxLength} + 2 ))
    printf -v bundleTracePrefix "%-${len}s" "[$bundleId]"
    bundleTracePrefix="${White}$bundleTracePrefix${NC}"
  fi
}
