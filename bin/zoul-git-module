#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_MODULE ]] && . zoul-git-module
ZOUL_GIT_MODULE=true

[[ -z $ZOUL_PROCESS ]]         && . zoul-process
[[ -z $ZOUL_GIT_REPO ]]        && . zoul-git-repo
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

# module state variables
readonly moduleScope='moduleRoot moduleId moduleBranch moduleTracePrefix'
readonly moduleStartupScope='startupDir startupRoot bundleRoot bundleId bundleBranch'

module_run()
{
  module_scope_startup module_scope $*
}
module_scope_startup()
{
  # setup startup context
  local \
    startupDir=$PWD \
    startupRoot=$(repo_module_root) \
    bundleId=$(repo_bundle_id) \
    bundleRoot=$(repo_bundle_root) \
    bundleBranch=$(branch_current_root_branch)

  # enter startup module
  module_enter "$startupRoot" || return $?

  # execute next russian doll
  $*
}
# usage:
#   module_enter "$moduleDir" || return $?
#   module_scope $*
module_scope()
{
  # setup module context
  local \
    moduleRoot="$PWD" \
    moduleId=$(repo_module_id) \
    moduleBranch=$(branch_current) \
    moduleTracePrefix moduleBranchTracePrefix

  printf -v moduleTracePrefix '%-15s' "[$moduleId]"
  printf -v moduleBranchTracePrefix '%-15s %15s' "[$moduleId]" "($moduleBranch)"

  # execute next russian doll
  $*
}
# usage:
#   module_enter "$moduleDir" || return $?
module_enter()
{
  cd "$1" &>/dev/null || {
    io_error "No such [sub]module directory '$1'" "$moduleTracePrefix"
    return 1
  }
  [[ $quiet == true ]] || echo Entering "'$(path_make_relative '.' "$startupDir")'"
}

# usage:
#   module_visit enumerator p-visitor ...
# in:
#   $1     -- enumerator
#   $2     -- p-visitor path ...
#   ${@:3} -- next
module_visit()
{
  local ec=0 path
  for path in $($1); do
    (
      $2 "$path" "${@:3}" || exit $?
    ) || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && break
  done
  return $ec
}
# usage:
#   module_visit enumerator p-visitor next ...
# in:
#   $1     -- enumerator
#   $2     -- p-visitor   # signature: p-visitor path next ...
#   ${@:3} -- next ...
module_visit_async()
{
  local ec=0 path pids=()
  for path in $(string_sort $($1)); do
    (
      $2 "$path" "${@:3}" || exit $?
    ) &
    pids+=($!)
    if (( $(process_job_count) % $jobsCount == 0 )); then
      wait "${pids[@]}" &>/dev/null || ec=$?
      pids=()
      [[ $ec -ne 0 && $stopOnError == true ]] && break
    fi
  done
  [ ${#pids[@]} -ne 0 ] && wait "${pids[@]}" &>/dev/null || ec=$?
  return $ec
}
# usage:
#   module_visit_submodules enumerator next ...
# in:
#   $1     -- enumerator
#   ${@:2} -- next ...
module_visit_submodules()
{
  module_visit $1 module_submodule_visitor "${@:2}"
}
# usage:
#   module_visit_submodules_async enumerator next ...
# in:
#   $1     -- enumerator
#   ${@:2} -- next ...
module_visit_submodules_async()
{
  module_visit_async $1 module_submodule_visitor "${@:2}"
}
# usage:
#   module_submodule_visitor path next ...
# in:
#   $1     -- path
#   ${@:2} -- next ...
module_submodule_visitor()
{
  module_enter "$1" || return $?
  module_scope "${@:2}" || return $?
}
