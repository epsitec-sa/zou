#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_TAG ]] && . zoul-git-tag
ZOUL_GIT_TAG=true

[[ -z $ZOUL_CORE ]]          && . zoul-core
[[ -z $ZOUL_GIT_CORE ]]      && . zoul-git-core
[[ -z $ZOUL_GIT_STOW_CORE ]] && . zoul-git-stow-core

# global options
#   noTagPush

tagger_name()  { git show $1 -q | grep Tagger: | sed -E 's,Tagger:s+(.*)s+<(.*)>,1,'; }
tagger_email() { git show $1 -q | grep Tagger: | sed -E 's,Tagger:s+(.*)s+<(.*)>,2,'; }
tag_date()     { git show $1 -q | grep Date: | sed -E 's,Date:s+(.*),1,' | head -n 1; }
tag_comment()  { git tag -l -n1 $1 | sed -E "s,^[^']+'([^']*).*$,\1,"; }

tag_exists()         { git show-ref -s --verify "refs/tags/$1" &>/dev/null; }
tag_is_lightweight() { [[ $(git rev-parse $1) == $(git rev-parse $1^{}) ]]; }
tag_is_annotated()   { [[ $(git rev-parse $1) != $(git rev-parse $1^{}) ]]; }
commit_is_pushed()   { [[ -n $(git branch -r --contains $1) ]]; }

tag_push_not_followed()
{
  [[ $noTagPush == true ]] && return 0
  local tag=$1 commit=$2 remote=$(git_remote); shift 2
  # 'git push --follow-tags' push only tags associated with commits that are not pushed
  if [[ $1 == '--delete' ]]; then
    if git push --delete "$remote" "$tag" &>/dev/null; then
      mio_success "Deleted tag ${VC}$tag${Brown} from ${VC}$remote"
    fi
  elif commit_is_pushed "$commit"; then
    if git push "$@" "$remote" "$tag" &>/dev/null; then
      mio_success "Pushed tag ${VC}$tag${Green} to ${VC}$remote"
    fi
  fi
}
tag_rename()
{
  local tag1=$1 tag2=$2 force=$3 tagOpts=()
  # io_trace "tag_rename -- $(print_vars tag1 tag2 force)"
  [[ $tag1 == $tag2 ]] && return 0
  # force rename if tags point at same commit
  { [[ $force == true ]] || { ref_exists $tag2 && ref_equals $tag1 $tag2; }; } && tagOpts+=( '-f' )

  local tagger=$(tagger_name $tag1)
  if [[ -z "$tagger" ]]; then
    io_buffered_eval "git tag ${tagOpts[@]} "$tag2" "$tag1^{}"" : ${DarkGray} \
    && mio_info "Renamed lightweight tag ${VC}$tag1${Cyan} to ${VC}$tag2" \
    || return $?
  else
    local message=$(tag_comment "$tag1")
    GIT_COMMITTER_NAME="$tagger" \
    GIT_COMMITTER_EMAIL=$(tagger_email "$tag1") \
    GIT_COMMITTER_DATE=$(tag_date "$tag1") \
    io_buffered_eval "git tag -m '$message' ${tagOpts[@]} "$tag2" "$tag1^{}"" : ${DarkGray} \
    && mio_info "Renamed annotated tag ${VC}$tag1${Cyan} to ${VC}$tag2" \
    || return $?
  fi
  tag_push_not_followed $tag2 $tag1
  [[ "$tag1" != "$tag2" ]] && tag_delete "$tag1" &>/dev/null
}
tag_move_to_commit()
{
  [[ $(git_get_commit $1) == $(git_get_commit $2) ]] && return 0
  local tag=$1 commit=$2 force=$3 tagOpt
  # force move if tag point at commit
  { [[ $force == true ]] || ref_equals $tag $commit; } && tagOpt='-f'

  local tagger=$(tagger_name $tag)
  if [[ -z "$tagger" ]]; then
    tag_delete $tag &>/dev/null
    git tag $tagOpt "$tag" "$commit^{}" \
    && mio_info "Moved lightweight tag '$tag' to '$commit'"
  else
    local message=$(tag_comment "$tag")
    local email=$(tagger_email "$tag")
    local date=$(tag_date "$tag")

    tag_delete $tag &>/dev/null
    GIT_COMMITTER_NAME="$tagger" GIT_COMMITTER_EMAIL="$email" GIT_COMMITTER_DATE="$date" \
    git tag $tagOpt -a -m "'$message'" "$tag" "$commit" \
    && mio_info "Moved annotated tag '$tag' to '$commit'"
  fi
  tag_push_not_followed $tag $commit
}
tag_new()
{
  local tag=$1 commit=${2:-HEAD} message=$3
  if tag_exists "$tag"; then
    mio_error "Tag '$tag' already exists"
    return 1
  elif git tag -a -m "'$message'" "$tag" "$commit"; then
    mio_success "Created tag ${VC}$tag${Green} on ${VC}$commit${Green}"
  fi
  tag_push_not_followed $tag $commit
}
tag_delete()
{
  if tag_exists "$1"; then
    tag_push_not_followed $1 $1^{} '--delete'
    io_buffered_eval "git tag --delete "$1"" : ${Green}
  else
    mio_error "Tag '$tag' does not exist"
    if git push --delete origin "$tag" &>/dev/null; then
      mio_success "Deleted tag ${VC}$tag${Brown} from ${VC}origin"
    fi
  fi
}
tag_move()
{
  # io_trace "tag_move ${*@Q}"

  local tag1=$1 tag2=$2
  [[ "$tag1" == "$tag2" ]] && return 0
  if ! git_object_exists "$tag1"; then
    mio_error "Object '$tag1' does not exist."
    return 1
  fi
  if git_object_exists "$tag2"; then
    # io_trace "tag_move 1 -- $(print_vars tag1 tag2 type2)"
    if tag_exists $tag2; then
      if ref_equals $tag1 $tag2; then
        tag_rename "$@"
      else
        local hash1=$(git rev-parse --short $tag1^{}) hash2=$(git rev-parse --short $tag2^{})
        mio_warning "Cannot move ${VC}$tag1 ($hash1)${Brown} to ${VC}$tag2 ($hash2)"
        local refPath stowFolder stowType refType refStowType stowPath
        stow_set_info "$tag1" # -> refPath stowFolder stowType
        stow_set_tag_info
        refStowType=${refStowType/*./twin.}
        stow_set_folder "$refStowType" # -> stowPath
        # io_trace "tag_move 2 -- $(print_vars tag1 stowFolder refPath stowType stowPath)"
        if [[ $tag1 != $stowPath ]]; then
          tag_rename "$tag1" "$stowPath"
        fi
        return 1
      fi
    else
      tag_move_to_commit "$@"
    fi
  else
    # tag2 does not exist, assume it's a tag
    tag_rename "$@"
  fi
}
tag_mirror()
{
  local verbose=$1 dryRun=$2 color=Gray
  [[ $dryRun == true ]] && color=DarkGray
  mio_message "Mirroring tags..." $color
  [[ $dryRun == true ]] && return 0
  if [[ $verbose == true ]]; then
    local line
    io_buffered_eval 'git push --tags --prune -f 2>&1' _tag_mirror_line_selector
  else
    git push --tags --prune -f &>/dev/null
  fi
}
_tag_mirror_line_selector()
{
  [[ $line =~ ^.*\[new\ tag\][[:blank:]]+(.*)$ ]] && line="${BASH_REMATCH[1]}"
}

