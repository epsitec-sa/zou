#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_VTAG ]] && . zoul-git-vtag
ZOUL_GIT_VTAG=true

[[ -z $ZOUL_CORE ]]            && . zoul-core
[[ -z $ZOUL_GIT_CORE ]]        && . zoul-git-core
[[ -z $ZOUL_GIT_REF ]]         && . zoul-git-ref
[[ -z $ZOUL_GIT_TAG ]]         && . zoul-git-tag
[[ -z $ZOUL_GIT_BRANCH_CORE ]] && . zoul-git-branch-core

vtag_get_patch()  { vtag_is_semver $1 && echo ${BASH_REMATCH[5]}; }

# Parse semver tag
# input:
#   x/y/v1.2.3-rc4+meta
#   x/y/v1.2-@
# output:
#   folder=${BASH_REMATCH[1]}          x/y/
#   major=${BASH_REMATCH[2]}           1
#   minor=${BASH_REMATCH[3]}           2
#   tail=${BASH_REMATCH[4]}            .3-rc4+meta | -@
#   patch=${BASH_REMATCH[5]}           3
#   prerel=${BASH_REMATCH[6]}          -rc4
#   prerel-prefix=${BASH_REMATCH[7]}   -rc 
#   prerel-rev=${BASH_REMATCH[8]}      4
#   meta=${BASH_REMATCH[9]}            +meta
vtag_is_semver() { [[ $1 =~ ^(.*/)?v([0-9]+).([0-9]+)(-@|.([0-9]+)((-alpha|-beta|-rc)([0-9]+))?(\+.+)?)$ ]]; }
vtag_is_vnode()  { [[ $1 =~ ^(.*/)?v[0-9]+\.[0-9]+-@ ]]; }
vtag_is_vtag()   { [[ $1 =~ ^(.*/)?v[0-9]+\.[0-9]+\.[0-9] ]]; }
vtag_at_vtag()
{
  local tag
  tag=$(git describe --exact-match "$1" 2>/dev/null) || return 1
  vtag_is_vtag "$tag" && echo $tag
}
vtag_list()
{
  # input             output
  # 1.0               v1.0-@ v1.0.0
  # sku/sal/1.0       sku/sal/v1.0-@
  local vbranch=$1
  local regex
  if [[ -z $vbranch ]]; then
    regex='v[0-9]+\.[0-9]+(\.|-)'
  elif [[ $vbranch =~ ^(.*/)?([0-9]+\.[0-9]+) ]]; then
    # vbranch
    local prefix=${BASH_REMATCH[1]}
    local version=${BASH_REMATCH[2]}
    regex="^$(regex_escape $prefix)v$(regex_escape $version)"
    # io_debug prefix vtag_list
    # io_debug version vtag_list
  else
    io_error "vtag invalid format : '$1'"
    return 1
  fi
  # io_debug regex vtag_list
  git tag -l --sort=-v:refname | grep -E $regex | grep -v '^other/' || true
}

# get highest version on a specific vbranch
# - a bundle can have the same version twice (SKU version)
#   sku/sal/v13.1.0
#   sku/acc/v13.1.0 - OK
# - a submodule must not have twice the same version (module version)
#   v1.0.0
#   sku/sal/v1.0.0 - WRONG
#   sku/sal/v1.0.1 - OK
# in:
#   $1 -- vbranch
#   $2 -- allowDuplicates (default to true in bundle, false in submodule)
#         true  : limit to vtags with same vbranch version and folder
#         false : take in account all vtags with same vbranch version
#         unset : true in bundle, false in submodule
#   $3 -- vnodes
#         true  : include vnodes
#         unset : skip vnodes
# stdout:
#   htag -- highest version tag
# exemple:
#   tags: v1.0.0 v1.0.1 v1.0.2 sku/v1.0.0 sku/v1.0.1
#   vtag_highest 1.0          -> v1.0.2
#   vtag_highest 1.0     true -> v1.0.2
#   vtag_highest sku/1.0      -> sku/v1.0.2 (does not exist - used as a base for next vtag computation)
#   vtag_highest sku/1.0 true -> sku/v1.0.1
vtag_highest()
{
  local vbranch=$1 allowDuplicates=$2 skipVNodes=$3

  if [[ $vbranch =~ ^(.*/)?([0-9]+\.[0-9]+) ]]; then
    local folder=${BASH_REMATCH[1]}
    local version=${BASH_REMATCH[2]}
    local regex
    [[ -z $allowDuplicates && $moduleRoot == $bundleRoot ]] && allowDuplicates=true
    if [[ $allowDuplicates == true ]]; then
      # restrict vtags to vbranch folder
      regex="^$(regex_escape $folder)v$(regex_escape $version)"
    else
      regex="^(.*/)?v$(regex_escape $version)"
    fi
    # io_trace "vtag_highest $(print_vars vbranch allowDuplicates skipVNodes regex)"
    local tags=() tag
    for tag in $(git tag -l "*v${version}*"); do
      [[ $tag =~ ^other/ ]] && continue
      [[ $skipVNodes == true && $tag =~ -@$ ]] && continue
      if [[ $tag =~ $regex ]]; then
        if [[ $allowDuplicates == true ]]; then
          tags+=( "$tag" )
        else
          # replace vtag folder with vbranch folder
          tags+=( "$folder${tag##*/}" )
        fi
      fi
    done
    vtag_highest_of "${tags[@]}"
  else
    io_error "vbranch invalid format : '$1'" "$moduleTracePrefix"
    return 1
  fi
}
vtag_group_by_version()
{
  declare -A lookup
  local vtag vbranch
  for vtag in $(git tag -l --sort=-v:refname); do
    # skip other tags
    ref_is_other $vtag && continue
    # skip non semver tags
    ! vtag_is_semver $vtag && continue
    vbranch="${BASH_REMATCH[1]}${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
    if [ -z "${lookup[$vbranch]}" ]; then
      lookup[$vbranch]=$vtag
    else
      lookup[$vbranch]="${lookup[$vbranch]} $vtag"
    fi
    # io_trace "vtag_group_by_version $(print_vars vbranch vtag)"
  done
  [ ${#lookup[@]} -eq 0 ] && echo 'declare -A lookup=()' || declare -p lookup
}
# out:
#   vtagGrouping
vtag_group_by_date_visitor()
{
  # assume caller has a vtagGrouping lookup defined
  local vtag vbranch
  if [ $# -eq 1 ]; then
    vtag=$1
    vbranch=$(vtag_get_vbranch_name $vtag)
    if [ -z "${vtagGrouping[$vbranch]}" ]; then
      vtagGrouping[$vbranch]=$vtag
    else
      vtagGrouping[$vbranch]="${vtagGrouping[$vbranch]} $vtag"
    fi
  else
    declare -A vlookup
    for vtag in "$@"; do
      vbranch=$(vtag_get_vbranch_name $vtag)
      if [ -z "${vlookup[$vbranch]}" ]; then
        vlookup[$vbranch]=$vtag
      else
        vlookup[$vbranch]="${vlookup[$vbranch]} $vtag"
      fi
    done
    # merge groupings
    for vbranch in ${!vlookup[@]}; do
      vtag=$(string_join '=' ${vlookup[$vbranch]})
      if [ -z "${vtagGrouping[$vbranch]}" ]; then
        vtagGrouping[$vbranch]=$vtag
      else
        vtagGrouping[$vbranch]="${vtagGrouping[$vbranch]} $vtag"
      fi
    done
    unset vlookup
  fi
}
vtag_group_by_date_filter()
{
  ! vtag_is_semver $1 && return 1
  ref_is_other $1 && return 1
  return 0
}
vtag_group_by_date()
{
  declare -A vtagGrouping
  vtag_visit_by_date vtag_group_by_date_visitor vtag_group_by_date_filter
  [ ${#vtagGrouping[@]} -eq 0 ] && echo 'declare -A vtagGrouping=()' || declare -p vtagGrouping
}
vtag_list_by_date_visitor() { (( $# > 1 )) && echo $(string_join '=' "$@") || echo $1; }
vtag_list_by_date() { vtag_visit_by_date vtag_list_by_date_visitor; }
vtag_visit_by_date()
{
  local visitor=$1
  local filter=$2
  local line atoms vtags item
  local IFS=$'\n'
  for line in $(git log --date-order --tags --simplify-by-decoration --pretty=format:'%d'); do
    local IFS=' '
    # look only for lines with a tag label
    [[ $line =~ tag: ]] || continue
    # remove parentheses
    [[ $line =~ \((.*)\) ]] && {
      line=${BASH_REMATCH[1]}
      # remove space between tag label and tag value ?
      line=${line//tag: /tag:}
      atoms=( ${line//, / } )
      vtags=()
      for item in "${atoms[@]}"; do
        [[ $item =~ ^tag:(.*) ]] && {
          item=${BASH_REMATCH[1]}
          if [[ -n $filter ]]; then
            $filter $item && vtags+=( $item )
          else
            vtags+=( $item )
          fi
        }
      done
      $visitor "${vtags[@]}"
    }
  done
}
# find first vtag ancestor starting from given commit
# input:
# - $1: branch symbol
# output:
# - vtag description (ex: v1.0.0-rc1-5-ge5d2fe9)
vtag_describe()
{
  local branch=$(git_symbolic_ref ${1:-HEAD}) match ltag stag skipVNode=$2 exclude=('other/*')
  [[ $skipVNode == true ]] && exclude+=('*-@')
  for match in $(ref_tag_fallback $branch 'v[0-9]*'); do
    ltag=$(git describe --tags --match "$match" ${exclude[@]/#/--exclude } "$branch" 2>/dev/null)
    if [[ -n $ltag ]]; then
      stag=${ltag%-*-g*}
      if git merge-base --is-ancestor $stag^{} $branch; then
        echo $ltag
        # io_trace "vtag_describe -> $(print_vars branch match ltag stag)"
        return 0
      fi
    fi
  done
  return 1
}
# list all vtags pointing at given commit
# input:
# - $1: rev to list
# output:
# - list of vtags pointing at given commit (ex: v1.0-@ v1.0.0-rc1 v1.0.0)
vtag_vtags_at()
{
  git tag --sort=-v:refname --points-at "${1:-HEAD}^{}" | grep -E '^(.*/)?v[0-9]+\.[0-9]+(\.|-)' | grep -v '^other/'
}
# get best match vtag at given commit
# input:
# - $1: branch (ex: sku/dev, master)
# output:
# - best match vtag  (ex: sku/dev -> sku/v1.0.0, master -> v2.0.0)
# io_info "vtag_best_match_vtag_at ${*@Q}" "$moduleTracePrefix"
vtag_best_match_vtag_at()
{
  local ref=$1 vtags hint reHint vHint tag
  vtags=( $(vtag_vtags_at $ref) )
  [ ${#vtags[@]} -eq 0 ] && return 1
  for hint in $(ref_tag_fallback $ref 'v'); do
    reHint=$(regex_escape "$hint")
    vHint="^${reHint}[0-9]+\.[0-9]+\.[0-9]+"
    # echo vtagHint=$vHint >&2
    for tag in ${vtags[@]}; do
      [[ $tag =~ $vHint ]] && { echo $tag; return 0; }
    done
    vHint="^${reHint}[0-9]+\.[0-9]+-@$"
    # echo vnodeHint=$vHint >&2
    for tag in ${vtags[@]}; do
      [[ $tag =~ $vHint ]] && { echo $tag; return 0; }
    done
  done
  echo "${vtags[0]}"
}
# extract vbranch name from vtag
# input:
# - $1: vtag (ex: v1.0.0-rc1)
# output:
# - vbranch name (ex: 1.0)
# - nothing if $1 is not a vtag
vtag_get_vbranch_name ()
{
  if [[ $1 =~ ^(.*/)?v([0-9]+)\.([0-9]+)(\.|-) ]]; then
    local prefix=${BASH_REMATCH[1]}
    local major=${BASH_REMATCH[2]}
    local minor=${BASH_REMATCH[3]}
    echo ${prefix}$major.$minor;
  fi
}
# find  local or remote vbranch - priority to local vbranch
# input:
# - $1: vtag (ex: v1.0.0-rc1)
# output:
# - local vbranch (ex: 1.0) if it exists
# - remote vbranch (ex: origin/1.0) if local vbranch does not exist
vtag_get_vbranch()
{
  local vtag=$1 vbranch
  vbranch=$(branch_realize $(vtag_get_vbranch_name $vtag))
  [ $? -le 1 ] && echo $vbranch
  io_warning "vtag_get_vbranch: vtag '$vtag' has no associated vbranch"
}
vtag_highest_of()
{
  # io_trace "vtag_highest_of ${*@Q}"
  if [ $# -eq 1 ]; then
    echo $1
  else
    local highest=$1 cc=0; shift
    while [[ -n $1 ]]; do
      vtag_compare $1 $highest
      [ $? -eq 1 ] && highest=$1
      shift
    done
    echo $highest
  fi
}
# output:
# - -1: $1 <  $2 (255)
# -  0: $1 == $2
# -  1: $1 >  $2
vtag_compare()
{
  if vtag_is_semver $1; then
    local major1=${BASH_REMATCH[2]}
    local minor1=${BASH_REMATCH[3]}
    local patch1=${BASH_REMATCH[5]}
    local prerel1=${BASH_REMATCH[6]}
    local prerelPrefix1=${BASH_REMATCH[7]}
    local prerelRev1=${BASH_REMATCH[8]}
    local meta1=${BASH_REMATCH[9]}
    if vtag_is_semver $2; then
      local major2=${BASH_REMATCH[2]}
      local minor2=${BASH_REMATCH[3]}
      local patch2=${BASH_REMATCH[5]}
      local prerel2=${BASH_REMATCH[6]}
      local prerelPrefix2=${BASH_REMATCH[7]}
      local prerelRev2=${BASH_REMATCH[8]}
      local meta2=${BASH_REMATCH[9]}

      [[ $1 == $2 ]] && return 0
      (( $major1 < $major2 )) && return -1
      (( $major1 > $major2 )) && return  1
      (( $minor1 < $minor2 )) && return -1
      (( $minor1 > $minor2 )) && return  1
      [[ -z $patch1 && -z $patch2 ]] && return  0  # both vnodes
      [[ -z $patch1 && -n $patch2 ]] && return -1
      [[ -n $patch1 && -z $patch2 ]] && return  1
      (( $patch1 < $patch2 )) && return -1
      (( $patch1 > $patch2 )) && return  1

      [[ $prerel1 == $prerel2 ]] && return 0
      [[ -n $prerel1 && -z $prerel2 ]] && return -1
      [[ -z $prerel1 && -n $prerel2 ]] && return  1
      [[ $prerelPrefix1 < $prerelPrefix2 ]] && return -1
      [[ $prerelPrefix1 > $prerelPrefix2 ]] && return  1
      (( prerelRev1 < prerelRev2 )) && return -1
      (( prerelRev1 > prerelRev2 )) && return  1

      [[ $meta1 == $meta2 ]] && return 0
      [[ -n $meta1 && -z $meta2 ]] && return  1
      [[ -z $meta1 && -n $meta2 ]] && return -1
      [[ $meta1 < $meta2 ]] && return -1
      [[ $meta1 > $meta2 ]] && return  1
      
      return 0
    else
      io_error "vtag_compare: invalid vtag format: $1" "$moduleTracePrefix"
    fi
  else
    io_error "vtag_compare: invalid vtag format: $1" "$moduleTracePrefix"
  fi
}
vtag_increment()
{
  local vtag=$1
  local prerel_prefix=$2
  local prerel_default rtm result
  [[ $prerel_prefix == 'rtm' ]] && { unset prerel_prefix; rtm=true; }
  [[ -n $prerel_prefix ]] && prerel_default=-${prerel_prefix}1

  io_debug vtag vtag_increment
  io_debug prerel_prefix vtag_increment
  io_debug prerel_default vtag_increment
  io_debug rtm vtag_increment

  #  <major>.<minor>-@
  #  <major>.<minor>.<patch>[-<pre-release>][+<meta>]-<delta>-g<sha1>
  if [[ $vtag =~ ^(.*/)?v([0-9]+)\.([0-9]+)(\.|-)(.*)$ ]]; then
    local prefix=${BASH_REMATCH[1]}
    local major=${BASH_REMATCH[2]}
    local minor=${BASH_REMATCH[3]}
    local patch=${BASH_REMATCH[5]}
    io_debug prefix vtag_increment
    io_debug major vtag_increment
    io_debug minor vtag_increment

    if [[ $patch == '@' ]]; then
      io_debug patch vtag_increment
      result="${prefix}v$major.$minor.0$prerel_default"
    elif [[ $patch =~ ^([0-9]+)(\.[0-9]+)?(-[[:alnum:]]+)?(\+.+)?$ ]]; then
      patch=${BASH_REMATCH[1]}
      local build=${BASH_REMATCH[2]}
      local prerel=${BASH_REMATCH[3]}
      local meta=${BASH_REMATCH[4]}
      io_debug patch vtag_increment
      io_debug build vtag_increment
      io_debug prerel vtag_increment
      io_debug meta vtag_increment
      if [[ $prerel =~ -(alpha|beta|rc)([0-9]*) ]]; then
        if [[ -n $rtm ]]; then
          result="${prefix}v$major.$minor.$patch"
        else
          local actual_prerel_prefix=${BASH_REMATCH[1]}
          local prerel_rev=${BASH_REMATCH[2]}
          io_debug actual_prerel_prefix vtag_increment
          io_debug prerel_rev vtag_increment
          if [[ $prerel_prefix > $actual_prerel_prefix ]]; then
            prerel_rev=1
          else
            prerel_prefix=$actual_prerel_prefix
            (( prerel_rev = prerel_rev + 1 ))
          fi
          prerel=-$prerel_prefix$prerel_rev
          io_debug prerel vtag_increment
          result="${prefix}v$major.$minor.$patch$prerel"
        fi
      else
        result="${prefix}v$major.$minor.$((patch+1))$prerel_default"
      fi
    fi
  fi
  if [[ -z $result ]]; then
    io_error "vtag_increment: wrong vtag format: $vtag" "$moduleTracePrefix"
  else
    echo $result
  fi
}

