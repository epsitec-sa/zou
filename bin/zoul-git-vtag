#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_VTAG ]] && . zoul-git-vtag
ZOUL_GIT_VTAG=true

[[ -z $ZOUL_CORE ]]     && . zoul-core
[[ -z $ZOUL_GIT_REF ]]  && . zoul-git-ref
[[ -z $ZOUL_GIT_CORE ]] && . zoul-git-core

vtag_get_patch() { vtag_is_semver $1 && echo ${BASH_REMATCH[5]}; } 
vtag_is_other()  { [[ $1 =~ ^other/ ]]; }
# input:
#   x/y/v1.2.3-rc4+meta
#   x/y/v1.2-@
# output:
#   folder=${BASH_RE_MATCH[1]}          x/y/
#   major=${BASH_RE_MATCH[2]}           1
#   minor=${BASH_RE_MATCH[3]}           2
#   tail=${BASH_RE_MATCH[4]}            .3-rc4+meta | -@
#   patch=${BASH_RE_MATCH[5]}           3
#   prerel=${BASH_RE_MATCH[6]}          -rc4
#   prerel-prefix=${BASH_RE_MATCH[7]}   -rc 
#   prerel-number=${BASH_RE_MATCH[8]}   4
#   meta=${BASH_RE_MATCH[9]}            +meta
vtag_is_semver() { [[ $1 =~ ^(.*/)?v([0-9]+).([0-9]+)(-@|.([0-9]+)((-alpha|-beta|-rc)([0-9]+))?(\+.+)?)$ ]]; }
vtag_is_vnode()  { [[ $1 =~ ^(.*/)?v[0-9]+\.[0-9]+-@ ]]; }
vtag_is_vtag()   { [[ $1 =~ ^(.*/)?v[0-9]+\.[0-9]+\.[0-9] ]]; }
vtag_at_vtag()
{
  local tag
  tag=$(git describe --exact-match "$1" 2>/dev/null) || return 1
  vtag_is_vtag "$tag" && echo $tag
}
vtag_list()
{
  # input             output
  # 1.0               v1.0-@ v1.0.0
  # sku/sal/1.0       sku/sal/v1.0-@
  local vbranch=$1
  local regex
  if [[ -z $vbranch ]]; then
    regex='v[0-9]+\.[0-9]+(\.|-)'
  elif [[ $vbranch =~ ^(.*/)?([0-9]+\.[0-9]+) ]]; then
    # vbranch
    local prefix=${BASH_REMATCH[1]}
    local version=${BASH_REMATCH[2]}
    regex="^$(regex_escape $prefix)v$(regex_escape $version)"
    # io_debug prefix vtag_list
    # io_debug version vtag_list
  else
    io_error "vtag invalid format : '$1'"
    return 1
  fi
  # io_debug regex vtag_list
  git tag -l --sort=-v:refname | grep -E $regex | grep -v '^other/' || true
}
vtag_group_by_version()
{
  declare -A lookup
  local vtag vbranch
  for vtag in $(git tag -l --sort=-v:refname); do
    # skip other tags
    vtag_is_other $vtag && continue
    # skip non semver tags
    ! vtag_is_semver $vtag && continue
    vbranch=$(vtag_get_vbranch_name $vtag)
    if [ -z "${lookup[$vbranch]}" ]; then
      lookup[$vbranch]=$vtag
    else
      lookup[$vbranch]="${lookup[$vbranch]} $vtag"
    fi
  done
  declare -p lookup
}
vtag_group_by_date_visitor()
{
  # assume caller has a vtagGrouping variable defined
  local vtag vbranch
  if [ $# -eq 1 ]; then
    vtag=$1
    vbranch=$(vtag_get_vbranch_name $vtag)
    if [ -z "${vtagGrouping[$vbranch]}" ]; then
      vtagGrouping[$vbranch]=$vtag
    else
      vtagGrouping[$vbranch]="${vtagGrouping[$vbranch]} $vtag"
    fi
  else
    declare -A vlookup
    for vtag in "$@"; do
      vbranch=$(vtag_get_vbranch_name $vtag)
      if [ -z "${vlookup[$vbranch]}" ]; then
        vlookup[$vbranch]=$vtag
      else
        vlookup[$vbranch]="${vlookup[$vbranch]} $vtag"
      fi
    done
    # merge groupings
    for vbranch in ${!vlookup[@]}; do
      vtag=$(string_join '=' ${vlookup[$vbranch]})
      if [ -z "${vtagGrouping[$vbranch]}" ]; then
        vtagGrouping[$vbranch]=$vtag
      else
        vtagGrouping[$vbranch]="${vtagGrouping[$vbranch]} $vtag"
      fi
    done
    unset vlookup
  fi
}
vtag_group_by_date_filter()
{
  ! vtag_is_semver $1 && return 1
  vtag_is_other $1 && return 1
  return 0
}
vtag_group_by_date()
{
  declare -A vtagGrouping
  vtag_visit_by_date vtag_group_by_date_visitor vtag_group_by_date_filter
  declare -p vtagGrouping
}
vtag_list_by_date_visitor() { (( $# > 1 )) && echo $(string_join '=' "$@") || echo $1; }
vtag_list_by_date() { vtag_visit_by_date vtag_list_by_date_visitor; }
vtag_visit_by_date()
{
  local visitor=$1
  local filter=$2
  local line atoms vtags item
  local IFS=$'\n'
  for line in $(git log --date-order --tags --simplify-by-decoration --pretty=format:'%d'); do
    local IFS=' '
    # look only for lines with a tag label
    [[ $line =~ tag: ]] || continue
    # remove parentheses
    [[ $line =~ \((.*)\) ]] && {
      line=${BASH_REMATCH[1]}
      # remove space between tag label and tag value ?
      line=${line//tag: /tag:}
      atoms=( ${line//, / } )
      vtags=()
      for item in "${atoms[@]}"; do
        [[ $item =~ ^tag:(.*) ]] && {
          item=${BASH_REMATCH[1]}
          if [[ -n $filter ]]; then
            $filter $item && vtags+=( $item )
          else
            vtags+=( $item )
          fi
        }
      done
      $visitor "${vtags[@]}"
    }
  done
}
vtag_most_recent()
{
  local vbranch=$(vtag_get_vbranch_name $1) vtag
  for vtag in $(vtag_list $vbranch); do
    # check if vtag is really more recent than given tag
    if git merge-base --is-ancestor "$1" "$vtag"; then
      echo $vtag
    else
      echo $1
    fi
    return 0;
  done
  echo $1
  return 1
}
# find first vtag ancestor starting from given commit
# input:
# - $1: branch symbol
# output:
# - vtag description (ex: v1.0.0-rc1-5-ge5d2fe9)
vtag_describe()
{
  local branch=$(git_symbolic_ref ${1:-HEAD}) match ltag stag
  for match in $(ref_tag_fallback $branch 'v[0-9]*'); do
    ltag=$(git describe --tags --match "$match" --exclude 'other/*' "$branch" 2>/dev/null)
    if [[ -n $ltag ]]; then
      stag=${ltag%-*-g*}
      # echo vtag_describe: git merge-base --is-ancestor $stag $branch >&2
      if git merge-base --is-ancestor $stag $branch; then
        echo $ltag
        return 0
      fi
    fi
  done
  return 1
}
# list all vtags pointing at given commit
# input:
# - $1: rev to list
# output:
# - list of vtags pointing at given commit (ex: v1.0-@ v1.0.0-rc1 v1.0.0)
vtag_vtags_at()
{
  git tag --sort=-v:refname --points-at "${1:-HEAD}^{}" | grep -E '^(.*/)?v[0-9]+\.[0-9]+(\.|-)' | grep -v '^other/'
}
# get best match vtag at given commit
# input:
# - $1: branch (ex: sku/dev, master)
# output:
# - best match vtag  (ex: sku/dev -> sku/v1.0.0, master -> v2.0.0)
# io_info "vtag_best_match_vtag_at ${*@Q}" "$moduleTracePrefix"
vtag_best_match_vtag_at()
{
  local ref=$1 vtags hint reHint vHint tag
  vtags=( $(vtag_vtags_at $ref) )
  [ ${#vtags[@]} -eq 0 ] && return 1
  for hint in $(ref_tag_fallback $ref 'v'); do
    reHint=$(regex_escape "$hint")
    vHint="^${reHint}[0-9]+\.[0-9]+\.[0-9]+"
    # echo vtagHint=$vHint >&2
    for tag in ${vtags[@]}; do
      [[ $tag =~ $vHint ]] && { echo $tag; return 0; }
    done
    vHint="^${reHint}[0-9]+\.[0-9]+-@$"
    # echo vnodeHint=$vHint >&2
    for tag in ${vtags[@]}; do
      [[ $tag =~ $vHint ]] && { echo $tag; return 0; }
    done
  done
  echo "${vtags[0]}"
}
# extract vbranch name from vtag
# input:
# - $1: vtag (ex: v1.0.0-rc1)
# output:
# - vbranch name (ex: 1.0)
# - nothing if $1 is not a vtag
vtag_get_vbranch_name ()
{
  if [[ $1 =~ ^(.*/)?v([0-9]+)\.([0-9]+)(\.|-) ]]; then
    local prefix=${BASH_REMATCH[1]}
    local major=${BASH_REMATCH[2]}
    local minor=${BASH_REMATCH[3]}
    echo ${prefix}$major.$minor;
  fi
}
# find  local or remote vbranch - priority to local vbranch
# input:
# - $1: vtag (ex: v1.0.0-rc1)
# output:
# - local vbranch (ex: 1.0) if it exists
# - remote vbranch (ex: origin/1.0) if local vbranch does not exist
vtag_get_vbranch()
{
  local vtag=$1
  local vbranch=$(vtag_get_vbranch_name $vtag)
  if [[ -n $(git show-ref refs/heads/$vbranch) ]]; then
    # local vbranch
    echo $vbranch
    return 0
  else
    # local vbranch not found try remote vbranch
    vbranch=$(git remote)/$vbranch
    if [[ -n $(git show-ref refs/remotes/$vbranch) ]]; then
      echo $vbranch
    else
      io_warning "vtag_get_vbranch: vtag '$vtag' has no associated vbranch"
    fi
    return 1
  fi
}
# get the vbranch tail starting from commit1 and containing commit2
# input:
# - $1: rev that points to the start of the tail (can be tagged with multiple vtags)
# output
# - [0]: the vtag that starts the vbranch tail
# - [1]: the vbranch that contains the given vbranch marker
# - [2]: a status (empty|full) indicating if the vbranch tail does not contain any vtag
vtag_get_vbranch_tail()
{
  # io_message "vtag_get_vbranch_tail ${*@Q}" "$moduleTracePrefix" Gray

  local vtag=$(vtag_best_match_vtag_at $1)
  [[ -z $vtag ]] && return 1
  io_debug vtag vtag_get_vbranch_tail
  
  local vbranch=$(vtag_get_vbranch $vtag)
  [[ -z $vbranch ]] && return 1
  io_debug vbranch vtag_get_vbranch_tail
  local status='empty'
  if ! vtag_is_vnode $vtag; then
    local hash1=$(git_get_commit "$vtag")
    local hash2=$(git_get_commit "$vbranch")
    [[ $hash1 == $hash2 ]] && status='full'
  fi
  echo $vtag $vbranch $status
}
vtag_get_next_vtag()
{
  io_message "vtag_get_next_vtag ${*@Q}" "$moduleTracePrefix" Gray

  local vtag=$1 vbranch=$2 previous lbranch
  [[ -z $vbranch ]] && vbranch=$(vtag_get_vbranch $vtag) 
  # return 1 if vbranch is a remote branch
  [ $? -eq 0 ] && lbranch=$vbranch || lbranch=${vbranch#*/} # remove remote prefix
  # io_debug 'vbranch' 'vtag_get_next_vtag'
  for current in $(vtag_list "$lbranch"); do
    if [[ $current == $vtag ]]; then
      if [[ -n $previous ]]; then
        # previous should be a descendant of vtag
        git merge-base --is-ancestor "$vtag" "$previous" >&2
        if (( $? == 0 )); then
          # previous should be an ancestor of vbranch
          git merge-base --is-ancestor "$previous" "$vbranch" >&2
          (( $? == 0 )) && echo $previous || io_error "vtag_get_next_vtag: $previous is not an ancestor of vbranch $vbranch"
        else
          io_error "vtag_get_next_vtag: $vtag is not an ancestor of $previous"
        fi
      fi
    else
      previous=$current
    fi
  done
}
vtag_compare_prerel()
{
  local p1=$1
  local p2=$2
  
  io_debug p1 vtag_compare_prerel
  io_debug p2 vtag_compare_prerel

  [[ $p1 == $p2 ]] && return 0
  [[ -n $p1 && -z $p2 ]] && return -1
  [[ -z $p1 && -n $p2 ]] && return 1

  local r1; local r2

  if [[ $p1 =~ ^-([[:alpha:]]+)([0-9]+) ]]; then
    p1=${BASH_REMATCH[1]}
    r1=${BASH_REMATCH[2]}
    io_debug p1 vtag_compare_prerel
    io_debug r1 vtag_compare_prerel
  fi
  if [[ $p2 =~ ^-([[:alpha:]]+)([0-9]+) ]]; then
    p2=${BASH_REMATCH[1]}
    r2=${BASH_REMATCH[2]}
    io_debug p2 vtag_compare_prerel
    io_debug r2 vtag_compare_prerel
  fi
  [[ $p1 < $p2 ]] && return -1
  [[ $p1 > $p2 ]] && return 1
  (( r1 < r2 )) && return -1
  (( r1 > r2 )) && return 1

  return 0
}
vtag_highest()
{
  if [ $# -eq 1 ]; then
    echo $1
  else
    local highest=$1 cc=0; shift
    while [[ -n $1 ]]; do
      vtag_compare $1 $highest
      [ $? -eq 1 ] && highest=$1
      shift
    done
    echo $highest
  fi
}
# output:
# - -1: $1 <  $2 (255)
# -  0: $1 == $2
# -  1: $1 >  $2
vtag_compare()
{
  if [[ $1 =~ ^(.*/)?v([0-9]+)\.([0-9]+)\.([0-9]+)(-[[:alnum:]]+)?(\+.+)?$ ]]; then
    local major1=${BASH_REMATCH[2]}
    local minor1=${BASH_REMATCH[3]}
    local patch1=${BASH_REMATCH[4]}
    local prerel1=${BASH_REMATCH[5]}
    local meta1=${BASH_REMATCH[6]}
    if [[ $2 =~ ^(.*/)?v([0-9]+)\.([0-9]+)\.([0-9]+)(-[[:alnum:]]+)?(\+.+)?$ ]]; then
      local major2=${BASH_REMATCH[2]}
      local minor2=${BASH_REMATCH[3]}
      local patch2=${BASH_REMATCH[4]}
      local prerel2=${BASH_REMATCH[5]}
      local meta2=${BASH_REMATCH[6]}

      (( $major1 < $major2 )) && return -1
      (( $major1 > $major2 )) && return  1
      (( $minor1 < $minor2 )) && return -1
      (( $minor1 > $minor2 )) && return  1
      (( $patch1 < $patch2 )) && return -1
      (( $patch1 > $patch2 )) && return  1

      io_debug prerel1 vtag_compare
      io_debug prerel2 vtag_compare
      io_debug meta1 vtag_compare
      io_debug meta2 vtag_compare

      vtag_compare_prerel "$prerel1" "$prerel2"; local result=$?
      (( $result == 255 )) && return -1
      (( $result ==   1 )) && return  1

      [[ $meta1 == $meta2 ]] && return 0
      [[ -n $meta1 && -z $meta2 ]] && return 1
      [[ -z $meta1 && -n $meta2 ]] && return -1
      [[ $meta1 < $meta2 ]] && return -1
      [[ $meta1 > $meta2 ]] && return 1
      
      return 0
    else
      io_error "vtag_compare: invalid vtag format: $2" "$moduleTracePrefix"
    fi
  else
    io_error "vtag_compare: invalid vtag format: $1" "$moduleTracePrefix"
  fi
}
vtag_increment()
{
  local vtag=$1
  local prerel_prefix=$2
  local prerel_default rtm result
  [[ $prerel_prefix == 'rtm' ]] && { unset prerel_prefix; rtm=true; }
  [[ -n $prerel_prefix ]] && prerel_default=-${prerel_prefix}1

  io_debug vtag vtag_increment
  io_debug prerel_prefix vtag_increment
  io_debug prerel_default vtag_increment
  io_debug rtm vtag_increment

  #  <major>.<minor>-@
  #  <major>.<minor>.<patch>[-<pre-release>][+<meta>]-<delta>-g<sha1>
  if [[ $vtag =~ ^(.*/)?v([0-9]+)\.([0-9]+)(\.|-)(.*)$ ]]; then
    local prefix=${BASH_REMATCH[1]}
    local major=${BASH_REMATCH[2]}
    local minor=${BASH_REMATCH[3]}
    local patch=${BASH_REMATCH[5]}
    io_debug prefix vtag_increment
    io_debug major vtag_increment
    io_debug minor vtag_increment

    if [[ $patch == '@' ]]; then
      io_debug patch vtag_increment
      result="${prefix}v$major.$minor.0$prerel_default"
    elif [[ $patch =~ ^([0-9]+)(\.[0-9]+)?(-[[:alnum:]]+)?(\+.+)?$ ]]; then
      patch=${BASH_REMATCH[1]}
      local build=${BASH_REMATCH[2]}
      local prerel=${BASH_REMATCH[3]}
      local meta=${BASH_REMATCH[4]}
      io_debug patch vtag_increment
      io_debug build vtag_increment
      io_debug prerel vtag_increment
      io_debug meta vtag_increment
      if [[ $prerel =~ -(alpha|beta|rc)([0-9]*) ]]; then
        if [[ -n $rtm ]]; then
          result="${prefix}v$major.$minor.$patch"
        else
          local actual_prerel_prefix=${BASH_REMATCH[1]}
          local prerel_rev=${BASH_REMATCH[2]}
          io_debug actual_prerel_prefix vtag_increment
          io_debug prerel_rev vtag_increment
          if [[ $prerel_prefix > $actual_prerel_prefix ]]; then
            prerel_rev=1
          else
            prerel_prefix=$actual_prerel_prefix
            (( prerel_rev = prerel_rev + 1 ))
          fi
          prerel=-$prerel_prefix$prerel_rev
          io_debug prerel vtag_increment
          result="${prefix}v$major.$minor.$patch$prerel"
        fi
      else
        result="${prefix}v$major.$minor.$((patch+1))$prerel_default"
      fi
    fi
  fi
  if [[ -z $result ]]; then
    io_error "vtag_increment: wrong vtag format: $vtag" "$moduleTracePrefix"
  else
    echo $result
  fi
}

