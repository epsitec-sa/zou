#!/bin/bash

[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_BRANCH_MERGE ]]  && . zoul-git-branch-merge
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

dev_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -v*)            dev_parse_default_version "$1";;
    -r|--recursive) recursive=true;;
    --minor)        incrementKind='minor';;
    --major)        incrementKind='major';;
    attach)         subcommand=$1;;
    enter)          subcommand=$1;;
    release)        subcommand=$1;;
    --)             shift; break;;
    -*) io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'release' 'attach'
  cmd_check_args "${args[@]}"
  
  devModulePaths=( "$@" )
  # io_trace "dev_parse -- $(print_vars recursive subcommand devModulePaths[@])"
}
dev_parse_default_version()
{
  local version=${1#-v}
  if [[ $version =~ ^[0-9]+\.[0-9]+$ ]]; then
    defaultVersion=$version
  else
    io_error "wrong version format ${VC}$version${Red} - should be <major>.<minor>"
    exit 1
  fi
}
dev_run()
{
  # parse command line
  local jobsCount recursive command='dev' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        incrementKind defaultVersion='0.1' devModulePaths=()

  dev_parse "$@" || return $?
  
  case $subcommand in
    attach)  startupMessage="Attaching to development, please wait...";;
    enter)   startupMessage="Entering development, please wait...";;
    release) startupMessage="Releasing development, please wait...";;
  esac

  module_run "${cmdScopes[@]}" dev_command
}
dev_command()
{
  [ ${#devModulePaths[@]} -eq 0 ] && devModulePaths+=( './' )
  cmd_register_module_paths "$recursive" "${devModulePaths[@]}"
  case $subcommand in
    attach|enter) cmd_register_module_paths false "$bundleRoot";;
  esac

  cmd_visit_modules
}

########
# ATTACH
########

dev_attach_epilog()
{
  module_dev_attach true
  branch_show_status || io_trace_error 'dev_attach_epilog'
}

#######
# ENTER
#######

dev_enter_epilog()
{
  dev_checkout true
  branch_show_status || io_trace_error 'dev_attach_epilog'
}

#########
# RELEASE
#########

dev_release_epilog()
{
  # release only modules in dev mode
  _dev_check_in_dev_mode || return 0

  # a submodule can create a vbranch in the bundle without refreshing the prod scope (run in a subshell)
  # io_trace "dev_release_epilog -- $(print_vars moduleDevBranchPath prodBranchPath)"
  module_is_bundle && _cmd_is_recursive && prod_reset_scope
  if [[ -n $incrementKind ]] || cosm_has_submodules_to_commit || ! ref_equals "$moduleDevBranchPath" "$prodBranchPath"; then
    dev_checkout false "$moduleDevBranch"
    prod_ensure_vbranch "$defaultVersion" "$incrementKind"
    cosm_commit_unstaged_clean_submodules
    branch_merge "$moduleDevBranchPath" "$prodBranchPath" '-Xtheirs' || io_trace_error 'dev_release_epilog'
  else
    mio_message "Already released" ${LightBlue}
  fi
}
_dev_check_in_dev_mode()
{
  module_in_strict_dev_mode && return 0
  ! module_is_startup && return 0
  mio_warning "Use ${VC}git dev enter${Brown} to switch to development"
  return 1
}

dev_run  "$@"
