#!/usr/bin/env bash

[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_CONFIG_SKU ]]    && . zoul-git-config-sku

prodPreinitEvent+=( _sku_on_prod_preinit )

sku_parse()
{
  local args=()
  while [[ "$#" -gt 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    -a|--all)       noSkuFilter=true;;
    --vlast)        checkoutType='vlast';;
    --vnext)        checkoutType='vnext';;
    --dev)          checkoutType='dev';;
    enter)          subcommand=$1;;
    info)           subcommand=$1;;
    config)         subcommand=$1;;
    -l|--list)      skuConfigListOnly=true;;
    -i|--include)   [[ $skuConfigMode == 'skuConfigExclude' ]] && { io_error 'options conflict'; exit 1; } || skuConfigMode='include';;
    -x|--exclude)   [[ $skuConfigMode == 'skuConfigInclude' ]] && { io_error 'options conflict'; exit 1; } || skuConfigMode='exclude';;
    -m|--pmid)      shift; configPrincipalModuleId=$1;;
    --)             shift; break;;
    -*)             io_error "unknown option ${VC}$1${Red}\n"; io_help $0; return 1;;
    *)
      case "$skuConfigMode" in
        include) skuConfigInclude+=($1);;
        exclude) skuConfigExclude+=($1);;
        *) args+=( "$1" );;
      esac
  esac; shift; done

  cmd_check_subcommand 'enter' 'info' 'config'
  if [[ -n $recursive && -n $skuConfigMode && -z $skuConfigListOnly ]]; then
    io_error 'recursive option cannot be used when modifying configuration'
    io_message " use ${VC}-l${LightCyan} or ${VC}--list${LightCyan} to list configuration"
    exit 1
  fi

  skuModulePaths=( "$@" )
  sku_parse_sku "${args[@]}"
  cmd_check_args "${args[@]:1}"
  # io_trace "sku_parse -- $(print_vars skuSpec vnext subcommand skuModulePaths[@])"
}
sku_parse_sku()
{
  # skip options
  [[ ${1:0:1} == '-' ]] && return 1
  skuSpec=$1
}
sku_run()
{
  # parse command line
  local jobsCount recursive command='sku' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        skuConfigListOnly skuConfigMode skuConfigInclude=() skuConfigExclude=() configPrincipalModuleId \
        noSkuFilter skuSpec skuModulePaths=() \
        checkoutType='dev'

  sku_parse "$@" || return $?
  sku_startup_message

  bundle_scope sku_command
}
sku_startup_message()
{
  case $subcommand in
    enter)
      local what;
      case "$checkoutType" in
        dev)   what='development';;
        vnext) what='next version';;
        vlast) what='last version';;
      esac
      startupMessage="Entering ${Brown}$what${White} on ${Brown}${skuSpec:-current SKU}${White}, please wait..."
      ;;
    info)
      startupMessage="Getting SKU info, please wait..."
      ;;
    config)
      local kindOf
      if [[ -n $configPrincipalModuleId ]]; then
          startupMessage="Setting ${Brown}$configPrincipalModuleId${White} as principal module, please wait..."
      else
        case $skuConfigMode in
          include) kindOf="${Green}included${White}";;
          exclude) kindOf="${Purple}excluded${White}";;
          *)       kindOf="${Green}included${White} and ${Purple}excluded${White}";;
        esac
        if [[ -n $skuConfigListOnly || -z $skuConfigMode ]]; then
          startupMessage="Displaying $kindOf submodules, please wait..."
        else
          startupMessage="Configuring $kindOf submodules, please wait..."
        fi
      fi
      ;;
  esac
}
sku_command()
{
  local sku
  branch_set_bestmatch_sku "$skuSpec"
  # io_trace "sku_command -- $(print_vars skuSpec sku subcommand skuModulePaths[@])"

  case "$subcommand" in
    enter)
      cmd_register_module_paths true  "$bundleRoot"
      noSubmodulesInit=true
      ;;
    info)
      [ ${#skuModulePaths[@]} -eq 0 ] && skuModulePaths+=( './' )
      cmd_register_module_paths false "$bundleRoot"
      cmd_register_module_paths "$recursive" "${skuModulePaths[@]}"
      ;;
    config)
      [ ${#skuModulePaths[@]} -eq 0 ] && skuModulePaths+=( './' )
      cmd_register_module_paths "$recursive" "${skuModulePaths[@]}"
      ;;
  esac

  cmd_visit_modules
}

_sku_on_prod_preinit() { prodCheckoutType=$checkoutType; }

sku_enter_finally()  { _sku_any_finally; }
sku_info_finally()   { _sku_any_finally; }
sku_config_finally() { _sku_any_finally; }

_sku_any_finally()
{
  config_sku_update
  branch_show_status
}

#######
# ENTER
#######

sku_enter_prolog()
{
  local moduleSku='master'
  ( [[ $moduleInSku == true ]] || module_is_bundle ) && moduleSku="$sku"
  # io_trace "sku_enter_prolog -- $(print_vars moduleSku)"
  sku_checkout "$moduleSku" "$prodCheckoutType" true
  module_sync_upd_sync_uninitialized_submodules

  cosm_discard_unstaged_clean_external_submodules
  notes_pull_all
}

######
# INFO
######

sku_info_prolog()
{
  local label sku skus=() acolor=${LightGreen} icolor=${DarkGray} bcolor=${Cyan}
  for sku in $(branch_list_all_flatten); do
    [[ $sku =~ ^(master|sku/.*dev)$ ]] || continue
    skus+=( "$sku" )
  done
  if [ ${#skus[@]} -gt 0 ]; then
    local i skuList skuName devBranch=$(wip_to_ref $moduleDevBranch)
    for i in "${!skus[@]}"; do
      sku=${skus[$i]}
      skuName=${sku%/dev}
      skuName=${skuName#sku/}
      # io_trace "sku_info_prolog -- $(print_vars sku skuName moduleDevBranch)"
      if [[ $sku == $devBranch ]]; then
        skus[$i]=${acolor}$skuName${bcolor}
      else
        skus[$i]=${icolor}$skuName${bcolor}
      fi
    done
    skuList=$(string_join ', ' $(array_sort skus[@]))
  fi

  mio_message "[${skuList}]" "${bcolor}"
}

########
# CONFIG
########

sku_config_select()
{
  local submodules=("${!1}")
  # io_trace "sku_config_select -- $(print_vars submodules[@])"

  # visit only submodules that contains submodules
  for sm in ${submodules[@]}; do
    [[ -f "$PWD/$sm/.gitmodules" ]] && echo $sm
  done
}
sku_config_prolog()
{
  if [ -z $skuConfigListOnly ]; then
    case "$skuConfigMode" in
      include) config_sku_include "${skuConfigInclude[@]}";;
      exclude) config_sku_exclude "${skuConfigExclude[@]}";;
    esac
  fi

  if [[ -n $configPrincipalModuleId ]]; then
    if [ -d "$bundleRoot/$configPrincipalModuleId" ]; then
      config_sku_set_principal_module_id "$configPrincipalModuleId"
      principalModuleId="$configPrincipalModuleId"
    else
      io_error "module not found: '$configPrincipalModuleId'"
      exit 1
    fi
    config_sku_status 'pmid'
  else
    config_sku_status "$skuConfigMode"
  fi
}

#########
# HELPERS
#########

# usage:
#   local sku
#   branch_set_bestmatch_sku $skuSpec
# in:
#   skuSpec=$1  -- SKU dev branch spec (fact/std, fact/net, ...)
# out:
#   sku
branch_set_bestmatch_sku()
{
  local skuSpec=$1
  if [[ -z $skuSpec ]]; then
    sku=$bundleDevBranch
  elif [[ "$moduleRoot" == "$bundleRoot" ]]; then
    _branch_set_bestmatch_sku_core
  else
    cd "$bundleRoot"
    _branch_set_bestmatch_sku_core
    cd "$moduleRoot"
  fi
}
_branch_set_bestmatch_sku_core()
{
  if branch_exists "$skuSpec"; then
    sku=$skuSpec
  else
    local branch candidates=() resku="^(.*/)?$(wildcard_to_regex "$skuSpec")(/.*)?$"
    for branch in $(branch_list_all_flatten); do
      [[ $branch =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && continue   # skip prod branches
      [[ $branch =~ $resku ]] && candidates+=( "$branch" )
      # io_trace "_branch_set_bestmatch_sku_core -- $(print_vars branch candidates[@])"
    done
    case ${#candidates[@]} in
      0) io_error "SKU ${VC}$skuSpec${Red} does not exist." "fatal"; exit 1;;
      1) sku=${candidates[0]};;
      *)
        local skuCandidates=() c
        for c in "${candidates[@]}"; do
          [[ $c =~ ^sku/ ]] && skuCandidates+=( "$c" )
        done
        case ${#skuCandidates[@]} in
          1) sku=${skuCandidates[0]};;
          *) io_error "SKU ${VC}$skuSpec${Red} is ambiguous, use one of (${VC}$(string_join ', ' "${candidates[@]}")${Red})"; exit 1;;
        esac
    esac
  fi
}

sku_run  "$@"
