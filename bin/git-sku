#!/bin/bash

[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_COSM ]]          && . zoul-git-cosm
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select
[[ -z $ZOUL_GIT_CONFIG_SKU ]]    && . zoul-git-config-sku

sku_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)            jobsCount=${1#-j};;
    -r|--recursive) recursive=true;;
    -a|--all)       noSkuFilter=true;;
    --vnext)        checkoutType='vnext';;
    --dev)          checkoutType='dev';;
    enter)          subcommand=$1;;
    info)           subcommand=$1;;
    config)         subcommand=$1;;
    -i|--include)   [[ $configMode == 'configExclude' ]] && { io_error 'options conflict'; exit 1; } || configMode='configInclude';;
    -x|--exclude)   [[ $configMode == 'configInclude' ]] && { io_error 'options conflict'; exit 1; } || configMode='configExclude';;
    --)             shift; break;;
    -*) io_error "unknown option '$1'"; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'info' 'config'
  
  skuModulePaths=( "$@" )
  sku_parse_sku "${args[@]}"
  cmd_check_args "${args[@]:1}"
  # io_trace "sku_parse -- $(print_vars skuSpec vnext subcommand skuModulePaths[@])"
}
sku_parse_sku()
{
  # skip options
  [[ ${1:0:1} == '-' ]] && return 1
  skuSpec=$1
}
sku_run()
{
  # parse command line
  local jobsCount recursive=false command='sku' subcommand \
        cmdScopes=( prod_scope config_scope cosm_scope ) \
        configMode='status' configInclude=() configExclude=() \
        checkoutType='vtag' noSkuFilter skuSpec skuModulePaths=()

  sku_parse "$@" || return $?
  
  case $subcommand in
    enter) startupMessage="Entering ${Brown}${skuSpec:-current SKU}${White}, please wait...";;
    info)  startupMessage="Getting SKU info, please wait...";;
  esac

  module_run "${cmdScopes[@]}" sku_command
}

sku_command()
{
  local sku
  branch_set_bestmatch_sku "$skuSpec"
  # io_trace "sku_command -- $(print_vars skuSpec sku subcommand skuModulePaths[@])"

  case "$subcommand" in
    enter)
      cmd_register_module_paths true  "$bundleRoot";;
    info)
      [ ${#skuModulePaths[@]} -eq 0 ] && skuModulePaths+=( './' )
      cmd_register_module_paths false "$bundleRoot"
      cmd_register_module_paths "$recursive" "${skuModulePaths[@]}"
      ;;
    config)
      [ ${#skuModulePaths[@]} -eq 0 ] && skuModulePaths+=( './' )
      cmd_register_module_paths "$recursive" "${skuModulePaths[@]}"
      ;;
  esac

  cmd_visit_modules
}

#######
# ENTER
#######

sku_enter_prolog() { sku_checkout "$sku" "$checkoutType" true; }
sku_enter_epilog() { branch_show_status; }

######
# INFO
######

sku_info_prolog()
{
  local label sku skus=() acolor=${LightGreen} icolor=${DarkGray} bcolor=${Cyan}
  for sku in $(branch_list_all_flatten); do
    [[ $sku =~ ^(master|sku/.*dev)$ ]] || continue
    skus+=( "$sku" )
  done
  if [ ${#skus[@]} -gt 0 ]; then
    local i skuList skuName devBranch=$(wip_to_ref $moduleDevBranch)
    for i in "${!skus[@]}"; do
      sku=${skus[$i]}
      skuName=${sku%/dev}
      skuName=${skuName#sku/}
      # io_trace "sku_info_prolog -- $(print_vars sku skuName moduleDevBranch)"
      if [[ $sku == $devBranch ]]; then
        skus[$i]=${acolor}$skuName${bcolor}
      else
        skus[$i]=${icolor}$skuName${bcolor}
      fi
    done
    skuList=$(string_join ', ' $(array_sort skus[@]))
  fi

  mio_message "[${skuList}]" "${bcolor}"
}
sku_info_epilog() { branch_show_status; }

########
# CONFIG
########

sku_config_prolog()
{
  if [ ${#configInclude[@]} -ne 0 ]; then
    if [ ${#configInclude[@]} -eq 1 ]; then
      config_sku_include "${configInclude[0]}"
    else
      config_sku_include_many "${configInclude[@]}"
    fi
  fi
  if [ ${#configExclude[@]} -ne 0 ]; then
    if [ ${#configExclude[@]} -eq 1 ]; then
      config_sku_exclude "${configExclude[0]}"
    else
      config_sku_exclude_many "${configExclude[@]}"
    fi
  fi

  case "$configMode" in
    configInclude) [ ${#configInclude[@]} -eq 0 ] && config_sku_include_all;;
    configExclude) [ ${#configExclude[@]} -eq 0 ] && config_sku_exclude_all;;
  esac

  config_sku_status
}

#########
# HELPERS
#########

# usage:
#   local sku
#   branch_set_bestmatch_sku $skuSpec
# in:
#   skuSpec=$1  -- SKU dev branch spec (fact/std, fact/net, ...)
# out:
#   sku
branch_set_bestmatch_sku()
{
  local skuSpec=$1
  if [[ -z $skuSpec ]]; then
    sku=$bundleDevBranch
  elif [[ "$moduleRoot" == "$bundleRoot" ]]; then
    _branch_set_bestmatch_sku_core
  else
    cd "$bundleRoot"
    _branch_set_bestmatch_sku_core
    cd "$moduleRoot"
  fi
}
_branch_set_bestmatch_sku_core()
{
  if branch_exists "$skuSpec"; then
    sku=$skuSpec
  else
    local branch candidates=() resku="^(.*/)?$(wildcard_to_regex "$skuSpec")(/.*)?$"
    for branch in $(branch_list_all_flatten); do
      [[ $branch =~ ^(.*/)?[0-9]+\.[0-9]+ ]] && continue   # skip prod branches
      [[ $branch =~ $resku ]] && candidates+=( "$branch" )
      # io_trace "_branch_set_bestmatch_sku_core -- $(print_vars branch candidates[@])"
    done
    case ${#candidates[@]} in
      0) io_error "SKU ${VC}$skuSpec${Red} does not exist." "fatal"; exit 1;;
      1) sku=${candidates[0]};;
      *)
        local skuCandidates=() c
        for c in "${candidates[@]}"; do
          [[ $c =~ ^sku/ ]] && skuCandidates+=( "$c" )
        done
        case ${#skuCandidates[@]} in
          1) sku=${skuCandidates[0]};;
          *) io_error "SKU ${VC}$skuSpec${Red} is ambiguous, use one of (${VC}$(string_join ', ' "${candidates[@]}")${Red})"; exit 1;;
        esac
    esac
  fi
}

sku_run  "$@"
