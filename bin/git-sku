#!/bin/bash

[[ -z $ZOUL_GIT_CMD ]]           && . zoul-git-cmd
[[ -z $ZOUL_GIT_PROD ]]          && . zoul-git-prod
[[ -z $ZOUL_GIT_BRANCH_SELECT ]] && . zoul-git-branch-select

sku_parse()
{
  local args=()
  while [[ "$#" > 0 ]]; do case "$1" in
    -h|--help) zou-help $0; exit 0;;
    -j*)      jobsCount=${1#-j};;
    -a|--all) noSkuFilter=true;;
    --vnext)  vnext=true;;
    enter)    subcommand=$1; sku_parse_sku $2 && shift;;
    status)   subcommand=$1;;
    --)       shift; break;;
    -*) io_error "unknown option '$1'"; return 1;;
    *)  args+=( "$1" );;
  esac; shift; done

  cmd_check_subcommand 'enter' 'status'
  cmd_check_args "${args[@]}"
  cmd_register_module_paths "$@"
  # io_trace "sku_parse -- $(print_vars skuSpec vnext subcommand cmdModulePaths[@])"
}
sku_parse_sku()
{
  # skip options
  [[ ${1:0:1} == '-' ]] && return 1
  skuSpec=$1
}
sku_run()
{
  # parse command line
  local jobsCount recursive command='sku' subcommand cmdModulePaths=() \
        cmdScopes=( prod_scope config_scope ) \
        vnext noSkuFilter skuSpec

  sku_parse "$@" || return $?
  
  case $subcommand in
    enter)  startupMessage="Entering ${Brown}$sku${White}, please wait...";;
    status) startupMessage="Getting SKU status, please wait...";;
  esac

  module_run "${cmdScopes[@]}" sku_command
}

sku_command()
{
  local sku
  branch_set_bestmatch_sku "$skuSpec"
  # io_trace "sku_command -- $(print_vars skuSpec sku subcommand cmdModulePaths[@])"

  case "$subcommand" in
    enter)  cmd_visit_bundle true;;
    status) cmd_visit_bundle && cmd_visit_modules_level1 true;;
  esac
}

sku_enter_prolog() { sku_checkout "$sku" "$vnext" true; }
sku_status_prolog()
{
  local sku skus=()
  for sku in $(branch_list_all_flatten); do
    if [[ $sku == 'sku/dev' ]]; then
      skus+=( 'sku' )
    elif [[ $sku =~ ^sku/(.+)/dev$ ]]; then
      skus+=( "${BASH_REMATCH[1]}" )
    fi
  done 
  mio_info "Available SKUs (${VC}$(string_join ', ' $(array_sort skus[@]))${Cyan})"
}

sku_run  "$@"
