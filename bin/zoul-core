#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_CORE ]] && . zoul-core
ZOUL_CORE=true

# declare startup constants
zou_startupPath=$(realpath "${BASH_SOURCE[-1]}")
zou_startupFileName="${zou_startupPath##*/}"
if [[ "$zou_startupFileName" == bashdb ]]; then
  zou_startupPath=$(realpath "${BASH_SOURCE[-2]}")
  zou_startupFileName="${zou_startupPath##*/}"
fi
zou_startupDir="${zou_startupPath%/*}"
zou_binDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
zou_command="${zou_startupFileName##git-}"

io_print_colors()
{
  local color colors=()
  for color in Black DarkGray Red LightRed Green LightGreen Brown Yellow Blue LightBlue Purple LightPurple Cyan LightCyan LightGray White; do
    colors+=( ${!color}$color )
  done
  printf '%20b%20b\n' "${colors[@]}"
}
# colors usage
#   colors="${Red}Red ${Green}Green${NC}"
#   printf '%b\n' "$message"
NC='\e[0m'  # No Color
Black='\e[0;30m'     DarkGray='\e[1;30m'
Red='\e[0;31m'       LightRed='\e[1;31m'
Green='\e[0;32m'     LightGreen='\e[1;32m'
Brown='\e[0;33m'     Yellow='\e[1;33m'
Blue='\e[0;34m'      LightBlue='\e[1;34m'
Purple='\e[0;35m'    LightPurple='\e[1;35m'
Cyan='\e[0;36m'      LightCyan='\e[1;36m'
LightGray='\e[0;37m' White='\e[1;37m'

# usage: io_message <message> [<label> [<color=LightCyan>]]
# example:
#   $ io_message 'message' 'info' Cyan
#   -> info: message
#   $ io_message 'message' '' Gray
#   -> message
io_message()
{
  local message=$1 label=$2 color=${3:-Cyan}
  if [[ -n $label ]]; then
    if [[ $label =~ ^\\e\[[0-9] ]]; then
      # colored label 
      message="$label : ${!color}$message${NC}"
    else
      # no label color
      message="${!color}$label${NC} : ${!color}$message${NC}"
    fi
  else
    message="${!color}$message${NC}"
  fi
  printf "%b\n" "$message" 1>&2
}
io_info()     { io_message "$1" "${2:-info}"; }
io_success()  { io_message "$1" "${2:-info}" Green; }
io_warning()  { io_message "$1" "${2:-warning}" Brown; }
io_error()    { io_message "$1" "${2:-error}" Red; }
io_debug()    { [[ $debug == 'true' ]] && io_message "$1 = ${!1}" "${2:-debug}" ${3:-Purple}; }

io_pause()
{
  local label=$(io_warning "Press any key to continue..." "$@" 2>&1)
  read -n1 -s -r -p "${label:0:-1}"
  echo $'\n'
}

trace_method()
{
  local method=$1 param; shift
  for param in $@; do
    method="$method $param='${!param}'"
  done
  echo "$method" >&2
}
trace_vars()
{
  local params=() param
  for param in "$@"; do
    params+=( "$param='${!param}'" )
  done
  echo "${params[@]}" >&2
}

string_is_folded() { [[ $1 =~ ^[^/]+/.+$ ]]; }
string_pad()       { printf "%-$1s" $2; }
string_join()      { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }
string_indent()    { local n=$1; shift; printf "%${n}s%s" '' "$*"; }
string_sort()   
{
  local IFS=$'\n'
  sort <<<"$*"
}
string_sort_descending()   
{
  local IFS=$'\n'
  sort -r <<<"$*"
}
array_sort()
{
  local array=( ${!1} )
  local IFS=$'\n'
  sort <<<"${array[*]}"
}
array_sort_descending()
{
  local array=( ${!1} )
  local IFS=$'\n'
  sort -r <<<"${array[*]}"
}

assert_equals()
{
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    -*) echo "unknown option: '$1'" >&2; exit 1;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}
  local value=${args[1]}
  [[ -n ${args[2]} ]] && label=${args[2]}

  if [[ "$expected" != "$value" ]]; then
    io_error "expected '$expected' but was '$value'" "$label"
    [[ -z $no_exit ]] && exit 1
  else
    io_success "expected '$value' OK" "$label"
  fi
}
assert_exit_code()
{
  local status=$?
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    -*) echo "unknown option: '$1'" >&2; exit 1;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}

  if [[ $expected != $status ]]; then
    io_error "expected exit code '$expected' but was '$status'" "$label"
    [[ -z $no_exit ]] && exit $status
  else
    io_success "expected exit code '$status' OK" "$label"
  fi
}
regex_whole()  { echo "^${1//./\\.}$"; }
regex_escape() { echo "${1//./\\.}"; }

array_remove_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_array array[@] remove[@])"
  #   else
  #     result=( $(array_remove_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) remove=( "${!2}" ) i r
  for i in ${!array[@]}; do
    for r in "${remove[@]}"; do
      if [[ "${array[i]}" == "$r" ]]; then
        unset 'array[i]'
        break
      fi
    done
  done
  printf '%s\n' "${array[@]}"
}
array_intersect_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_intersect_array array[@] remove[@])"
  #   else
  #     result=( $(array_intersect_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array1=( "${!1}" ) array2=( "${!2}" ) i j
  for i in ${array1[@]}; do
    for j in "${array2[@]}"; do
      if [[ "$i" == "$j" ]]; then
        echo $i
      fi
    done
  done
}
array_remove_element()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_element array[@] "$element")"
  #   else
  #     result=( $(array_remove_element array[@] "$element") )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) i
  for i in ${!array[@]}; do
    if [[ "${array[i]}" == "$2" ]]; then
      unset 'array[i]'
      break
    fi
  done
  printf '%s\n' "${array[@]}"
}
array_contains_element()
{
  local e match="$1"; shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}
path_make_relative()
{
  local path=$(realpath "$1")
  local relativeTo=$(realpath "${2:-.}")
  realpath --relative-to="$relativeTo" "$path"
}
get_file_encoding()
{
  local info=$(file -i $1)
  info="${info##*=}"
  echo "${info^^}"
}
_locale_encoding()
{
  local info=$(locale | grep -0 'LANG=')
  info="${info##*.}"
  echo "${info^^}"
}

zou_lencoding="$(_locale_encoding)"

ised()
{
  local file=$1
  local script=$2
  local fEncoding=$(get_file_encoding $file)

  if [[ $fEncoding == $zou_lencoding ]]; then
    sed -i -E "$script" "$file"
  else
    local tmp="$file.zou"
    if iconv -t "$zou_lencoding" "$file" 2>/dev/null >"$tmp"; then
      sed -i -E "$script" "$tmp"
      iconv -t "$fEncoding" "$tmp" >"$file"
    else
      sed -i -E "$script" "$file"
    fi
    rm --force "$tmp"
  fi
  
  realpath "$file"
}

# usage:
#   visit enumerator p-visitor ...
# in:
#   $1     -- enumerator
#   $2     -- p-visitor path ...
#   ${@:3} -- next
visit()
{
  local ec=0 path
  for path in $($1); do
    (
      $2 "$path" "${@:3}" || exit $?
    ) || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && break
  done
  return $ec
}
# usage:
#   visit enumerator p-visitor next ...
# in:
#   $1     -- enumerator
#   $2     -- p-visitor   # signature: p-visitor path next ...
#   ${@:3} -- next ...
visit_async()
{
  local ec=0 path pids=()
  for path in $(string_sort $($1)); do
    (
      $2 "$path" "${@:3}" || exit $?
    ) &
    pids+=($!)
    if (( $(process_job_count) % $jobsCount == 0 )); then
      wait "${pids[@]}" &>/dev/null || ec=$?
      pids=()
      [[ $ec -ne 0 && $stopOnError == true ]] && break
    fi
  done
  [ ${#pids[@]} -ne 0 ] && wait "${pids[@]}" &>/dev/null || ec=$?
  return $ec
}

# trace constants (if debug == true)
io_debug zou_startupPath
io_debug zou_startupDir
io_debug zou_startupFileName
io_debug zou_binDir
io_debug zou_command
io_debug zou_lencoding
