#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_CORE ]] && . zoul-core
ZOUL_CORE=true

[[ -z $ZOUL_LOCK ]]    && . zoul-lock
[[ -z $ZOUL_PROCESS ]] && . zoul-process

# declare startup constants
zou_startupPath=$(realpath "${BASH_SOURCE[-1]}")
zou_startupFileName="${zou_startupPath##*/}"
if [[ "$zou_startupFileName" == bashdb ]]; then
  zou_startupPath=$(realpath "${BASH_SOURCE[-2]}")
  zou_startupFileName="${zou_startupPath##*/}"
fi
zou_startupDir="${zou_startupPath%/*}"
zou_binDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
zou_command="${zou_startupFileName##git-}"

# colors usage
#   colors="${Red}Red ${Green}Green${NC}"
#   printf '%b\n' "$colors"
NC='\e[0m'  # No Color
Black='\e[0;30m'     DarkGray='\e[1;30m'
Red='\e[0;31m'       LightRed='\e[1;31m'
Green='\e[0;32m'     LightGreen='\e[1;32m'
Brown='\e[0;33m'     Yellow='\e[1;33m'
Blue='\e[0;34m'      LightBlue='\e[1;34m'
Purple='\e[0;35m'    LightPurple='\e[1;35m'
Cyan='\e[0;36m'      LightCyan='\e[1;36m'
LightGray='\e[0;37m' White='\e[1;37m'

io_print_colors()
{
  local color colors=()
  for color in Black DarkGray Red LightRed Green LightGreen Brown Yellow Blue LightBlue Purple LightPurple Cyan LightCyan LightGray White; do
    colors+=( ${!color}$color )
  done
  printf '%20b%20b\n' "${colors[@]}"
}
io_set_version()
{
  local line regex='Version>(.*)</'
  while read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ $regex ]] && {
      version=${BASH_REMATCH[1]}
      break
    }
  done < "$zou_binDir/../Version.props"
}
io_banner()
{
  local version; io_set_version
  local banner="${LightBlue}Zou tools [Version ${Green}$version${LightBlue}]
Copyright Â© 2019, EPSITEC SA, CH-1400 Yverdon-les-Bains, Switzerland${NC}"
  printf "%b\n" "$banner" 1>&2
}
io_help()
{
  local hdir=$(realpath "$zou_binDir/../help") \
        hname=$(basename "$1") \
        hpath help

  hpath=$hdir/$hname
  if [[ -f "$hpath" ]]; then
    help=$(cat "$hpath")
    io_message "$help"
  else
    local htpl=$hdir/template/$hname
    if [[ -f "$htpl" ]]; then
      io_warning "help file not found at $hpath\n"
      io_info "  use the following commands to create and edit the following template

      mv \"$htpl\" \"$hpath\"
      vim \"$hpath\"

  "
      help=$(cat "$htpl")
      io_message "$help" '' Gray
    else
      io_error "help file not found - $hpath"
    fi
  fi
}

io_trace()
{
  [[ -z $ZOU_TRACE ]] && return 0
  io_message "  $1" "$moduleTracePrefix" ${2:-Gray}
}

#########
# io lock
#########
[[ -z $ioGate ]] && {
  ioGate=$(lock_init)
  export ioGate
}

io_lock()       { lock "$ioGate" 0 "$@"; }
io_lock_enter() { lock_enter "$ioGate"; }
io_lock_exit()  { lock_exit "$ioGate"; }

# io_message()
# {
#   io_message_unsafe "$@"
# }
# usage: io_message <message> [<label> [<color=LightCyan>]]
# example:
#   $ io_message 'message' 'info' Cyan
#   -> info: message
#   $ io_message 'message' '' Gray
#   -> message
io_message() { io_lock io_message_unsafe "$@"; }
io_message_unsafe()
{
  local message=$1 label=$2 color=${3:-Cyan}
  if [[ -n $label ]]; then
    if [[ $label =~ ^\\e\[[0-9] ]]; then
      # colored label 
      message="$label : ${!color}$message${NC}"
    else
      # no label color
      message="${!color}$label${NC} : ${!color}$message${NC}"
    fi
  else
    message="${!color}$message${NC}"
  fi
  printf "%b\n" "$message" 1>&2
}
io_info()     { io_message "$1" "${2:-info}"; }
io_success()  { io_message "$1" "${2:-info}" Green; }
io_warning()  { io_message "$1" "${2:-warning}" Brown; }
io_error()    { io_message "$1" "${2:-error}" Red; }
io_debug()    { [[ $debug == 'true' ]] && io_message "$1 = ${!1}" "${2:-debug}" ${3:-Purple}; }

io_pause()
{
  local label=$(io_warning "Press any key to continue..." "$@" 2>&1)
  read -n1 -s -r -p "${label:0:-1}"
  echo $'\n'
}

trace_method()
{
  local method=$1 param; shift
  for param in $@; do
    method="$method $param='${!param}'"
  done
  echo "$method" >&2
}
trace_vars()
{
  local vars=$(print_vars "$@")
  echo "$vars" >&2
}
print_vars()
{
  local params=() param array
  for param in "$@"; do
    if [[ $param =~ \[@\]$ ]]; then
      array=( "${!param}" )
      params+=( "${param%\[@\]}=(${array[@]})" )
    else
      params+=( "$param='${!param}'" )
    fi
  done
  printf '%s ' "${params[@]}"
}

string_is_folded() { [[ $1 =~ ^[^/]+/.+$ ]]; }
string_pad_left()  { printf "%*s" "$1" "$2"; }
string_pad_right() { printf "%-*s" "$1" "$2"; }
string_join()      { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }
string_indent()    { local n=$1; shift; printf "%${n}s%s" '' "$*"; }
string_sort()   
{
  local IFS=$'\n'
  sort <<<"$*"
}
string_sort_descending()   
{
  local IFS=$'\n'
  sort -r <<<"$*"
}
string_max_length()
{
  local maxLength
  string_set_max_length "$@"
  echo $maxLength
}
# out:
#   maxLength
string_set_max_length()
{
  local s len
  maxLength=0
  for s; do
    len=${#s}
    (( $len > $maxLength )) && maxLength=$len
  done
}
array_sort()
{
  local array=( ${!1} )
  local IFS=$'\n'
  sort <<<"${array[*]}"
}
array_sort_descending()
{
  local array=( ${!1} )
  local IFS=$'\n'
  sort -r <<<"${array[*]}"
}

assert_equals()
{
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}
  local value=${args[1]}
  [[ -n ${args[2]} ]] && label=${args[2]}

  if [[ "$expected" != "$value" ]]; then
    io_error "expected '$expected' but was '$value'" "$label"
    [[ -z $no_exit ]] && exit 1
  else
    io_success "expected '$value' OK" "$label"
  fi
}
assert_exit_code()
{
  local status=$?
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}

  if [[ $expected != $status ]]; then
    io_error "expected exit code '$expected' but was '$status'" "$label"
    [[ -z $no_exit ]] && exit $status
  else
    io_success "expected exit code '$status' OK" "$label"
  fi
}
wildcard_to_regex_match_whole()
{
  local regex
  wildcard_set_regex_match_whole "$1"
  echo "$regex"
}
wildcard_to_regex()
{
  local regex
  wildcard_set_regex "$1"
  echo "$regex"
}
wildcard_set_regex_match_whole()
{
  wildcard_set_regex "$1"
  regex="^$regex$"
}
wildcard_set_regex()
{
  regex="${1//./\\.}"         # .   ->   \.
  regex="${regex//\*/\.\*}"   # *   ->   .*
  regex="${regex//\?/\.}"     # ?   ->   .
  # ZOU_TRACE=true io_trace "wildcard_set_regex ${*@Q} -> $(print_vars regex)"
}

array_remove_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_array array[@] remove[@])"
  #   else
  #     result=( $(array_remove_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) remove=( "${!2}" ) i r
  for i in ${!array[@]}; do
    for r in "${remove[@]}"; do
      if [[ "${array[i]}" == "$r" ]]; then
        unset 'array[i]'
        break
      fi
    done
  done
  printf '%s\n' "${array[@]}"
}
array_intersect_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_intersect_array array[@] remove[@])"
  #   else
  #     result=( $(array_intersect_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array1=( "${!1}" ) array2=( "${!2}" ) i j
  for i in ${array1[@]}; do
    for j in "${array2[@]}"; do
      if [[ "$i" == "$j" ]]; then
        echo $i
      fi
    done
  done
}
array_remove_element()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_element array[@] "$element")"
  #   else
  #     result=( $(array_remove_element array[@] "$element") )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) i
  for i in ${!array[@]}; do
    if [[ "${array[i]}" == "$2" ]]; then
      unset 'array[i]'
      break
    fi
  done
  printf '%s\n' "${array[@]}"
}
array_contains_element()
{
  local e match="$1"; shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}
path_make_relative()
{
  local path=$(realpath "$1")
  local relativeTo=$(realpath "${2:-.}")
  realpath --relative-to="$relativeTo" "$path"
}
get_file_encoding()
{
  local info=$(file -i $1)
  info="${info##*=}"
  echo "${info^^}"
}
_locale_encoding()
{
  local info=$(locale | grep -0 'LANG=')
  info="${info##*.}"
  echo "${info^^}"
}

zou_lencoding="$(_locale_encoding)"

ised()
{
  local file=$1
  local script=$2
  local fEncoding=$(get_file_encoding $file)

  if [[ $fEncoding == $zou_lencoding ]]; then
    sed -i -E "$script" "$file"
  else
    local tmp="$file.zou"
    if iconv -t "$zou_lencoding" "$file" 2>/dev/null >"$tmp"; then
      sed -i -E "$script" "$tmp"
      iconv -t "$fEncoding" "$tmp" >"$file"
    else
      sed -i -E "$script" "$file"
    fi
    rm --force "$tmp"
  fi
  
  realpath "$file"
}

# usage:
#   visit enumerator p-visitor ...
#   visit array[@] p-visitor ...
# in:
#   $1     -- enumerator or array name
#   $2     -- p-visitor path ...
#   ${@:3} -- next
visit()
{
  local ec=0 _zouVisitPaths path
  [[ $1 =~ \[@\]$ ]] && _zouVisitPaths=("${!1}") || _zouVisitPaths=("$($1)")
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0

  for path in "${_zouVisitPaths[@]}"; do
    (
      $2 "$path" "${@:3}" || exit $?
    ) || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && break
  done
  return $ec
}
# usage:
#   visit enumerator p-visitor next ...
#   visit array[@] p-visitor next ...
# in:
#   $1     -- enumerator or array name
#   $2     -- p-visitor   # signature: p-visitor path next ...
#   ${@:3} -- next ...
visit_async()
{
  local ec=0 _zouVisitPaths path pids=()
  [[ "$1" =~ \[@\]$ ]] && _zouVisitPaths=("${!1}") || _zouVisitPaths=("$($1)")
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0

  [[ -z $jobsCount ]] && jobsCount=32

  for path in $(array_sort _zouVisitPaths[@]); do
    (
      $2 "$path" "${@:3}" || exit $?
    ) &
    pids+=($!)
    if (( $(process_job_count) % $jobsCount == 0 )); then
      wait "${pids[@]}" &>/dev/null || ec=$?
      pids=()
      [[ $ec -ne 0 && $stopOnError == true ]] && break
    fi
  done
  [ ${#pids[@]} -ne 0 ] && wait "${pids[@]}" &>/dev/null || ec=$?
  wait
  return $ec
}
visit_async_fast()
{
  local _zouVisitPaths path
  [[ $1 =~ \[@\]$ ]] && _zouVisitPaths=("${!1}") || _zouVisitPaths=("$($1)")
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0

  for path in $(array_sort _zouVisitPaths[@]); do
    ( $2 "$path" "${@:3}" || exit $? ) &
  done
  wait
}

# trace constants (if debug == true)
io_debug zou_startupPath
io_debug zou_startupDir
io_debug zou_startupFileName
io_debug zou_binDir
io_debug zou_command
io_debug zou_lencoding
