#!/usr/bin/env bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_CORE ]] && . zoul-core
ZOUL_CORE=true

[[ -z $ZOUL_SYSTEM ]]  && . zoul-system
[[ -z $ZOUL_LOCK ]]    && . zoul-lock
[[ -z $ZOUL_PROCESS ]] && . zoul-process

# Environment variables
# zouTraceError=true
# zouTraceScope=true

# work with default IFS
IFS=$' \t\n'
OIFS=$IFS


# force git to use invariant language
export LANGUAGE=en_US
export LANG="$LANGUAGE.UTF-8"

# declare startup constants
zouStartupPath=$(abspath "${BASH_SOURCE[-1]}")
zouStartupFileName="${zouStartupPath##*/}"
if [[ "$zouStartupFileName" == bashdb ]]; then
  zouStartupPath=$(abspath "${BASH_SOURCE[-2]}")
  zouStartupFileName="${zouStartupPath##*/}"
fi
zouStartupDir="${zouStartupPath%/*}"
zouBinDir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
zouCommand="${zouStartupFileName##git-}"
zouConfigFile="$(abspath ~)/.zou-flow"

zouTmpDir=${TMPDIR:-/tmp}/_zou
[ -d "$zouTmpDir" ] || mkdir -p "$zouTmpDir"

zouLogPath=${ZOU_LOG_PATH:-$zouTmpDir/zou-flow.log}
[ -d $(dirname "$zouLogPath") ] || mkdir "$(dirname "$zouLogPath")"

if [[ $ZOU_LOG == true ]]; then
  [[ -f "$zouLogPath" ]] && rm "$zouLogPath"
  stderrRedir="$zouLogPath"
  stdallRedir="$zouLogPath"
else
  stderrRedir='/dev/null'
  stdallRedir='/dev/null'
fi

# colors usage
#   colors="${Red}Red ${Green}Green${NC}"
#   printf '%b\n' "$colors"
NC='\e[0m'  # No Color
Black='\e[0;30m'  DarkGray='\e[1;30m'
Red='\e[0;31m'    LightRed='\e[1;31m'
Green='\e[0;32m'  LightGreen='\e[1;32m'
Brown='\e[0;33m'  Yellow='\e[1;33m'
Blue='\e[0;34m'   LightBlue='\e[1;34m'
Purple='\e[0;35m' Magenta='\e[1;35m'
Cyan='\e[0;36m'   LightCyan='\e[1;36m'
Gray='\e[0;37m'   White='\e[1;37m'

# specific message colors
VC=${Gray}  # variable
EC=${Red}   # error
IC=${Cyan}  # info
WC=${Brown} # warning

io_print_colors()
{
  local color colors=()
  for color in Black DarkGray Red LightRed Green LightGreen Brown Yellow Blue LightBlue Purple Magenta Cyan LightCyan Gray White; do
    colors+=( ${!color}$color )
  done
  printf '%15b%20b\n' "${colors[@]}"
}
io_remove_colors()
{
  printf '%s\n' "$@" | sed -E 's/\\e\[[[:digit:]][^m]*m//g'
}
# out:
#   version
io_set_version()
{
  version=''

  local line regex='Version>(.*)</' versionProps
  
  if [ -f "$zouBinDir/Version.props" ]; then
    versionProps="$zouBinDir/Version.props"
  else
    versionProps="$zouBinDir/../Version.props"
  fi
  # io_trace "io_set_version - $(print_vars versionProps)"
  while read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ $regex ]] && {
      version=${BASH_REMATCH[1]}
      break
    }
  done < "$versionProps"
}
io_banner()
{
  local version; io_set_version
  local banner="${LightBlue}Zou tools [Version ${Green}$version${LightBlue}]
Copyright Â© 2019, EPSITEC SA, CH-1400 Yverdon-les-Bains, Switzerland${NC}"
  printf "%b\n" "$banner" 1>&2
}
io_help()
{
  local hdir=$(abspath "$zouBinDir/../help") hname=$(basename "$1")

  if [[ -f "$hdir/$hname" ]]; then
    io_message "$(cat "$hdir/$hname")"
  elif [[ -f "$hdir/git-$hname" ]]; then
    io_message "$(cat "$hdir/git-$hname")"
  elif [[ -f "$hdir/topic-$hname" ]]; then
    io_message "$(cat "$hdir/topic-$hname")"
  else
    local htpl=$hdir/template/$hname
    if [[ -f "$htpl" ]]; then
      mio_warning "help file not found at $hpath\n"
      mio_info "  use the following commands to create and edit the following template

      mv \"$htpl\" \"$hpath\"
      vim \"$hpath\"

  "
      help=$(cat "$htpl")
      io_message "$help" '' ${Gray}
    else
      io_error "help file not found - $hpath"
    fi
  fi
}
io_help_list()
{
    local hdir names commands topics
    hdir=$(abspath "$zouBinDir/../help/.")
    topics=( $(io_list_filenames "$hdir" 'topic-*') )
    commands=( $(io_list_filenames "$hdir" 'git-*') )
    topics=( "${topics[@]#topic-}" )
    commands=( "${commands[@]#git-}" )
    topics=( "${topics[@]/#/  }" )
    commands=( "${commands[@]/#/  }" )
    # io_trace "io_help_list -- $(print_vars topics[@])"
    # io_trace "io_help_list -- $(print_vars commands[@])"
    
    IFS=$'\n'
    mio_message "\nAvailable commands:" ${Gray}
    mio_message "${commands[*]}";
    mio_message "\nAvailable topics:" ${Gray}
    mio_message "${topics[*]}";
    IFS=$OIFS
}
io_list_filenames()
{
  find "$1" -maxdepth 1 -type f -iname "$2" -printf "%f\n"
}

io_trace()
{
  local message=${1//$'\n'/'\\n'}
  message=${message//$'\t'/'\\t'}
  mio_message "  $message" ${2:-$Gray}
}
io_trace_unsafe()
{
  local message=${1//$'\n'/'\\n'}
  message=${message//$'\t'/'\\t'}
  mio_message_unsafe "  $message" ${2:-$Gray}
}
io_trace_error()
{
  local ec=$?
  [[ $zouTraceError == true ]] || return $ec
  [ $ec -eq 0 ] && return 0
  io_trace "$1 (error code=$ec)" ${Red}
  return $ec
}

#########
# io lock
#########
[[ -z $ioGate ]] && {
  ioGate=$(lock_init)
  export ioGate
}

io_lock()       { lock "$ioGate" 0 "$@"; }
io_lock_enter() { lock_enter "$ioGate"; }
io_lock_exit()  { lock_exit "$ioGate"; }

# usage: io_message <message> [<label> [<color=${LightCyan}>]]
# example:
#   $ io_message 'message' 'info' ${Cyan}
#   -> info: message
#   $ io_message 'message' '' ${Gray}
#   -> message
io_info()    { io_message "$1" "${2:-info}"; }
io_success() { io_message "$1" "${2:-info}"    ${Green}; }
io_warning() { io_message "$1" "${2:-warning}" ${Brown}; }
io_error()   { io_message "$1" "${2:-error}"   ${Red}; }
io_message() { io_lock io_message_unsafe "$@"; }

io_info_unsafe()     { io_message_unsafe "$1" "${2:-info}"; }
io_success_unsafe()  { io_message_unsafe "$1" "${2:-info}"    ${Green}; }
io_warning_unsafe()  { io_message_unsafe "$1" "${2:-warning}" ${Brown}; }
io_error_unsafe()    { io_message_unsafe "$1" "${2:-error}"   ${Red}; }
io_message_unsafe()
{
  local message=$1 label=$2 color=${3:-${Cyan}}
  if [[ -n $label ]]; then
    if [[ $label =~ ^\\e\[ ]]; then
      # colored label 
      message="$label : ${color}$message${NC}"
    else
      # no label color
      message="${color}$label${NC} : ${color}$message${NC}"
    fi
  else
    message="${color}$message${NC}"
  fi
  printf "%b\n" "$message" 1>&2
}

mio_info()    { mio_message "$1"; }
mio_success() { mio_message "$1" "${Green}"; }
mio_warning() { mio_message "$1" "${Brown}"; }
mio_error()   { mio_message "$1" "${Red}"; }
mio_message() { io_lock mio_message_unsafe "$@"; }

mio_info_unsafe()    { mio_message_unsafe "$1"; }
mio_success_unsafe() { mio_message_unsafe "$1" "${Green}"; }
mio_warning_unsafe() { mio_message_unsafe "$1" "${Brown}"; }
mio_error_unsafe()   { mio_message_unsafe "$1" "${Red}"; }
mio_message_unsafe()
{
  local message=$1 color=${2:-$Cyan}
  [[ -n $moduleAlias ]] && message="$message${DarkGray} -- $moduleAlias"
  io_message_unsafe "$message" "$moduleTracePrefix" "$color"
}

io_debug() { [[ $debug == 'true' ]] && io_message "$1 = ${!1}" "${2:-debug}" ${3:-$Purple} || true; }

io_pause()
{
  local label=$(mio_warning "Press any key to continue..." "$@" 2>&1)
  read -n1 -s -r -p "${label:0:-1}"
  echo $'\n'
}

trace_method()
{
  local method=$1 param; shift
  for param in $@; do
    method="$method $param='${!param}'"
  done
  echo "$method" >&2
}
trace_vars()
{
  local vars=$(print_vars "$@")
  echo "$vars" >&2
}
print_vars()
{
  local param value
  for param in "$@"; do
    value=( $(io_remove_colors "${!param}") )
    if [[ $param =~ \[@\]$ ]]; then
      param="${param%\[@\]}"
      if [ ${#value[@]} -eq 0 ]; then
        printf '%b ' "$param=()"
      else
        value=( $(printf '%q ' "${value[@]}") )
        printf '%b ' "$param=(${value[@]@Q})"
      fi
    elif [[ -z $value ]]; then
      printf '%b ' "$param=''"
    else
      value=$(printf '%q' "$value")
      printf '%b ' "$param='$value'"
    fi
  done
}

string_is_folded() { [[ $1 =~ ^[^/]+/.+$ ]]; }
string_pad_left()  { printf "%*s" "$1" "$2"; }
string_pad_right() { printf "%-*s" "$1" "$2"; }
string_join()      { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }
string_indent()    { local n=$1; shift; printf "%${n}s%s" '' "$*"; }

string_sort()            { IFS=$'\n' sort <<<"$*"; IFS=$OIFS; }
string_sort_descending() { IFS=$'\n' sort -r <<<"$*"; IFS=$OIFS; }

string_max_length()
{
  local maxLength
  string_set_max_length "$@"
  echo $maxLength
}
# out:
#   maxLength
string_set_max_length()
{
  maxLength=0

  local s len
  for s; do
    len=${#s}
    (( $len > $maxLength )) && maxLength=$len
  done
}
remove_color()
{
  local value=$1
  while [[ $value =~ ^([^\\]*)\\e\[[0-9][^m]*m(.*)$ ]]; do
    value=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
  done
  echo $value
}
assert_equals()
{
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}
  local value=${args[1]}
  [[ -n ${args[2]} ]] && label=${args[2]}

  if [[ "$expected" != "$value" ]]; then
    io_error "expected '$expected' but was '$value'" "$label"
    [[ -z $no_exit ]] && exit 1
  else
    io_success "expected '$value' OK" "$label"
  fi
}
assert_exit_code()
{
  local status=$?
  local label=assert args=() no_exit
  while [[ "$#" > 0 ]]; do case "$1" in
    -l|--label) label="$2"; shift;;
    -n|--no-exit) no_exit=true;;
    *) args+=("$1");;
  esac; shift; done
  local expected=${args[0]}

  if [[ $expected != $status ]]; then
    io_error "expected exit code '$expected' but was '$status'" "$label"
    [[ -z $no_exit ]] && exit $status
  else
    io_success "expected exit code '$status' OK" "$label"
  fi
}
wildcard_to_regex_match_whole()
{
  local regex
  wildcard_set_regex_match_whole "$1"
  echo "$regex"
}
wildcard_to_regex()
{
  local regex
  wildcard_set_regex "$1"
  echo "$regex"
}
# out:
#   regex
wildcard_set_regex_match_whole()
{
  wildcard_set_regex "$1"
  regex="^$regex$"
}
# out:
#   regex
wildcard_set_regex()
{
  regex="${1//./\\.}"         # .   ->   \.
  regex="${regex//\*/\.\*}"   # *   ->   .*
  regex="${regex//\?/\.}"     # ?   ->   .
  # io_trace "wildcard_set_regex ${*@Q} -> $(print_vars regex)"
}

########
# ARRAYS
########

array_sort()
{
  local array=( ${!1} )
  IFS=$'\n' sort <<<"${array[*]}"; IFS=$OIFS
}
array_sort_descending()
{
  local array=( ${!1} )
  IFS=$'\n' sort -r <<<"${array[*]}"; IFS=$OIFS
}
array_remove_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_array array[@] remove[@])"
  #   else
  #     result=( $(array_remove_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) remove=( "${!2}" ) i r
  for i in ${!array[@]}; do
    for r in "${remove[@]}"; do
      if [[ "${array[i]}" == "$r" ]]; then
        unset 'array[i]'
        break
      fi
    done
  done
  printf '%s\n' "${array[@]}"
}
array_intersect_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_intersect_array array[@] remove[@])"
  #   else
  #     result=( $(array_intersect_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array1=( "${!1}" ) array2=( "${!2}" ) i j
  # io_trace "array_intersect_array ${*@Q} -- $(print_vars array1[@] array2[@])"
  for i in ${array1[@]}; do
    for j in "${array2[@]}"; do
      if [[ "$i" == "$j" ]]; then
        echo $i
      fi
    done
  done
}
array_union_array()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_union_array array[@] remove[@])"
  #   else
  #     result=( $(array_union_array array[@] remove[@]) )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array1=( "${!1}" ) array2=( "${!2}" ) i
  for i in "${!array2[@]}"; do
    if ! array_contains_element "${array2[$i]}" "${array1[@]}"; then
      array1+=( ${array2[$i]} )
    fi
  done
  printf '%s\n' "${array1[@]}"
}
array_remove_element()
{
  # usage:
  #   if there is spaces in array elements:
  #     mapfile -t result <<< "$(array_remove_element array[@] "$element")"
  #   else
  #     result=( $(array_remove_element array[@] "$element") )
  # note:
  #   array are passed by names: ${!1} is an indirection
  local array=( "${!1}" ) i
  for i in "${!array[@]}"; do
    if [[ "${array[i]}" == "$2" ]]; then
      unset 'array[i]'
      break
    fi
  done
  printf '%s\n' "${array[@]}"
}
array_contains_element()
{
  local e match="$1"; shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}
path_make_relative()
{
  local path=$(abspath "$1")
  local relativeTo=$(abspath "${2:-.}")
  abspath --relative-to="$relativeTo" "$path"
}

get_file_encoding()
{
  local info=$(file -i "$1")
  info="${info##*charset=}"
  info="${info,,}"
  [[ $info == 'unknown-8bit' ]] && echo 'utf-8' || echo $info
}
_locale_encoding()
{
  if command -v locale &>>"$stdallRedir"; then
    _lang_to_encoding "$(locale | grep -0 'LANG=')"
  else
    _lang_to_encoding "LANG=$LANG"
  fi
}
_lang_to_encoding()
{
  # LANG=C        -> ''
  # LANG=C.UTF-8  -> 'utf-8'
  [[ $1 =~ ^.*\.(.*)$ ]] && echo ${BASH_REMATCH[1],,} || true
}

zouEncoding="$(_locale_encoding)"

ised()
{
  local file=$1 script=$2 fEncoding=$(get_file_encoding "$1") ec=0
  # io_trace "ised $(print_vars file fEncoding)"

  if [[ $fEncoding == $zouEncoding || $fEncoding == 'us-ascii' || $fEncoding == 'utf-8' || $fEncoding == 'iso-8859-1' ]]; then
    sed -b -E -i "$script" "$file" || ec=$?
  else
    local tmp="$file.zou"
    if iconv -f "$fEncoding" -t "$zouEncoding" "$file" >"$tmp"; then
      { sed -b -E -i "$script" "$tmp" && iconv -f "$zouEncoding" -t "$fEncoding" "$tmp" >"$file"; } || ec=$?
    else
      sed -b -E -i "$script" "$file" || ec=$?
    fi
    rm --force "$tmp"
  fi
  
  abspath "$file"
  return $ec
}
# Escape arguments for command line usage
#
# exemple:
#   cl_escape 'a b c' 'x y' z
#   -> a\ b\ c x\ y z
cl_escape()
{
  local arg
  for arg; do
    printf '%q ' "$arg"
  done
}
# Adapt file encoding for encoding agnostic commands.
#
# exemple:
#   ieval "grep 'FILEVERSION'" resources.rc
ieval()
{
  local command=$1 file=$2 fEncoding=$(get_file_encoding "$2")
  # io_trace "ieval $(print_vars command file fEncoding)"

  if [[ $fEncoding == $zouEncoding || $fEncoding == 'us-ascii' || $fEncoding == 'utf-8' || $fEncoding == 'iso-8859-1' ]]; then
    eval "$command "$(cl_escape "$file")""
  else
    iconv -f "$fEncoding" -t "$zouEncoding" "$file" 2>>"$stderrRedir" \
    | eval "$command" \
    | iconv -f "$zouEncoding" -t "$fEncoding"
    return ${PIPESTATUS[1]}
  fi
}

# usage:
#   visit enumerator p-visitor ...
#   visit array[@] p-visitor ...
# in:
#   $1     -- enumerator or array name
#   $2     -- p-visitor path ...
#   ${@:3} -- next
visit()
{
  local ec=0 _zouVisitPaths path
  if [[ "$1" =~ \[@\]$ ]]; then
    _zouVisitPaths=("${!1}")
    # io_trace "visit -1- $(print_vars _zouVisitPaths[@])"
  elif [[ -n $1 ]]; then
    _zouVisitPaths=("$($1)")
    # io_trace "visit -2- $(print_vars _zouVisitPaths[@])"
  fi
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0

  for path in "${_zouVisitPaths[@]}"; do
    ( $2 "$path" "${@:3}" || exit $? ) || ec=$?
    [[ $ec -ne 0 && $stopOnError == true ]] && break
  done
  return $ec
}
# usage:
#   visit enumerator p-visitor next ...
#   visit array[@] p-visitor next ...
# in:
#   $1     -- enumerator or array name
#   $2     -- p-visitor   # signature: p-visitor path next ...
#   ${@:3} -- next ...
visit_async()
{
  local ec=0 _zouVisitPaths path pid pids=()
  if [[ "$1" =~ \[@\]$ ]]; then
    _zouVisitPaths=("${!1}")
    # io_trace "visit_async -1- $(print_vars _zouVisitPaths[@])"
  elif [[ -n $1 ]]; then
    _zouVisitPaths=("$($1)")
    # io_trace "visit_async -2- $(print_vars _zouVisitPaths[@])"
  fi
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0
  
  [[ -z $jobsCount ]] && jobsCount=12

  for path in $(array_sort _zouVisitPaths[@]); do
    ( $2 "$path" "${@:3}" || io_trace_error "visit_async >> $2 "$path" "${@:3}"" || exit $? )&
    pids+=($!)
    if (( "$jobsCount" > 0 )) && (( $(process_job_count) % "$jobsCount" == 0 )); then
      for pid in "${pids[@]}"; do
        wait $pid &>>"$stdallRedir" || ec=$?
      done
      pids=()
      [[ $ec -ne 0 && $stopOnError == true ]] && break
    fi
  done
  for pid in "${pids[@]}"; do
    wait $pid &>>"$stdallRedir" || ec=$?
  done
  wait
  return $ec
}
visit_async_fast()
{
  local _zouVisitPaths path
  if [[ "$1" =~ \[@\]$ ]]; then
    _zouVisitPaths=("${!1}")
    # io_trace "visit_async_fast -1- $(print_vars _zouVisitPaths[@])"
  elif [[ -n $1 ]]; then
    _zouVisitPaths=("$($1)")
    # io_trace "visit_async_fast -2- $(print_vars _zouVisitPaths[@])"
  fi
  [ ${#_zouVisitPaths[@]} -eq 0 ] && return 0

  for path in $(array_sort _zouVisitPaths[@]); do
    ( $2 "$path" "${@:3}" || exit $? ) &
  done
  wait
}
# Intercept and trace error
#
# usage:
#   func || error $? "label" || return $?
# in:
#   $1 -- error code
#   $2 -- label
# return:
#   $1
error()
{
  [ $1 -ne 0 ] && io_trace "error '$1' at '$2'"
  return $1
}
# Execute a command and transform stdout
#
#  io_eval 'git fetch --tags 2>&1' _ptags_line_selector ${Gray}
#  io_eval 'git fetch --tags 2>&1' : ${Gray}
#
# in:
#   command=$1  -- command to evaluate
#   selector=$2 -- selector $line $color
#   color=$3    -- default color
io_eval()
{
  local selector=${2:-:} color=${3:-$NC} indent=${4:-  } isLastLine=0 skipCurrentLine line
  # io_trace "io_eval ${*@Q} -- $(print_vars selector color)"
  IFS=$'\n' eval "$1" | \
  while read -r line; do
    $selector "$line" "$color"; isLastLine=$?
    [[ $skipCurrentLine == true ]] && continue
    io_message "${indent}$line" "$moduleTracePrefix" "$color"
    [ $isLastLine -ne 0 ] && break
  done; IFS=$OIFS
  return ${PIPESTATUS[0]}
}
io_locked_eval()
{
  local selector=${2:-:} color=${3:-$NC} indent=${4:-  } isLastLine=0 skipCurrentLine line
  # io_trace "io_locked_eval ${*@Q} -- $(print_vars selector color)"
  io_lock_enter
  IFS=$'\n' eval "$1" | \
  while read -r line; do
    $selector "$line" "$color"; isLastLine=$?
    [[ $skipCurrentLine == true ]] && continue
    io_message_unsafe "${indent}$line" "$moduleTracePrefix" "$color"
    [ $isLastLine -ne 0 ] && break
  done; IFS=$OIFS
  io_lock_exit
  return ${PIPESTATUS[0]}
}
io_buffered_eval()
{
  # io_trace "io_buffered_eval ${*@Q}"
  local selector=${2:-:} color=$3 indent=${4:-  } isLastLine=0 skipCurrentLine line lines ec
  # io_trace "io_buffered_eval 1 -- $(print_vars selector color indent)"
  IFS=$'\n' lines=( $(eval "$1") ); ec=$?; IFS=$OIFS
  if [[ -z $color ]]; then
    [ $ec -eq 0 ] && color=${NC} || color=${Red}
  fi
  io_lock_enter
  for line in "${lines[@]}"; do
    $selector "$line" "$color"; isLastLine=$?
    [[ $skipCurrentLine == true ]] && continue
    io_message_unsafe "${indent}$line" "$moduleTracePrefix" "$color"
    [ $isLastLine -ne 0 ] && break
  done
  io_lock_exit
  return $ec
}
faketty()
{
  script -eqc "$*" /dev/null
}
# usage:
#   myEvent=()
#   myEvent+=( handler )
#   raise_event 'myEvent[@]' $param1...
raise_event()
{
  # io_trace "raise_event -- $(print_vars $1)"
  local event=${1%'[@]'} handlers=( ${!1} ) handler; shift
  for handler in "${handlers[@]}"; do
    # io_trace "raise_event $event -- $handler $*"
    $handler "$@"
  done
  return 0
}

# Execute a command and capture stdout stderr and return code into variables
# usage:
#   local vout verr vret
#   eval "$(declare_exec vout verr vret COMMAND ...)"
#   return $vret
# in:
#   $1:vout     -- variable name where stdout will be saved
#   $2:verr     -- variable name where stderr will be saved
#   $3:vret     -- variable name where return code will be saved
#   $4:command  -- command to be executed
#   ...         -- command parameters 
declare_exec()
{
  ($4 "${@:5}") \
    2> >(_declare_stdin "$2") \
    1> >(_declare_stdin "$1"); _declare_xcode "$3"
}
_declare_stdin() { printf -v "$1" "%s" "$(cat)"; declare -p "$1"; }
_declare_xcode() { printf -v "$1" "%s" "$?";     declare -p "$1"; }

# io_trace "zoul-core $0 -- $(print_vars zouStartupDir zouStartupFileName zouStartupPath BASH_SOURCE[@])"