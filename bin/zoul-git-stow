#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_STOW ]] && . zoul-git-stow
ZOUL_GIT_STOW=true

[[ -z $ZOUL_GIT_STOW_CORE ]] && . zoul-git-stow-core
[[ -z $ZOUL_GIT_TAG ]]       && . zoul-git-tag

# in:
#  tagMove=$1 -- tag move function (tag_move $src $dst)
#  tags=${@:2} -- tag list
# return code:
#  1 if any tag move fails
stow_tags()
{
  local stowType stowFolder refPath refType refStowType stowPath tag

  for tag; do
    stow_set_info "$tag"            # -> stowType stowFolder refPath
    stow_set_tag_info               # -> refType refStowType refPath
    stow_set_folder "$refStowType"  # -> stowPath
    # io_trace "stow_tag -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    tag_move "$tag" "$stowPath"
  done
}
stow_archive_tags()
{
  local refPath stowFolder stowType refType refStowType stowPath tag ec=0

  for tag; do
    stow_set_info "$tag"                          # -> refPath stowFolder stowType
    stow_set_tag_info                             # -> refPath refType refStowType
    # io_trace "stow_archive_tags -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    refStowType=${refStowType/*./archive.}
    stow_set_folder "$refStowType"                # -> stowPath
    # io_trace "stow_archive_tags -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    tag_move "$tag" "$stowPath"
  done
  return $ec
}
stow_orphan_tags()
{
  local refPath stowFolder stowType refType refStowType stowPath tag ec=0

  for tag; do
    stow_set_info "$tag"                          # -> refPath stowFolder stowType
    stow_is_orphan && continue
    stow_set_tag_info                             # -> refPath refType refStowType
    # io_trace "stow_orphan_tags 1 -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    refStowType=${refStowType/active./other.}
    refStowType=${refStowType/.*/.orphan}
    stow_set_folder "$refStowType"                # -> stowPath
    # io_trace "stow_orphan_tags 2 -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    tag_move "$tag" "$stowPath"
  done
  return $ec
}
stow_adopt_tags()
{
  local refPath stowFolder stowType refType refStowType stowPath tag ec=0

  for tag; do
    stow_set_info "$tag"                          # -> refPath stowFolder stowType
    ! stow_is_orphan && continue
    stow_set_tag_info                             # -> refPath refType refStowType
    # io_trace "stow_adopt_tags 1 -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    refStowType=${refStowType/other./active.}
    refStowType=${refStowType/.orphan/.root}
    stow_set_folder "$refStowType"                # -> stowPath
    # io_trace "stow_adopt_tags 2 -- $(print_vars tag stowFolder refPath stowType refStowType refType stowPath)"
    tag_move "$tag" "$stowPath"
  done
  return $ec
}
stow_remove_duplicate_tags()
{
  local refPath stowFolder stowType tag tag1 tag2 ec=0

  # group by namespace
  declare -A archiveMap
  declare -A otherMap
  declare -A twinMap
  declare -A activeMap
  for tag; do
    stow_set_info "$tag" # -> refPath stowFolder stowType
    case ${stowType%.*} in
    archive) archiveMap[$refPath]=$tag;;
    other)   otherMap[$refPath]=$tag;;
    twin)    twinMap[$refPath]=$tag;;
    active)  activeMap[$refPath]=$tag;;
    esac
  done
  # delete archive tags in other twin and active namespaces
  for refPath in ${!archiveMap[@]}; do
    tag1=${archiveMap[$refPath]}
    tag2=${otherMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset otherMap[$refPath]
    fi
    tag2=${twinMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset twinMap[$refPath]
    fi
    tag2=${activeMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset activeMap[$refPath]
    fi
  done
  # delete other tags in twin and active namespace
  for refPath in ${!otherMap[@]}; do
    tag1=${otherMap[$refPath]}
    tag2=${twinMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset twinMap[$refPath]
    fi
    tag2=${activeMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset activeMap[$refPath]
    fi
  done
  # delete active tags in twin namespace
  for refPath in ${!activeMap[@]}; do
    tag1=${activeMap[$refPath]}
    tag2=${twinMap[$refPath]}
    if [[ -n $tag2 ]] && ref_equals $tag1 $tag2; then
      tag_delete $tag2 || ec=$?
      unset twinMap[$refPath]
    fi
  done
}
stow_promote_vtags()
{
  local branches=(${!1}) stowType stowFolder refPath refType refStowType \
        vtag vtag2 vbranch vbranchFolder vbranchFolders vbranchPairs vtagFolder version
  shift

  # group vbranchFolder:vbranch pair by version
  declare -A vbranchMap
  for vbranch in "${branches[@]}"; do
    if [[ $vbranch =~ ^(.*/)?([0-9]+\.[0-9]+) ]]; then
      vbranchFolder=${BASH_REMATCH[1]:-/}
      version=${BASH_REMATCH[2]}
      vbranch=$(branch_realize "$vbranch")
      vbranchMap[$version]="${vbranchMap[$version]} "$vbranchFolder:$vbranch""
      # io_trace "stow_promote_vtags 1 -- vbranchMap[$version]=${vbranchMap[$version]}"
    fi
  done
  # group vtags by version
  declare -A vtagMap
  for vtag; do
    if [[ $vtag =~ ^(.*/)?(v?([0-9]+\.[0-9]+).*)$ ]]; then
      version=${BASH_REMATCH[3]}
      vtagMap[$version]="${vtagMap[$version]} "$vtag""
    fi
  done
  for version in "${!vtagMap[@]}"; do
    vbranchPairs=( ${vbranchMap[$version]} )
    [ ${#vbranchPairs[@]} -eq 0 ] && continue
    # io_trace "stow_promote_vtags 2 -- $(print_vars version vbranchPairs[@])"
    for vtag in ${vtagMap[$version]}; do
      # remove non descendant vbranches
      local vbranchTagPairs=()
      for vbranchPair in ${vbranchPairs[@]}; do
        vbranch=${vbranchPair#*:}
        # skip vbranch with suffix (ex: 1.9-og)
        [[ $vbranch =~ ^(.*/)?[0-9]+\.[0-9]+$ ]] || continue
        _stow_check_ancestry && vbranchTagPairs+=("$vbranchPair")
      done
      if [ ${#vbranchTagPairs[@]} -eq 0 ]; then
        for vbranchPair in ${vbranchPairs[@]}; do
          vbranch=${vbranchPair#*:}
          # keep only branch with suffix
          [[ $vbranch =~ ^(.*/)?[0-9]+\.[0-9]+$ ]] && continue
          _stow_check_ancestry && vbranchTagPairs+=("$vbranchPair")
        done
      fi

      [ ${#vbranchTagPairs[@]} -eq 0 ] && continue
      [[ $vtag =~ ^(.*/)?(.*)$ ]] # split to folder / name
      vtagFolder=${BASH_REMATCH[1]:-/}
      vtagName=${BASH_REMATCH[2]}

      vbranchFolders=( ${vbranchTagPairs[@]%:*} )
      # only one branch for this vtag
      if [ ${#vbranchFolders[@]} -eq 1 ]; then
        vbranchFolder=${vbranchFolders[0]}
        if [[ $vbranchFolder != $vtagFolder ]]; then
          vtag2="${vbranchFolder#/}$vtagName"
          # io_trace "stow_promote_vtags 3 -- $(print_vars vtag vtagFolder vbranchFolder vtag2)"
          stow_set_info "$vtag2"          # -> stowType stowFolder refPath
          stow_set_tag_info "$vtag"       # -> refType refStowType refPath
          stow_set_folder "$refStowType"  # -> stowPath
          tag_move "$vtag" "$stowPath"
        fi
      # more than one branch for this vtag
      # already stowed if any vbranch folder equals vtag folder
      elif ! array_contains_element "$vtagFolder" "${vbranchFolders[@]}"; then
        unset vbranchFolder
        local deltaMin=0xFFFF
        for vbranchPair in "${vbranchTagPairs[@]}"; do
          vbranch=${vbranchPair#*:}
          delta=$(( $(git rev-list --count "$vtag".."$vbranch") ))
          (( delta == deltaMin )) && break
          if (( delta < deltaMin )); then
            deltaMin=$delta
            vbranchFolder=${vbranchPair%:*}
            # io_trace "stow_promote_vtags 4 -- tag_resolve $(print_vars vtag vbranch deltaMin vbranchFolder)"
          fi
        done
        if [[ -n $vbranchFolder ]]; then
          vtag2="${vbranchFolder#/}$vtagName"
          # io_trace "stow_promote_vtags 5 -- $(print_vars vtag vtagFolder vbranchFolder vtag2)"
          stow_set_info "$vtag2"          # -> stowType stowFolder refPath
          stow_set_tag_info "$vtag"       # -> refType refStowType refPath
          stow_set_folder "$refStowType"  # -> stowPath
          tag_move "$vtag" "$stowPath"
        fi
      fi
    done
  done
}
_stow_check_ancestry()
{
  if git merge-base --is-ancestor "$vtag" "$vbranch"; then
    return 0
  elif git merge-base --is-ancestor "$vbranch" "$vtag"; then
    io_info "Branch ${Brown}$vbranch${Cyan} should be fast forwarded to tag ${Brown}$vtag${Cyan}" "$moduleTracePrefix"
  else
    io_info "Tag ${Brown}$vtag${Cyan} is not associated with branch ${Brown}$vbranch${Cyan}" "$moduleTracePrefix"
  fi
  return 1
}
stow_orphans()
{
  local branches=(${!1}) vbranch version vtag vbranches 
  shift

  # group vbranchFolder:vbranch pair by version
  declare -A vbranchMap
  for vbranch in "${branches[@]}"; do
    if [[ $vbranch =~ ^(.*/)?([0-9]+\.[0-9]+) ]]; then
      version=${BASH_REMATCH[2]}
      vbranchMap[$version]="${vbranchMap[$version]} "$vbranch""
      # io_trace "stow_orphans 1 -- vbranchMap[$version]=${vbranchMap[$version]}"
    fi
  done
  # group vtags by version
  declare -A vtagMap
  for vtag; do
    if [[ $vtag =~ ^(.*/)?(v?([0-9]+\.[0-9]+).*)$ ]]; then
      version=${BASH_REMATCH[3]}
      vtagMap[$version]="${vtagMap[$version]} "$vtag""
    fi
  done
  for version in "${!vtagMap[@]}"; do
    vbranches=( ${vbranchMap[$version]} )
    if [ ${#vbranches[@]} -eq 0 ]; then
      stow_orphan_tags ${vtagMap[$version]}
    else
      stow_adopt_tags ${vtagMap[$version]}
    fi
  done
}
