#!/bin/bash

# Use the following statement to include current lib only once
#   [[ -z $ZOUL_GIT_COSM ]] && . zoul-git-cosm
ZOUL_GIT_COSM=true

[[ -z $ZOUL_GIT_MODULE ]]        && . zoul-git-module

# global options
#   noSkuFilter
#   noSelectFilter
#   showSubmoduleMessage
#   commitSubmodules
#   commitDirtySubmodules

branchChangedEvent+=( _cosm_on_branch_changed )
submoduleChangedEvent+=( _cosm_reset_scope )

# usage:
#   module_run config_scope cosm_scope $*
cosm_scope()
{
  # setup cosm context
  local unstagedCleanSubmodules unstagedDirtySubmodules \
        showSubmoduleMessage=true cosmScopeInitialized=true
  
  _cosm_reset_scope

  # execute next russian doll
  $1 "${@:2}"
}
cosm_has_unstaged_submodules()
{
  [ ${#unstagedCleanSubmodules[@]} -gt 0 ] || [ ${#unstagedDirtySubmodules[@]} -gt 0 ]
}

_cosm_on_branch_changed()
{
  _cosm_reset_scope

  [ ${#moduleSubmodulePaths[@]} -eq 0 ] && return 0
  _cosm_update_submodules_excluded_from_select
  _cosm_discard_submodules_excluded_from_sku
}
_cosm_reset_scope()
{
  [[ $cosmScopeInitialized == true ]] || return 0
  unstagedCleanSubmodules=()
  unstagedDirtySubmodules=()
  [ ${#moduleSubmodulePaths[@]} -eq 0 ] && return 0
  repo_split_unstaged_submodules "$moduleRoot"

  # io_lock_enter
  # io_trace_unsafe "_cosm_reset_scope -- $(print_vars unstagedCleanSubmodules[@])"
  # io_trace_unsafe "_cosm_reset_scope -- $(print_vars unstagedDirtySubmodules[@])"
  # io_lock_exit
}
  fi
}
# Update active submodules that are excluded from select
_cosm_update_submodules_excluded_from_select()
{
  [[ $commitExcludedSubmodules == true ]] && return 0
  local needUpdate=( $(array_remove_array 'configSelectExclude[@]' 'configSkuExclude[@]') )
  # io_trace "_cosm_update_submodules_excluded_from_select $(print_vars configSelectExclude[@] configSkuExclude[@] needUpdate[@])"
  if [ ${#needUpdate[@]} -ne 0 ]; then
    visit_async 'needUpdate[@]' 'repo_update_submodule'
  fi
}
_cosm_discard_submodules_excluded_from_sku()
{
  # discard unstaged clean submodules which are excluded from SKU
  local discard=( $(array_intersect_array 'unstagedCleanSubmodules[@]' 'configSkuExclude[@]') ) ec=0
  # io_trace "_cosm_discard_submodules_excluded_from_sku -- $(print_vars unstagedCleanSubmodules[@] discard[@])"
  if [ ${#discard[@]} -ne 0 ]; then
    visit_async 'discard[@]' 'repo_discard_submodule' || ec=$?
    unstagedCleanSubmodules=( $(array_remove_array 'unstagedCleanSubmodules[@]' 'discard[@]') )
  fi
  return $ec
}
# Process unstaged submodules
#   - update unselected submodules
#   - discard excluded submodules
#   - commit clean submodules
#   - optionnally commit dirty submodules
# exemple:
#   commitDirtySubmodules=true
#   cosm_scope cosm_node
cosm_process_unstaged_submodules()
{
  [ ${#moduleSubmodulePaths[@]} -eq 0 ] && return 0
  [[ $commitSubmodules == true ]] || return 0

  # io_trace "cosm_process_unstaged_submodules -- $(print_vars unstagedCleanSubmodules[@] unstagedDirtySubmodules[@])"

  if [[ $commitDirtySubmodules == true ]]; then
    local unstaged=( "${unstagedCleanSubmodules[@]}" "${unstagedDirtySubmodules[@]}" )
    repo_commit_submodules "$moduleRoot" $(array_remove_array 'unstaged[@]' 'configSkuExclude[@]')
  else
    repo_commit_submodules "$moduleRoot" $(array_remove_array 'unstagedCleanSubmodules[@]' 'configSkuExclude[@]')
    _cosm_dirty_warning
  fi
}
_cosm_dirty_warning()
{
  if [ ${#unstagedDirtySubmodules[@]} -ne 0 ]; then
    if [ ${#unstagedDirtySubmodules[@]} -eq 1 ]; then
      mio_message "Submodule '${unstagedDirtySubmodules[0]}' is dirty and has not been commited." ${Purple}
    else
      mio_message "Submodules '$(string_join ', ' ${unstagedDirtySubmodules[@]})' are dirty and have not been commited." ${Purple}
    fi
    mio_message "  use 'git cosm -f' to force a commit." ${Purple}
  fi
}
