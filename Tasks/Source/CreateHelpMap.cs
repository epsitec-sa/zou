using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Build.BuildEngine;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace Epsitec.Zou
{
	public class CreateHelpMap: Task
	{
		// Format sample:
		//	HIDR_MAINFRAME	0x20002
		[Required]
		public string[] HelpIds
		{
			get;
			set;
		}
		// Format example:
		//	html\afx_hidd_font.htm
		[Required]
		public string[] Topics
		{
			get;
			set;
		}
		// Format example:
		//	hid_edit_navprev		navigation
		public string[] Synonyms
		{
			get;
			set;
		}
		[Output]
		public string[] Items
		{
			get;
			private set;
		}
		public override bool			Execute()
		{
			try
			{
				this.Items = this.GetMapElements ().ToArray ();
			}
			catch (Exception e)
			{
				this.Log.LogErrorFromException (e);
			}
			return !this.Log.HasLoggedErrors;
		}

		private IEnumerable<string> GetMapElements()
		{
			// symbol -> relative path
			var symPathLookup = this.Topics
				.ToLookup (topic => Path.GetFileNameWithoutExtension (topic).ToLowerInvariant ());

			// check that topic file names are unique
			symPathLookup.ForEach (item =>
			{
				if (item.Count () > 1)
				{
					var pathes = string.Join (", ", item);
					this.Log.LogError ($"duplicate topic file names are forbidden: {{ {pathes} }}");
				}
			});

			// symbol -> symbol
			var synonymLookup = this.Synonyms?
				.Select (line => KeyValueRegex.Match (line))
				.Where (match => match.Success)
				.Select (match => new
				{
					Symbol = match.Groups[1].Value,
					Synonym = match.Groups[2].Value.ToLowerInvariant ()
				})
				.ToLookup (a => a.Symbol, a => a.Synonym);

			// merge synonyms with C/C++ help ID symbols
			// symbol -> values
			var symVals = this.HelpIds
				.Select (line => KeyValueRegex.Match (line))
				.Where (match => match.Success)
				.SelectMany (match =>
				{
					var symbol = match.Groups[1].Value.ToLowerInvariant ();
					var value = int.Parse (match.Groups[2].Value.Substring (2), NumberStyles.HexNumber);
					var synonyms = synonymLookup?[symbol] ?? Enumerable.Empty<string> ();
					return EnumerableEx
						.Return (symbol)
						.Concat (synonyms)
						.Distinct ()
						.Select (sym => new
						{
							Symbol = sym,
							Value = value
						});
				})
				.ToArray ();

			// filter with existing topic files
			var symValLookup = symVals
				.Where (a => symPathLookup
					.Select(item => item.Key)
					.Contains (a.Symbol, StringComparer.OrdinalIgnoreCase))
				.ToLookup (a => a.Symbol, a => a.Value);

			// value -> symbol
			var valSymLookup = symValLookup
				.SelectMany (helpId => helpId.Select (value => new
				{
					Value = value,
					Symbol = helpId.Key
				}))
				.OrderBy (a => a.Symbol)
				.ToLookup (a => a.Value, a => a.Symbol);

			yield return "// This file has been generated by zou, do not modify it.";
			yield return " ";
			if (valSymLookup.Count == 0)
			{
				this.Log.LogWarning ("could not find any matching help topic");
			}
			else
			{
				foreach (var valSym in valSymLookup)
				{
					var sym = valSym.OrderBy (_ => _).First ();
					var url = symPathLookup[sym].Single ().Replace ('\\', '/');
					var mapElement = $"{{ 0x{valSym.Key:X4}, _T(\"{url}\") }},";

					if (valSym.Count () > 1)
					{
						var values = string.Join (" and ", valSym.Select (x => $"\"{x}\""));
						var warning = $"topics {values} have the same ID (0x{valSym.Key:X4}), using \"{sym}\"...";
						this.Log.LogWarning (warning);
						yield return $"// WARNING: {warning}";
					}
					yield return mapElement;
				}
			}
		}

		// Match this:
		//   HID_FILE_NEW	0x1E100		// comment
		// But not C++ line comment:
		//   // C++ line comment

		private static readonly Regex KeyValueRegex = new Regex("^(?<!\\s*//\\s*)(\\w+)\\s*(\\w+)", RegexOptions.CultureInvariant | RegexOptions.Compiled);
	}
}
